#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage {a4wide}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter beramono
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 80

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_author "Maks Verver"
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Title goes here
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
A 
\emph on
parity game
\emph default
 is a game played by two players, called Even and Odd, on a directed graph.
 Each vertex in the graph is associated with (
\emph on
owned
\emph default
 or 
\emph on
controlled
\emph default
 by) one of the two players.
 Furthermore, to each vertex a 
\emph on
priority
\emph default
 is assigned, which is a non-negative integer.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename illustrations/introduction-example.svg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
A small example of a parity game
\begin_inset CommandInset label
LatexCommand label
name "fig:introduction-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are different conventions for the player's names.
 They may be called Even and Odd, or denoted by symbols ◇ and ◻, which is
 particularly useful when visualizing games, as can be seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:introduction-example"

\end_inset

: the shape of the vertices corresponds with the players that control them.
 For the description of algorithms and data structures, especially when
 computations are involved, it is more convenient to use integers 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

.
 For example, if we consider a player 
\begin_inset Formula $x$
\end_inset

, his opponent is 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
Formally, a parity game can be described as a quadruple 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

, where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V=V_{0}\cup V_{1}$
\end_inset

 and 
\begin_inset Formula $V_{0}\cap V_{1}=\emptyset$
\end_inset

 (in other words: 
\begin_inset Formula $V_{\text{0}}$
\end_inset

 and 
\begin_inset Formula $V_{\text{1}}$
\end_inset

 partition the set of graph vertices 
\begin_inset Formula $V$
\end_inset

 into those controlled by
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 Even and Odd respectively).
 
\begin_inset Formula $E\subseteq V\times V$
\end_inset

 is the set of directed edges in the game graph.
 This set may contain loops (edges which lead from a vertex back to itself).
 
\begin_inset Formula $\phi:V\rightarrow\mathbb{N}_{0}$
\end_inset

 is the priority function that assigns a priority to every vertex in the
 graph.
 The number of distinct priority values assigned to vertices in the game,
 is called the 
\emph on
index of the game
\emph default
, wich is equal to the cardinality of the range of 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
Parity games can be played on finite as well as infinite graphs.
 A finite parity game is played on a graph with a finite number of vertices;
 in this case, the number of edges and the index of the game will be finite
 as well.
\end_layout

\begin_layout Subsection
Game Play and Winning Conditions
\end_layout

\begin_layout Standard
A parity game is played by placing a token on some initial vertex.
 The player controlling that vertex moves the token to an adjacent vertex,
 which may belong to either player, who then makes the next move.
 When the token lands on a vertex without any outgoing edges, the game ends.
 However, it is more common for a game to continue indefinitely, causing
 an infinite sequence of moves.
 The sequence of moves on the graph is called a 
\emph on
play
\emph default
 and it can be described as the sequence of vertices visited by the token.
 Formally, a sequence 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\pi=v_{1}v_{2}\ldots v_{n}$
\end_inset

 is a (finite) play if and only if 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\forall i<n,\ v_{i}v_{i+1}\in E$
\end_inset

 and 
\begin_inset Formula $v_{n}$
\end_inset

 has no outgoing edges.
 Similarly, an infinite sequence 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is an (infinite) play if and only if 
\begin_inset Formula $\forall i\in\mathbb{N},\; v_{i}v_{i+1}\in E$
\end_inset

.
 A subsequence of a play (ending on some vertex with outgoing edges) is
 called a 
\emph on
partial play
\emph default
.
\end_layout

\begin_layout Standard
For finite plays, the player who is first unable to move is called the loser,
 and his opponent the winner.
 In a finite play, the loser is therefore simply the controller of the final
 vertex in the play.
\end_layout

\begin_layout Standard
For infinite plays, a more complicated notion of winning is used.
 Let the 
\emph on
dominant priority
\emph default
 
\begin_inset Formula $P(\pi)$
\end_inset

 for a play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 be the smallest value that occurs infinitely often in the sequence 
\begin_inset Formula $\phi(v_{1})\phi(v_{2})\ldots$
\end_inset

 or formally:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P(\pi)=\min\left\{ p\in\mathbb{N}_{0}:\ \forall i\ \exists j>i:\ \phi(v_{j})=p\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
A play is won by player Even if the dominant priority for the play is even,
 and won by Odd otherwise (hence their names).
 When the set of priorities is finite, the dominant priority is well-defined,
 assigning a winner to every infinite play.
\end_layout

\begin_layout Standard
It should be noted that there is no consensus in literature on how priorities
 should be ordered.
 Throughout this report I will use the convention of lower priority values
 taking precedence over higher values, thus 
\begin_inset Formula $0$
\end_inset

 being the 
\begin_inset Quotes eld
\end_inset

highest
\begin_inset Quotes erd
\end_inset

 priority, which is consistent with the definition given above.
\end_layout

\begin_layout Subsection
Strategies and Solutions
\end_layout

\begin_layout Standard
A strategy for player 
\begin_inset Formula $x$
\end_inset

 assigns a move to each position in which 
\begin_inset Formula $x$
\end_inset

 is to move.
 Formally, the strategy is a function 
\begin_inset Formula $\dot{\sigma}_{x}:V^{*}\times V_{x}\rightarrow V$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 such that if 
\begin_inset Formula $v_{1}\ldots v_{n}$
\end_inset

 is a partial play, then 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=v_{n+1}$
\end_inset

 and 
\begin_inset Formula $v_{1}\ldots v_{n+1}$
\end_inset

 is a (partial) play too.
 A play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is called consistent with a strategy 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
for player 
\begin_inset Formula $x$
\end_inset

 if 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{i})=v_{i+1}$
\end_inset

 for all 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $v_{i}\in V_{x}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
.
\end_layout

\begin_layout Standard
A strategy 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called 
\emph on
winning
\emph default
 for player 
\begin_inset Formula $x$
\end_inset

 at starting vertex 
\begin_inset Formula $v_{1}$
\end_inset

 if all plays 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 consistent with 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 are won by player 
\begin_inset Formula $x$
\end_inset

.
 Parity games of finite index have the important property that they are
 fully 
\emph on
determined
\emph default
, i.e.
 for every starting vertex either player Even or player Odd has a winning
 strategy.
 Thus, for these games, we can partition the vertex set 
\begin_inset Formula $V$
\end_inset

 of the game graph into two sets of vertices 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

 which can be won by player Even and Odd respectively.
 When the index is infinite, we can still identify disjoint sets 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

, but they may not be a true partition.
\end_layout

\begin_layout Standard
In many practical applications, determination of winning sets is enough
 to constitute a solution.
 For example, when using parity games as a vehicle for model checking, the
 question whether a formal property holds corresponds with the question
 wether a particular vertex in a game graph is won by player Even.
 In this case it suffices to determine the winner for this particular vertex
 only, without computing associated strategies, and even without fully determini
ng winning sets.
\end_layout

\begin_layout Standard
A limitation of calculating winning sets without associated strategies is
 that even if we assume the output to be correct, the winning sets alone
 do not provide any insight into 
\emph on
why
\emph default
 a particular vertex is won by a particular player.
 Strategies are useful to understand the outcome of the games.
 In the application of model checking, strategies can be used to show why
 a certain property holds, or generate counter-examples if it doesn't.
 Additionally, if we have not just a winning set, but also associated strategies
, we can check the correctness of a proposed solution without having to
 solve the game from scratch.
\end_layout

\begin_layout Standard
Therefore, 
\emph on
solving a game
\emph default
 in the most general sense means to identify optimal strategies for both
 players in addition to their winning sets.
 Note that even in finite games, strategies (unlike winning sets) do not
 complement each other, so given an optimal strategy for one player, we
 cannot (easily) deduce an optimal strategy for his opponent.
\end_layout

\begin_layout Subsection
Optimal Strategies and Finite Memory
\end_layout

\begin_layout Standard
A strategy 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called an 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
optimal strategy
\emph default
 when it is winning for player 
\begin_inset Formula $x$
\end_inset

 starting from any vertex 
\begin_inset Formula $v\in W_{x}$
\end_inset

.
\end_layout

\begin_layout Standard
Strategies as described above are called 
\emph on
infinite-memory strategies
\emph default
, because they can take the entire move history into account to determine
 the next move.
 In contrast, 
\emph on
memoryless strategies
\emph default
 are strategies which depend only on the current position of token, i.e.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=\dot{\sigma}_{x}(w_{1}\ldots w_{n})$
\end_inset

 whenever 
\begin_inset Formula $v_{n}=w_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
We will define memoryless strategies as functions 
\begin_inset Formula $\sigma_{x}:V_{x}\rightarrow V$
\end_inset

 such that if
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\sigma_{x}(v)=w$
\end_inset

 then 
\begin_inset Formula $vw\in E$
\end_inset

.
 A memoryless strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 is then consistent with a play 
\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset

 if 
\begin_inset Formula $\sigma_{x}(v_{i})=v_{i+1}$
\end_inset

 for all 
\begin_inset Formula $v_{i}\in V_{x}$
\end_inset

.
 We can restrict the domain of 
\begin_inset Formula $\sigma_{\text{x}}$
\end_inset

 to 
\begin_inset Formula $V_{\text{x}}\cap W_{x}$
\end_inset

 since for vertices in 
\begin_inset Formula $V_{x}$
\end_inset

 but not in 
\begin_inset Formula $W_{\text{x}}$
\end_inset

, player 
\begin_inset Formula $x$
\end_inset

 has no winning move, and therefore any adjacent vertex can be selected
 without affecting the optimality of the strategy.
 Even if we leave out these vertices for which the controlling player has
 no winning move, optimal strategies are not (necessarily) uniquely defined,
 unlike winning sets.
\end_layout

\begin_layout Standard
Sometimes we want to refer to the combined strategies of both players, 
\begin_inset Formula $\sigma$
\end_inset

, defined as:
\begin_inset Formula 
\[
\sigma(v)=\begin{cases}
\sigma_{0}(v) & \mbox{if }v\in V_{0}\\
\sigma_{1}(v) & \mbox{if }v\in V_{1}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
It turns out that for all games of finite index optimal memoryless strategies
 exist.
 Research on finite-order games typically focuses on finding memoryless
 strategies for both players, which can be described succinctly by simply
 listing an optimal move for every vertex.
\end_layout

\begin_layout Standard
This report is about finding optimal strategies to finite parity games,
 and therefore the term 
\emph on
strategy
\emph default
 without further qualification will be used to mean 
\emph on
optimal memoryless strategy
\emph default
, and the 
\emph on
solution
\emph default
 to a parity game is a triple 
\begin_inset Formula $W_{0},W_{1},\sigma$
\end_inset

 describing the winning sets and optimal strategy for both players.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename illustrations/introduction-example-solved.svg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The example game solved
\begin_inset CommandInset label
LatexCommand label
name "fig:introduction-example-solved"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:introduction-example-solved"

\end_inset

 the solution for the example game presented earlier is shown.
 Vertices are partioned into winning sets for both players.
 Edges that cannot be part of winning strategies are dashed.
 In this particular case, any of the solid edges can be chosen to yield
 an optimal strategy.
\end_layout

\begin_layout Section
Computational Complexity
\end_layout

\begin_layout Standard
Given a polynomial-time algorithm to verify the optimality of a pair of
 winning strategies (one such algorithm will be presented later on), the
 general problem of determining winning sets as well as strategies can be
 solved by nondeterministically guessing the winner and an optimal move
 for each vertex, which puts the problem in NP (the set of problems decidable
 by a non-deterministic Turing machine and verifiable by a deterministic
 Turing machine in polynomial time) and co-NP (by symmetry of the problem:
 absence of a winning strategy for one player can be proven by showing a
 winning strategy for the other player).
 The strategies are certificates to the solution.
\end_layout

\begin_layout Standard
NP and co-NP are generally believed to be distinct, and since the existence
 of NP-hard problems in co-NP would imply NP = co-NP, it seems unlikely
 that the problem is NP-hard.
 This makes it plausible that there should be a polynomial-time algorithm
 to solve parity games, but despite considerable research interest, none
 have been found.
\end_layout

\begin_layout Standard
If there exists a polynomial-time algorithm that determines winning sets
 only (without associated strategies) then full solutions can be constructed
 in polynomial time too.
 This restricted problem has been shown to be in UP 
\begin_inset Formula $\cap$
\end_inset

 co-UP 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski1998deciding"

\end_inset

 where UP is the subset of NP containing those problems that are decidable
 by an 
\emph on
unambiguous
\emph default
 nondeterministic Turing machine.
 Since P 
\begin_inset Formula $\subseteq$
\end_inset

 UP 
\begin_inset Formula $\subseteq$
\end_inset

 NP this is a stronger result, although it is not known whether P 
\begin_inset Formula $\subset$
\end_inset

 UP or UP 
\begin_inset Formula $\subset$
\end_inset

 NP (or both, or neither).
\end_layout

\begin_layout Standard
The best currently known algorithms are either exponential in game index
 
\begin_inset Formula $d$
\end_inset

 (for example, Jurdziński's Small Progress Measures algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset

 has an upper bound of 
\begin_inset Formula $O\left(d\left|E\right|\left(\frac{\left|V\right|}{\left\lfloor d/2\right\rfloor }\right)^{\left\lfloor d/2\right\rfloor }\right)$
\end_inset

 ) while others are instead subexponential in the size of the game graph
 (for example, Jurdziński, Paterson and Zwick give an 
\begin_inset Formula $\left|V\right|^{O(\sqrt{\left|V\right|})}$
\end_inset

 algorithm in 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2006deterministic"

\end_inset

).
\end_layout

\begin_layout Standard
Often 
\begin_inset Formula $d$
\end_inset

 is small and therefore the first category of algorithms provides better
 complexity bounds.
 However, in practice many instances can be solved much faster than the
 worst case time complexity would suggest, and worst-case complexity bounds
 don't predict which algorithms work best in practice.
\end_layout

\begin_layout Section
Application To Model Checking
\end_layout

\begin_layout Standard
The most notable practical application of parity games is their suitability
 as a component in model checking systems, which attempt to verify whether
 a model of a system (typically expressed in some high-level formal language)
 satisfies a certain specification (typically captured in a temporal logic
 formula).
\end_layout

\begin_layout Standard
Model checking tools must balance two concerns: on the one hand, the specificati
on language available to the user should be as expressive as possible, while
 on the other hand, the internal representation of the resulting model checking
 problem should be kept simple enough so that it can be solved quickly using
 provably-correct algorithms.
\end_layout

\begin_layout Standard
Parity games fit these constraints well because they can be used to express
 whether a property specified in the modal 
\begin_inset Formula $\mu$
\end_inset

-calculus holds on a labelled transition system (LTS) 
\begin_inset CommandInset citation
LatexCommand cite
key "emerson1991tree"

\end_inset

.
 Since many high-level specification languages can be converted into labelled
 transition systems, and many temporal logics (such as CTL and LTL) can
 be expressed in the modal 
\begin_inset Formula $\mu$
\end_inset

-calculus, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
citation?
\end_layout

\end_inset

 efficient algorithms for solving parity games could provide the basis of
 a comprehensive approach to model checking.
\end_layout

\begin_layout Standard
Not only are parity games sufficiently powerful to express these problems,
 but conversion from the model checking problem to parity games yields reasonabl
y compact games, where the number of vertices equals the product of the
 number of states in the LTS and the number of subexpressions in the 
\begin_inset Formula $\mu$
\end_inset

-calculus formula, and the number of priorities corresponds with the alternation
 depth of fixed-point operators in the formula (for example, see 
\begin_inset CommandInset citation
LatexCommand cite
key "obdrzalek2006algorithmic"

\end_inset

 for one explicit construction method).
 Finally, these games can be constructed in linear time, and thus model
 checking via parity games would be a very practical approach, assuming
 the resulting parity games can be solved quickly.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
The work related to mine falls into three broad categories: theoretical
 work on parity game algorithms, practical work on formulating problems
 as parity games, and implementations of parity game algorithms.
 I will summarize the developments most relevant to my project in this section.
\end_layout

\begin_layout Subsection
Automata theory and parity game algorithms 
\begin_inset CommandInset label
LatexCommand label
name "sub:Automata-and-PG-algorithms"

\end_inset


\end_layout

\begin_layout Standard
A considerable amount of literature is available on parity games specifically
 and more generally on perfect-information games played on (possibly infinite)
 graphs and trees, as well as their relationship to computing automata and
 their application to model checking.
 The majority of this work is theoretical in nature.
\end_layout

\begin_layout Standard
An important property of parity games is the fact that the winner can be
 determined for every vertex using memoryless strategies.
 A proof of determinacy of Borel games, of which parity games are a specializati
on, was first formulated by Donald A.
 Martin 
\begin_inset CommandInset citation
LatexCommand cite
key "martin1975borel"

\end_inset

.
 For Borel games with a Rabin winning condition, of which the parity condition
 is a special case, Klarlund proved that memoryless strategies exist 
\begin_inset CommandInset citation
LatexCommand cite
key "klarlund1994progress"

\end_inset

.
 Both of these results are more general than needed for parity games; Zielonka
 gives two direct proofs for the memoryless determinacy of parity games
 specifically 
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset

.
\end_layout

\begin_layout Standard
Some of the terminology introduced to discuss more general classes of games
 (like Muller games, which cannot generally be solved with memoryless strategies
) is also useful for discussing parity games, and these will be repeated
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Common-Terminology"

\end_inset

.
\end_layout

\begin_layout Standard
For parity games specifically, many solving algorithms have been proposed,
 including:
\end_layout

\begin_layout Itemize
A recursive algorithm based on a constructive proof of determinacy, first
 described by McNaughton 
\begin_inset CommandInset citation
LatexCommand cite
key "mcnaughton1993infinite"

\end_inset

 and reformulated for parity games by Zielonka 
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset


\end_layout

\begin_layout Itemize
Fixed-point iteration using Small Progress Measures by Jurdziński 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset


\end_layout

\begin_layout Itemize
Strategy improvement by Vöge and Jurdziński 
\begin_inset CommandInset citation
LatexCommand cite
key "voege2000discrete"

\end_inset


\end_layout

\begin_layout Itemize
A randomized subexponential algorithm by Björklund, Sandberg and Vorobyov
 
\begin_inset CommandInset citation
LatexCommand cite
key "bjorklund2003discrete"

\end_inset


\end_layout

\begin_layout Itemize
A deterministic subexponential algorithm by Jurdziński, Paterson and Zwick
 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2006deterministic"

\end_inset


\end_layout

\begin_layout Itemize
A “big steps” improvement by Schewe 
\begin_inset CommandInset citation
LatexCommand cite
key "schewe2007solving"

\end_inset

 that combines both McNaughton's and Jurdziński's algorithms
\end_layout

\begin_layout Itemize
Optimal strategy improvement by Schewe 
\begin_inset CommandInset citation
LatexCommand cite
key "schewe2008strategy-improvement"

\end_inset


\end_layout

\begin_layout Standard
Additionally, various indirect approaches to solving parity games by reduction
 to other formulations such as SAT (
\begin_inset CommandInset citation
LatexCommand cite
key "lange2005sat"

\end_inset

) and Boolean equation systems have been proposed.
\end_layout

\begin_layout Standard
This gives plenty of algorithms to choose from, though there is no agreement
 on which algorithms work best in practice.
 Schewe favours approaches based on strategy improvement, stating these
 are: 
\emph on

\begin_inset Quotes eld
\end_inset

[..] fast simplex style algorithms that perform well in practice.
 While their complexity is wide open, they are often considered the best
 choice for solving large scale games.
\emph default

\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schewe2008strategy-improvement"

\end_inset


\end_layout

\begin_layout Standard
However, Friedmann and Lange have performed an emperical evaluation of various
 algorithms, and conclude that 
\emph on

\begin_inset Quotes eld
\end_inset

the small progress measures algorithm as well as the strategy improvement
 turn out to be generally slower than the recursive algorithm
\emph default

\begin_inset Quotes erd
\end_inset

 and conclude that 
\emph on

\begin_inset Quotes eld
\end_inset

Zielonka’s recursive algorithm is the best parity game solver in practice
\emph default

\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

.
\end_layout

\begin_layout Subsection
Model checking tools
\end_layout

\begin_layout Standard
At least two formal verification systems exist that can transform model
 checking problems into parity games:
\end_layout

\begin_layout Enumerate
The mCRL2 toolkit 
\begin_inset CommandInset citation
LatexCommand cite
key "groote2008mcrl2"

\end_inset

 composes models and formulae into parametrized Boolean equation systems
 (PBES) 
\begin_inset CommandInset citation
LatexCommand cite
key "groote2005parameterised"

\end_inset

, can linearize these into boolean equation systems (BES), and either solve
 those directly (with a tool called 
\family typewriter
pbes2bool
\family default
) or translate them into parity games instead.
\end_layout

\begin_layout Enumerate
The LTSmin toolkit 
\begin_inset CommandInset citation
LatexCommand cite
key "blom2010ltsmin"

\end_inset

 supports a different approach: it transforms a PBES into a parametrized
 parity game (PPG) and then generates the parity game directly 
\begin_inset CommandInset citation
LatexCommand cite
key "kant2012pbes2pg"

\end_inset

.
 This approach was motivated by the observation that linearization of the
 PBES was often the slowest step in the solution process, and that optimization
 of this conversion can drastically reduce both time and memory required.
\end_layout

\begin_layout Standard
In both of these toolkits, the parametrized forms tend to be fairly small,
 while the linearized forms (and therefore the final parity game) may be
 quite large.
 Model checking using a parity game solver as a backend is viable only if
 the resulting parity games can reasonably fit into memory.
 This is a limitation shared with many other approaches to model checking
 (in particular those relying on explicit state space exploration).
\end_layout

\begin_layout Subsection
Parity game solvers
\end_layout

\begin_layout Standard
Although many algorithms have been proposed in literature (as discussed
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Automata-and-PG-algorithms"

\end_inset

) few implementations are mentioned, and there is little discussion of practical
 considerations (speed in practice, memory use, parallelizability, distributabil
ity, et cetera).
 This is suprising: considering the utility of parity game solvers as part
 of a model checking toolchain, and the notorious gap between theoretical
 time complexity and solving time required in practical instances, one would
 imagine there to be more research interest in determining which algorithms
 work well in practice.
\end_layout

\begin_layout Standard
The main exception is PGSolver (
\emph on
“a collection of tools for generating, manipulating and - most of all -
 solving parity games”
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "pgsolver"

\end_inset

) which implements a large number of algorithms described in literature,
 as well as a number of preprocessing operations to simplify instances before
 passing them on to a solver backend.
 This tool is actively maintained, and forms the basis of Friedmann and
 Lange's empirical evaluation 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

.
\end_layout

\begin_layout Standard
Jeroen Keiren also used PGSolver to evaluate the suitability of parity game
 algorithms to solve the Boolean equation systems generated by the mCRL2
 toolkit.
\begin_inset CommandInset citation
LatexCommand cite
key "keiren2009"

\end_inset

 Although PGSolver is a powerful tool, it also has some limitations: it's
 a strictly sequential solver that doesn't support parallel or distributed
 solving, and since it is implemented in OCaml, it relies on automatic memory
 management, which may not be very efficient (especially when solving large
 problems).
\end_layout

\begin_layout Standard
It should be mentioned that Van de Pol and Weber developed a multi-core
 implementation of Small Progress Measures 
\begin_inset CommandInset citation
LatexCommand cite
key "vandepol2008multicore"

\end_inset

 (the first parallel implementation of a parity game algorithm).
 However, their tool is unmaintained and because of the limited scope of
 their experiments, not very suitable for general use.
\end_layout

\begin_layout Standard
In summary, it appears that PGSolver is the only comprehensive tool easily
 available to users that have a parity game problem to solve.
\end_layout

\begin_layout Section
My Contributions
\end_layout

\begin_layout Standard
From the above it should be clear that there is a gap between theory and
 practice with respect to the use of parity games as a vehicle for formal
 verification.
 On the practical side there is a desire to efficiently solve model checking
 problems that arise in practice.
 Tool support to express these problems as parity games already exists.
 On the theoretical side there is no dearth of proposed algorithms for solving
 parity games, but there is only one tool that actually implements these
 algorithms: PGSolver.
\end_layout

\begin_layout Standard
It should come as no surprise that my contributions lie in this area.
 The main deliverable of my master's project, besides this report, is an
 efficient parity game solving tool which improves upon the state of the
 art in several ways:
\end_layout

\begin_layout Itemize
For mCRL2 my tool provides an alternative to 
\family typewriter
pbes2bool
\family default
 (the default solver for PBES) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
any examples of where my tool is faster / uses less memory?
\end_layout

\end_inset

.
 My solver has already been integrated into mCRL2 as an experimental tool
 called 
\family typewriter
pbespgsolve
\family default
 which can be used today.
\end_layout

\begin_layout Itemize
Compared to PGSolver, my tool features fewer different solver algorithms,
 but better preprocessing routines and heuristics.
 My tool typically uses less time and space to solve testcases, sometimes
 dramatically so.
\end_layout

\begin_layout Standard
I want to stress that improving upon PGSolver was not a goal of the project
 in itself.
 However, having independent implementations of some of the critical algorithms
 (in different programming languages and using different data structures)
 is very useful to put empirical data such as reported by Friedmann and
 Lange in perspective, because it helps quantify to which extent results
 depend on the performance of the algorithms themselves and to which extent
 they are influenced by implementation techniques.
\end_layout

\begin_layout Standard
My solver also includes a few innovations that are documented in this report:
\end_layout

\begin_layout Itemize
A new preprocessing technique which removes cycles controlled by a single
 player from the game (described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Winner-controlled-cycle-removal"

\end_inset

)
\end_layout

\begin_layout Itemize
An efficient strategy verification algorithm that is not dependent on any
 solving algorithm (described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Verification"

\end_inset

) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: how does verification work in PGsolver‽
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
An optimization of the small progress measures algorithm (described in subsectio
n 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimization-after-lifting"

\end_inset

)
\end_layout

\begin_layout Itemize
A new heuristic for the small progress measures algorithm (described in
 subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Maximum-Measure-Propagation"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
+ add: Parallel/distributed implementations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, my report includes an empirical evaluation of these algorithms
 and techniques (some novel, some only known from literature, and some previousl
y evaluated) in order to give more insight in which techniques are most
 useful when solving parity games in practice (in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Empirical-Evaluation"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The rest of the report should be structured around describing/proving these
 contributions.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Building blocks for parity game solvers
\end_layout

\begin_layout Standard
Before discussing algorithms used to solve parity games, it is useful to
 establish some common terminology related to parity game theory.
 Most of this terminology comes from literature, but since the terms used
 and their meaning varies considerably, it is necessary to definite the
 concepts and terms that will be used in the rest of this report.
\end_layout

\begin_layout Standard
First, a number of restrictions on the game structure will be given, that
 simplify the definition and discussion of the algorithms and datastructures
 that follow.
 Second, a number of useful properties of parity games will be presented;
 none of these are new, but they will be defined in a manner consistent
 with the preceding definitions.
 Third, a number of notable special cases of parity games will be discussed;
 these deserve to be mentioned but are otherwise outside the scope of this
 report.
\end_layout

\begin_layout Standard
Finally, a polynomial-time algorithm for the verification of parity game
 algorithms will be presented, which is used to guarantee the correctness
 of the reported results.
\end_layout

\begin_layout Section
Restrictions on the graph
\end_layout

\begin_layout Standard
For convenience, I will assume that every vertex has at least one outgoing
 edge.
 This property makes finite plays impossible, which simplifies the analysis
 of many algorithms.
 We will call a game a 
\emph on
proper game
\emph default
 if its graph satisfies this property.
 However, improper games can be turned into proper games by considering
 each vertex without outgoing edges: if it is controlled by player 
\begin_inset Formula $x$
\end_inset

, we can change its priority to 
\begin_inset Formula $1-x$
\end_inset

 and add an edge from the vertex back to itself.
 In the modified graph every vertex has an outgoing edge, yet it has the
 same solution and winning strategies as the original graph.
\end_layout

\begin_layout Standard
Additionally, I will assume the game graph is finite.
 This has practical as well as theoretical benefits.
 From a practical point of view, since all of the game data is now finite,
 it allows us to represent graphs explicitly using only finite memory (otherwise
, a symbolic representation would be required).
 From a theoretical point of view, a finite vertex set allows for algorithms
 and proofs that do not generalize to infinite graphs.
\end_layout

\begin_layout Section
Restrictions on the set of priorities
\end_layout

\begin_layout Standard
When discussing actual implementations of data structures and algorithms,
 it is convenient to assume that the priorities in the game are not just
 integers, but bounded by a value that is as small as possible.
 Fortunately, we can reduce the values of priorities used to a range between
 0 and 
\begin_inset Formula $d$
\end_inset

 (exclusive), where 
\begin_inset Formula $d$
\end_inset

 is the index of the game.
 This is done by remapping priorities for vertices in a process called 
\emph on
priority compression.
\end_layout

\begin_layout Standard
Consider we have a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 and we wish to apply priority compression.
 To do so, we find the first unused priority (say, 
\begin_inset Formula $p$
\end_inset

) in the game.
 If 
\begin_inset Formula $p=d$
\end_inset

 then all priorities from 
\begin_inset Formula $0$
\end_inset

 through 
\begin_inset Formula $d-1$
\end_inset

 (inclusive) are used and we are done.
 Otherwise, let 
\series bold

\begin_inset Formula $q$
\end_inset


\series default
 be the least priority greater than 
\begin_inset Formula $p$
\end_inset

 that is used.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $p=0$
\end_inset

 then we can decrement all priorities by 
\begin_inset Formula $q$
\end_inset

 and, if 
\begin_inset Formula $q$
\end_inset

 is odd, we additionally switch the roles of players Even and Odd.
 Formally, we construct a game 
\begin_inset Formula $\Gamma'=(V_{\text{0}}',V_{\text{1}}',E,\phi')$
\end_inset

 where 
\begin_inset Formula $V_{x}'=V_{y}$
\end_inset

 and 
\begin_inset Formula $x=y-p\mod{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
, 
\begin_inset Formula $\phi'(v)=\phi(v)-q$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $p>0$
\end_inset

 then we keep 
\begin_inset Formula $V_{0}'=V_{0}$
\end_inset

 and 
\begin_inset Formula $V_{1}'=V_{1}$
\end_inset

.
 However, if 
\begin_inset Formula $p\equiv q\mod{2}$
\end_inset

 then we get rid of the unused priorities and lump the vertices with priority
 
\begin_inset Formula $q$
\end_inset

 in with those with priority 
\begin_inset Formula $p$
\end_inset

.
 After all, 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 have the same parity, and since none of the values in between are used,
 they can be interchanged without affecting the outcome of the game.
 More formally, in this case we define 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi'(v)$
\end_inset

 as:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 
\begin_inset Formula 
\[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q & \mbox{\mbox{if }\ensuremath{\phi(v)>p}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $p-q\equiv0\mod{2}$
\end_inset

 this preserves parity: 
\begin_inset Formula $\phi'(v)\equiv\phi(v)\mod{2}$
\end_inset

.
 Finaly, if 
\begin_inset Formula $p>0$
\end_inset

 and 
\begin_inset Formula $p\not\equiv q\mod{2}$
\end_inset

 then we can remove the unused priorities, but we do not want to equate
 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 which have different priorities:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q+1 & \mbox{\mbox{if} \ensuremath{\phi(v)>p}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Again, since 
\begin_inset Formula $p-q+1\equiv0\mod{2}$
\end_inset

 this preserves the parity of 
\begin_inset Formula $\phi$
\end_inset

 while removing the unused priorities between 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 Repeating this process to eliminate all the gaps results in a game which
 uses priorities form 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $d-1$
\end_inset

 (inclusive).
\end_layout

\begin_layout Standard
Most solving algorithms do not require that priorities are compressed into
 a minimal range, but since the amount of time and space required is often
 a function of the maximum priority that occurs in the game, it is useful
 to preprocess every game to minimize the priority set in this way, especially
 since this is can be easily done in 
\begin_inset Formula $O(V)$
\end_inset

 time.
\end_layout

\begin_layout Section
Common Terminology 
\begin_inset CommandInset label
LatexCommand label
name "sec:Common-Terminology"

\end_inset


\end_layout

\begin_layout Standard
There are a number of concepts which can be applied to parity games which
 have been described in literature before.
 In particular, Zielonka introduces some useful terminology in a treatise
 on two-player games played on coloured graphs (of which parity games are
 a subset) which will be repeated here.
 He describes attractor sets and traps.
 Additionally, I will describe subgames analogous to (though slightly different
 from) subarenas.
\end_layout

\begin_layout Subsection
Subgames
\end_layout

\begin_layout Standard
A 
\emph on
subgame
\emph default
 of a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 induced by a vertex set 
\begin_inset Formula $U\subseteq V$
\end_inset

 is the game 
\begin_inset Formula $\Gamma|U=(V_{0}\cap U,V_{1}\cap U,E\cap\left(U\times U\right),\phi|U)$
\end_inset

 where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi|U$
\end_inset

 denotes 
\begin_inset Formula $\phi$
\end_inset

 with its domain limited to 
\begin_inset Formula $U$
\end_inset

.
 In other words, the game obtained when only considering vertices from 
\begin_inset Formula $U$
\end_inset

 and ignoring the rest.
 
\begin_inset Formula $\Gamma|U$
\end_inset

 is called a 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
proper subgame
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 if it is a proper game as described above.
\end_layout

\begin_layout Subsection
Traps
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $vE$
\end_inset

 be the set of vertices which are successors of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $E$
\end_inset

, or formally 
\begin_inset Formula $vE=\{w\in V:\ vw\in E\}.$
\end_inset

 Analogously, 
\begin_inset Formula $Ew=\{v\in V:\ vw\in E\}$
\end_inset

.
 A non-empty vertex set 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $U\subseteq V$
\end_inset

 is a trap for player 
\begin_inset Formula $x$
\end_inset

 (or an 
\begin_inset Formula $x$
\end_inset

-trap, for short) when, informally, player 
\begin_inset Formula $x$
\end_inset

 cannot force the token out of 
\begin_inset Formula $U$
\end_inset

.
 Formally, 
\begin_inset Formula $U$
\end_inset

 is an 
\begin_inset Formula $x$
\end_inset

-trap if for all 
\begin_inset Formula $v\in U$
\end_inset

:
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula 
\[
v\in V_{x}\rightarrow vE\setminus U=\emptyset
\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula 
\[
v\in V_{1-x}\rightarrow vE\cap U\neq\emptyset
\]

\end_inset


\end_layout

\begin_layout Standard
In literature, 
\begin_inset Formula $x$
\end_inset

-traps are sometimes called 
\emph on
dominions
\emph default
 for player 
\begin_inset Formula $1-x$
\end_inset

 instead.
\end_layout

\begin_layout Subsection
Attractor sets
\begin_inset CommandInset label
LatexCommand label
name "sub:Attractor-sets"

\end_inset


\end_layout

\begin_layout Standard
An attractor set for a player 
\begin_inset Formula $x$
\end_inset

 on a vertex set 
\bar under

\begin_inset Formula $U\subseteq V$
\end_inset


\bar default
, denoted 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

, is the set of vertices from which the player 
\begin_inset Formula $x$
\end_inset

 can force the token into one of the vertices in 
\begin_inset Formula $U$
\end_inset

 (including, by definition, vertices in 
\begin_inset Formula $U$
\end_inset

 itself).
 Zielonka gives an iterative definition of an attractor set:
\begin_inset Formula 
\[
U_{0}=U
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
U_{i+1}=U_{i}\cup\{v\in V_{x}:\; vE\cap U_{i}\neq\emptyset\}\cup\{v\in V_{1-x}:\; vE\setminus U_{i}=\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Attr^{x}(\Gamma,U)=U_{0}\cup U_{1}\cup\cdots
\]

\end_inset


\end_layout

\begin_layout Standard
Since the graph is finite eventually 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
converges to some 
\begin_inset Formula $U_{i}\subseteq V$
\end_inset

 when 
\begin_inset Formula $U_{i}=U_{i+1}$
\end_inset

 and we can find that point by iteratively computing the sets up to this
 point.
 In practice a slightly different approach is used, as will be described
 in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Attractor-set-computation"

\end_inset

.
\end_layout

\begin_layout Standard
In literature, attractor sets are sometimes called 
\emph on
force sets
\emph default
 instead.
\end_layout

\begin_layout Subsubsection
Attractor strategies
\end_layout

\begin_layout Standard
An important property of attractor sets is that if 
\begin_inset Formula $U\subseteq W_{x}$
\end_inset

, then 
\begin_inset Formula $Attr^{x}(\Gamma,U)\subseteq W_{x}$
\end_inset

 too.
 Of course, if we know the optimal strategy for all vertices 
\begin_inset Formula $v\in U$
\end_inset

, then we also want to extend this strategy to 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

.
 Fortunately, this can easily be done: every vertex that first appears in
 
\begin_inset Formula $U_{i+1}$
\end_inset

 (i.e.
 it is a member of 
\begin_inset Formula $U_{i+1}\setminus U_{i}$
\end_inset

) has a successor in 
\begin_inset Formula $U_{i}$
\end_inset

, and when we repeatedly choose such a successor, then we arrive at 
\begin_inset Formula $U_{0}$
\end_inset

 in 
\begin_inset Formula $i$
\end_inset

 steps, at which point the rest of the strategy is known.
 Therefore, attractor set computation of a winning region with known strategy
 yields a stategy for the entire attractor set too.
\end_layout

\begin_layout Subsubsection
Duality between attractor sets and traps
\end_layout

\begin_layout Standard
The second important property of attractor sets is that the complement 
\begin_inset Formula $V'$
\end_inset

 of an attractor set for player 
\begin_inset Formula $x$
\end_inset

 (formally: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V'=V\setminus Attr^{x}(\Gamma,U)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
) is a trap for 
\begin_inset Formula $x$
\end_inset

.
 Moreover, if 
\begin_inset Formula $\Gamma$
\end_inset

 is a proper game, 
\begin_inset Formula $\Gamma|V'$
\end_inset

 is a proper subgame
\emph on
 
\emph default
of 
\begin_inset Formula $\Gamma$
\end_inset

, since if a vertex 
\begin_inset Formula $v\in V'$
\end_inset

 has no successor 
\begin_inset Formula $w\in V'$
\end_inset

 then all its successors must be in 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 would have, by definition, been in the attractor set, instead of its complement.
\end_layout

\begin_layout Standard
This property is important because it means that if we start with a proper
 game then we can safely remove attractor sets of arbitrary vertex sets
 to obtain proper subgames, which is not the case if we would remove arbitrary
 vertex sets.
 This technique can be used to break down a game in parts which are solved
 separately.
\end_layout

\begin_layout Section
Degenerate cases
\end_layout

\begin_layout Standard
In addition to games which do not comply with the restrictions mentioned
 earlier, there are also a few classes of degenerate games that are special
 cases of the general game describe above.
 They are mentioned separately because specific algorithms exist to solve
 them more quickly.
\end_layout

\begin_layout Standard
These special cases are occasionally provided as input to a solver (for
 example, as the representation of a particularly simple model checking
 problem) but more commonly they arise as subgames to be solved after preprocess
ing the game or after partial solving.
\end_layout

\begin_layout Subsection
Single-parity games
\begin_inset CommandInset label
LatexCommand label
name "sub:Single-priority-games"

\end_inset


\end_layout

\begin_layout Standard
If the priorities of vertices all have the same parity (even or odd) then
 the corresponding player will trivially win from every starting vertex,
 with an arbitrary strategy.
 A special case is the single-priority game, where only a single priority
 is used.
 Priority compression can be used to convert the former case to the latter.
\end_layout

\begin_layout Subsection
Single-player games
\end_layout

\begin_layout Standard
A parity game is a 
\emph on
single-player game for player 
\begin_inset Formula $x$
\end_inset

 
\emph default
when all vertices controlled by player 
\begin_inset Formula $1-x$
\end_inset

 have outdegree equal to 1.
 In such a game, only player 
\begin_inset Formula $x$
\end_inset

 can make choices, and player 
\series bold

\begin_inset Formula $1-x$
\end_inset


\series default
 is forced to always move the token to the single available successor whenever
 it lands on one of his vertices.
\end_layout

\begin_layout Standard
In such a game, player 
\begin_inset Formula $x$
\end_inset

 wins precisely from the vertices which lie on a cycle of which the minimum
 priority has parity equal to 
\begin_inset Formula $x$
\end_inset

, as well as from all vertices from which such a cycle can be reached.
 After all, his opponent has no choice, so he can never force the token
 out of a cycle or prevent player 
\begin_inset Formula $x$
\end_inset

 from reaching a cycle when there exists a path to it.
 The remaining vertices (if there are any) are won by player 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
In extremely rare cases the game is played on a graph consisting of cycles
 only and then neither player has a choice.
 In that case, strategies are trivial and the winner of each cycle corresponds
 to the parity of the least priority occuring on the cycle.
\end_layout

\begin_layout Subsection
Graphs of multiple components
\end_layout

\begin_layout Standard
Some game graphs are not completely connected, in the sense that there may
 be pairs of vertices where there exists no path from one vertex to the
 other.
 These games can be solved more efficiently by identifying strongly connected
 components, solving each component separately, and then combining the results.
 There are two different ways to solve this.
\end_layout

\begin_layout Standard
The first approach is to solve components in reverse topological order.
 Before solving the subgame induced by a component, we add edges to dummy
 vertices (one won by Even and one won by Odd) for any existing edges that
 have a target outside the current component, depending on which winning
 set contains their target.
 Because of the order in which components are solved, these winning sets
 are well-defined for vertices outside but reachable from the current component.
 The main advantage of this approach is that it requires running the decompositi
on algorithm only once, although creating temporary vertices and edges complicat
es the implementation somewhat.
\end_layout

\begin_layout Standard
A slightly more advanced approach was introduced in PGSolver and implemented
 in my solver as well.
 Here, we look only for a single leaf component (a component with no outgoing
 edges) and solve its induced subgame (which is necessarily a proper subgame).
 Then, we extend the winning sets for both players to their attractor sets
 in the main game.
 The main game is then replaced by a subgame induced by the complement of
 the original graph with these attractor sets removed, and the process is
 repeated until a single component remains.
 Because we remove attractor sets of winning sets only, the constructed
 subgames remain proper subgames.
\end_layout

\begin_layout Standard
In the second approach, we must decompose the graph and constructing a (typicall
y large) subgame once for every subcomponent that is found.
 This seems less efficient than the first approach, but it has advantages
 as well, mainly stemming from the fact that the attractor sets of winning
 sets may extend far into the main game, removing solved parts of the graph
 which are much larger than the component which was last solved, and creating
 more separate components in the unsolved part of the graph than were present
 initially.
 In cases where the initial game graph consists of a single component, the
 decomposition algorithm is run only once, and no subgame needs to be constructe
d, so the overhead is limited (and comparable to that of the first approach)
 in these cases.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
NOTE: this 
\begin_inset Quotes eld
\end_inset

second approach
\begin_inset Quotes erd
\end_inset

 is what PGsolver implements, but isn't how I implemented it at all! Maybe
 this whole section is out of place?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Verification 
\begin_inset CommandInset label
LatexCommand label
name "sec:Verification"

\end_inset


\end_layout

\begin_layout Standard
To ascertain the correctness of the implemented algorithms, it is useful
 to have a means of verifying the solutions produced by these algorithms.
 Of course, algorithms are typically published with a correctness proof
 before they are implemented, but mistakes could be introduced during implementa
tion, which makes it worthwhile to implement a verification routine to validate
 the results independent of any solution algorithms.
\end_layout

\begin_layout Standard
Note that solutions produced by different algorithms cannot generally be
 compared: although winning sets are unique (and thus can be compared) strategie
s are generally not, so when two algorithms produce two different pairs
 of strategies, that does not imply either is wrong.
\end_layout

\begin_layout Standard
The verification algorithm described below depends on the efficient solution
 of single-player games, for which a polynomial time algorithm will be presented
 first.
\end_layout

\begin_layout Subsection
Solving single-player games
\end_layout

\begin_layout Standard
Without loss of generality, suppose we want to solve a single-player game
 for player Even.
 Player Even can win from at least some vertices if the graph contains a
 cycle with even dominant priority (for brevity, let's call this an 
\emph on
even cycle
\emph default
).
\end_layout

\begin_layout Standard
To solve the game, we iteratively identify an even cycle 
\begin_inset Formula $c_{1}c_{2}\ldots c_{n}\in V^{+}$
\end_inset

 in the game (
\begin_inset Formula $c_{i}c_{j}\in E$
\end_inset

 if 
\begin_inset Formula $i+1=j\mod{n}$
\end_inset

 and 
\begin_inset Formula $\min\phi(c_{j})=0\mod{2}$
\end_inset

) 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
and then solve the smaller subgame 
\begin_inset Formula $\Gamma|V\setminus Attr^{x}(\Gamma,\{c_{1},c_{2}\ldots,c_{n}\})$
\end_inset

 in the same manner.
 The strategy for player Even is formed by combining 
\begin_inset Formula $\sigma_{0}(c_{i})=c_{j}$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
if 
\begin_inset Formula $i+1=j\mod{n}$
\end_inset

 with the strategy obtained by computing the attractor set and solving the
 subgame.
 When eventually no even cycle remains, then all possible plays in the remaining
 subgame necessarily have odd dominant priority and player Odd wins from
 the remaining vertices with a trivial strategy, since by definition of
 a single-player game Odd has no choice in the game.
\end_layout

\begin_layout Standard
The question now becomes how to find these even cycles.
 If we call a cycle with dominant priority 
\emph on
i
\emph default
 an 
\emph on
i
\emph default
-cycle, then a game contains an 
\emph on
i
\emph default
-cycle if and only if it contains some vertices with priority 
\emph on
i
\emph default
 lying on a cycle after removal of all edges incident with vertices of priority
 less than 
\emph on
i
\emph default
, because an 
\emph on
i
\emph default
-cycle can only include edges between vertices of priority 
\emph on
i
\emph default
 or greater.
 To find an 
\emph on
i
\emph default
-cycle in a graph with edges between vertices of priorities 
\emph on
i
\emph default
 or greater, we can use the connection between strongly connected components
 of the graph and cycles in the graph: every cycle must lie in a single
 strongly connected component and if the edge set of a strongly-connected
 component is non-empty, then all vertices in the strongly-connected component
 must lie on a cycle (by the definition of strongly connected components).
\end_layout

\begin_layout Standard
To find an even cycle, then, it suffices to search for 
\begin_inset Formula $i$
\end_inset

-cycles for all even values of 
\begin_inset Formula $i$
\end_inset

 and for each value construct a graph with edges incident only to vertices
 of priority 
\begin_inset Formula $i$
\end_inset

 or greater, which is then decomposed into strongly connected components.
 If a vertex with priority 
\begin_inset Formula $i$
\end_inset

 exists in a component which contains at least one edge, then a cycle can
 be found with a backtracking search within the component, which will visit
 every edge in the component at most once.
\end_layout

\begin_layout Standard
Because identifying strongly connected components takes 
\begin_inset Formula $O(E)$
\end_inset

 time (for example, using Tarjan's algorithm, described in 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1971depth"

\end_inset

) and subgame construction typically takes 
\begin_inset Formula $O(E)$
\end_inset

 time as well, it would not be very efficient to remove attractor sets one
 cycle at a time.
 Instead, after decomposing the graph for priority 
\begin_inset Formula $i$
\end_inset

, we can search for one cycle per component and compute the attractor set
 of all these cycles combined to remove all 
\begin_inset Formula $i$
\end_inset

-cycles from the game at once.
 This way, the algorithm requires at most 
\series bold

\begin_inset Formula $O(d)$
\end_inset


\series default
 iterations and in the worst case 
\begin_inset Formula $O(d\left|E\right|)$
\end_inset

 total time.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Maybe TODO: compare with PGSolver, if that's different.
 (I think it looks for a single cycle at a time?)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Verification algorithm
\end_layout

\begin_layout Standard
We are only interested in the strategy for vertices that are in the winning
 set of the player that controls them.
 Assume we are verifying the set 
\begin_inset Formula $W_{x}$
\end_inset

 with optimal strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 for player 
\begin_inset Formula $x$
\end_inset

.
 Define a graph with vertices limited to 
\begin_inset Formula $W_{x}$
\end_inset

 and the set of edges 
\begin_inset Formula $E|\sigma_{x}$
\end_inset

 as follows:
\begin_inset Formula 
\[
E|\sigma_{x}=\left\{ vw\in E:v\in\left(W_{x}\cap V_{x}\right)\wedge\sigma_{x}(v)=w\right\} \cup\left\{ vw\in E:v\in\left(W_{x}\cap V_{1-x}\right)\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Less formally, the edge set includes the edges that are consistent with
 
\begin_inset Formula $x$
\end_inset

's strategy, as well as all edges originating at vertices controlled by
 his opponent.
 We must first check the trivial property that 
\begin_inset Formula $E|\sigma_{x}\subseteq W_{x}\times W_{x}$
\end_inset

 (otherwise either player 
\begin_inset Formula $x$
\end_inset

 or his opponent would move the token outside 
\begin_inset Formula $W_{x}$
\end_inset

 in which case it cannot be the right winning set).
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Assuming this property holds, then 
\begin_inset Formula $\Gamma|\sigma_{x}=(W_{x}\cap V_{x},W_{x}\cap V_{1-x},E|\sigma_{x},\phi|W_{x})$
\end_inset

 is a proper subgame of 
\begin_inset Formula $\Gamma$
\end_inset

, and precisely those plays in the original game consistent with strategy
 
\begin_inset Formula $\sigma_{x}$
\end_inset

 are possible in the game 
\begin_inset Formula $\Gamma|\sigma_{\text{x}}$
\end_inset

 as well, except that all choice for player 
\begin_inset Formula $x$
\end_inset

 has been removed, which makes 
\begin_inset Formula $\Gamma|\sigma_{x}$
\end_inset

 a single-player game controlled by player 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
To verify that the original strategy was sound, we can solve this single
 player game using the method described earlier, and verify that the winning
 set for player 
\begin_inset Formula $W_{1-x}$
\end_inset

 in the subgame is empty.
 This proves that the strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 is valid in 
\begin_inset Formula $W_{x}$
\end_inset

 though it does not yet prove that 
\begin_inset Formula $W_{x}$
\end_inset

 is maximal.
 To show that, we must verify that 
\begin_inset Formula $W_{x-1}=V\setminus W_{x}$
\end_inset

 is a winning set for the opponent 
\begin_inset Formula $x-1$
\end_inset

.
\end_layout

\begin_layout Standard
Complete verification of winning sets and strategies therefore requires
 solving two single-player games, each of which takes 
\begin_inset Formula $O(d\left|E\right|)$
\end_inset

 time (as described above).
 Since 
\begin_inset Formula $d\leq\left|V\right|$
\end_inset

 the verification algorithm runs in polynomial time and is fast in practice
 when the game graph is sparse and the number of distinct priorities is
 low, as is often the case.
\end_layout

\begin_layout Chapter
Common algorithms and data structures
\end_layout

\begin_layout Standard
The results that will be presented later on are based on emperical evaluation
 of various parity game solving algorithms on both synthetic and real-world
 cases.
 The results obtained therefore depend not only on the choice of algorithms,
 but also on various implementation details, such as the data structures
 and programming techniques used to implement those algorithms.
\end_layout

\begin_layout Standard
It has been shown that in practice different experimental tools have different
 performance characteristics despite being based on the same theoretical
 algorithms.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite some proof?
\end_layout

\end_inset

 This phenomon occurs because of undocumented differences in the implementation
 of these different tools, sometimes arising from intentional changes to
 those algorithms (preprocessing operations or optimizations for particular
 instances, for example) and more often because the algorithms described
 in literature are usually not described to a sufficient level of detail
 that they can be implemented without being forced to make concrete implementati
on choices.
 For theoretical analysis this is not necessary (and usually, in the interest
 of conciseness, not desired), but for practical results it matters significantl
y how the missing parts are implemented concretely.
\end_layout

\begin_layout Standard
To ensure that the results presented here are reproducible, and to make
 the differences in results obtained with different tools easier to understand
 and explain, I will document the choices that I made in the implementation
 of my solving tool to a fair amount of detail.
 In particular, the core data structures and the algorithms will be documented
 precisely.
\end_layout

\begin_layout Standard
Finally, the descriptions provided here and in later chapters are a useful
 key to understanding the source code of my solver tool, since it provides
 a high-level overview of its design.
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
Recall that a parity game consists of a directed graph, a partition of vertices
 into sets owned by the two players, and the assignment of a priority to
 every vertex.
 This data must be represented in some way in a solver.
\end_layout

\begin_layout Standard
When executing a solving algorithm, the parity game data is read, but usually
 not modified.
 Therefore, an implementation that allows efficient read-only access is
 more important than a data structure with high flexibility in regards to
 updates.
 However, many of the simplification and preprocessing algorithms must either
 modify the parity game under consideration or be able to quickly construct
 a modified copy of it.
 This use case must be accommodated as well.
\end_layout

\begin_layout Standard
Finally, since practical instances of parity games tend to be fairly large,
 it is desirable that the parity game representation is as compact as possible,
 to the extend this is possible without compromising access speed.
 This not only reduces the amount of memory needed to solve particularly
 large instances, but also ensures that the solving algorithms benefit maximally
 from cache effects.
\end_layout

\begin_layout Subsection
The game graph structure
\end_layout

\begin_layout Standard
A parity game is played on a directed graph, which consists of a set of
 vertices (
\begin_inset Formula $V$
\end_inset

) and a set of edges (
\begin_inset Formula $E\subseteq V\times V$
\end_inset

).
 Vertices will be identified with integers from 0 through 
\begin_inset Formula $\left|V\right|$
\end_inset

 (exclusive).
 At a minimum, we will store 
\begin_inset Formula $\left|V\right|$
\end_inset

 and 
\begin_inset Formula $\left|E\right|$
\end_inset

, the number of vertices and edges in the graph respectively.
\end_layout

\begin_layout Standard
To represent the graph in its entirety, we then only need to store the edges.
 We could store those as an array of pairs of integers (the source and destinati
on vertices of a directed edge).
 This is reasonably compact (requiring 
\begin_inset Formula $2\left|E\right|$
\end_inset

 integers to be stored).
 However, this representation is impractical if we want to quickly access
 a set of successors (
\begin_inset Formula $vE$
\end_inset

) or predecessors (
\begin_inset Formula $Ev$
\end_inset

) of a vertex, which are common operations in many algorithms.
\end_layout

\begin_layout Standard
Therefore, a different representation is used.
 Suppose we start with the array of edges described above and sort them
 by source vertex first, and destination vertex second.
 Then, all the edges from a vertex 
\begin_inset Formula $v$
\end_inset

 to its successors will occur as a consecutive sequence in the edge array,
 and we can store for each vertex the interval 
\begin_inset Formula $[\mathtt{succBegin[v],\mathtt{succEnd[v]})}$
\end_inset

.
\end_layout

\begin_layout Standard
This representation would require 
\begin_inset Formula $2\left|E\right|+2\left|V\right|$
\end_inset

 integers to be stored, and allows the following operations to be performed
 efficiently:
\end_layout

\begin_layout Enumerate
Enumerate the successors of a vertex (
\begin_inset Formula $vE$
\end_inset

), in order.
\end_layout

\begin_layout Enumerate
Calculate the number of successors of a vertex (
\begin_inset Formula $\left|vE\right|$
\end_inset

), by calculating 
\begin_inset Formula $\mathtt{succEnd[v]}-\mathtt{succBegin[v]}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Determine if 
\begin_inset Formula $vw\in E$
\end_inset

 (using binary search, this could take 
\begin_inset Formula $O\left(log\left(\left|vE\right|+1\right)\right)$
\end_inset

 time).
\end_layout

\begin_layout Standard
Of course, the first operation is the one that is most common.
 Next, we can apply two simplifications.
 First, since the predecessor vertex of all edges with indices between 
\begin_inset Formula $\mathtt{succBegin[v]}$
\end_inset

 and 
\begin_inset Formula $\mathtt{succEnd[v]}$
\end_inset

 are known to be equal to 
\begin_inset Formula $v$
\end_inset

, we don't need to store predecessor vertices at all.
 Additionally, it is easy to see that 
\begin_inset Formula $\mathtt{succEnd[v]=succBegin[v+1]}$
\end_inset

 for all 
\begin_inset Formula $v$
\end_inset

 except the last vertex, so we can store all indices in a single array of
 length 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left|V\right|+1$
\end_inset

, instead of using two arrays.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
This it the final representation that is used, and requires 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\left|E\right|+\left|V\right|+1$
\end_inset

 integers to store the edge data.
 However, this edge representation only allows us to quickly find successors
 of edges.
 For some algorithms, it is useful to be able to find predecessors quickly
 as well.
 For this reason, the graph data structure by default stores the edge set
 in reverse order too, doubling the amount of memory required.
\end_layout

\begin_layout Standard
It should be noted that this dense edge representation does not allow efficient
 insertion or removal of individual edges in the game graph, because each
 such operation requires a large part of the edge array to be moved.
 Fortunately, the preprocessing algorithms that are applied in the solver
 are applied to the graph as a whole, and the cost of individual changes
 can therefore be amortized over the entire graph-wide operation.
\end_layout

\begin_layout Subsection
The parity game structure
\end_layout

\begin_layout Standard
In addition to the game graph, a parity game must store two attributes for
 each vertex:
\end_layout

\begin_layout Enumerate
The controlling player (Even or Odd), and
\end_layout

\begin_layout Enumerate
the associated priority value, 
\begin_inset Formula $\phi(v)$
\end_inset

.
\end_layout

\begin_layout Standard
These two attributes are packed into a two-byte structure, and stored in
 an array of length 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 Note that this limits the maximum priority that can be represented to 255,
 which seems low, but is much larger than occurs in practice (although synthetic
 cases with larger priorities could easily be generated).
\end_layout

\begin_layout Standard
Additionaly, we store in the parity game structure two properties of the
 game:
\end_layout

\begin_layout Enumerate
The priority limit (
\begin_inset Formula $d$
\end_inset

) which is calculated as the maximum priority value used + 1.
 (This is equal to the index of the game assuming all priority values are
 used.)
\end_layout

\begin_layout Enumerate
An array of integers of length 
\begin_inset Formula $d$
\end_inset

 that stores how many vertices occur with each individual priority value.
\end_layout

\begin_layout Standard
This information can be recomputed from the vertex attributes in time 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

, but it is useful in a number of situations, for example, to quickly calculate
 the worst-case execution time of the SPM algorithm or to quickly determine
 whether priority compression is possible.
\end_layout

\begin_layout Subsection
The solution structure
\end_layout

\begin_layout Standard
Every solving algorithm needs to return a solution to the given parity game,
 which consists of a partitioning of the vertex set into winning sets for
 both players, and a strategy for each player which is defined at least
 for vertices in the winning set of that player.
\end_layout

\begin_layout Standard
This characterization shows that there is a strong relation between winning
 sets and strategies of players: when a player controls a vertex which lies
 outside his winning set, he has no meaningful strategy there (as every
 possible move is by definition losing).
 Therefore, we will simply define solutions as arrays which assign to every
 vertex the successor vertex for the controlling player, or the special
 value 
\begin_inset Formula $-1$
\end_inset

 if it is in his opponent's winning set instead:
\begin_inset Formula 
\[
\mathtt{solution[v]}=\begin{cases}
\sigma_{0}(v) & \mbox{ if }v\in V_{0}\cap W_{0}\\
\sigma_{1}(v) & \mbox{ if }v\in V_{1}\cap W_{1}\\
-1 & \mbox{ if }v\in(V_{0}\cap W_{1})\cup(V_{1}\cap W_{0})
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
From a solution array, winning sets and strategies can be trivially obtained
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W_{x}=\{v\in V_{x}:\;\mathtt{solution[v]}\neq-1\}
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{x}(v)=\begin{cases}
\mathtt{solution[v]} & \mbox{ if }v\in W_{x}\\
\min(vE) & \mbox{ if \ensuremath{v\notin W_{x}}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Note that the choice of the minimum successor for vertices which are lost
 to the current player is arbitrary; in those cases any successor could
 be chosen.
\end_layout

\begin_layout Subsection
Subgame construction
\end_layout

\begin_layout Standard
Many algorithms require subgames to be constructed.
 Since the data structure described above requires a dense representation
 of vertices, this requires that all data is reconstructed.
 The subgame 
\begin_inset Formula $\Gamma|U$
\end_inset

 is constructed from an array containing the vertex identifiers in 
\begin_inset Formula $U$
\end_inset

 while the ordering of the elements determines the new identifiers of the
 vertices in the subgraph.
\end_layout

\begin_layout Standard
The main cost in constructing a subgame comes from the construction the
 successor and/or predecessor arrays of the subgraph, which is done by iterating
 over all successors (or predecessors, as the case may be) of vertices in
 
\begin_inset Formula $U$
\end_inset

, filtering out vertices which are outside of 
\begin_inset Formula $U$
\end_inset

.
 If the ordering of vertices in 
\begin_inset Formula $U$
\end_inset

 differs from 
\bar under

\begin_inset Formula $V$
\end_inset


\bar default
 then vertex lists need to be resorted too, but usually this is not necessary;
 for most purposes 
\begin_inset Formula $U$
\end_inset

 can be constructed as a subsequence of 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Standard
To filter vertices efficiently, either a hashtable or a boolean array is
 used to represent 
\begin_inset Formula $U$
\end_inset

, depending on the size of 
\begin_inset Formula $U$
\end_inset

 relative to 
\begin_inset Formula $V$
\end_inset

: for small subsets the mapping is sparse and a hashtable is more efficient.
 The exact time complexity depends on the outdegree for vertices in 
\begin_inset Formula $U$
\end_inset

.
 If we assume the graph to be sparse (i.e.
 the outdegree is 
\begin_inset Formula $O(1)$
\end_inset

) then subgame construction takes 
\begin_inset Formula $O(\left|U\right|)$
\end_inset

 space.
 Even if the graph is not sparse, subgame construction takes time linear
 in the number of edges of the resulting subgraph, as long as the outdegree
 of the subgame is comparable to that of the vertices in the original graph.
\end_layout

\begin_layout Standard
This is the assumption that will be used in this report to analyze the complexit
y of algorithms that rely on subgame construction, which includes Zielonka's
 algorithm, as well as many preprocessing operations.
 Finally, it should be noted that when constructing subgames, the array
 
\begin_inset Formula $U$
\end_inset

 is kept around to be able to map the vertex indentifiers in the subgame
 back to the original game, which is necesssary to propagate solution and
 strategy information back to the main game, and to gather global statistics
 and debugging information.
\end_layout

\begin_layout Subsection
Attractor set computation 
\begin_inset CommandInset label
LatexCommand label
name "sub:Attractor-set-computation"

\end_inset


\end_layout

\begin_layout Standard
In my implementation, attractor sets are computed straightforwardly using
 a queue and a set, where both data structures are assumed to have 
\begin_inset Formula $O(1)$
\end_inset

 performance for the relevant operations (for example, a deque and a hash
 table satisfy these requirements).
 The queue is initialized to the attractor set.
 Every iteration, a vertex is extracted from the queue and its predecessors
 are examined.
 Any predecessor which is controlled by the player for whom we are computing
 the attractor set, or which is controlled by his opponent but has no successors
 outside the attractor set, is added to the queue and the attractor set,
 and (optionally) the strategy for the new vertex is updated.
 Because the attractor set computation is analogous to a breadth-first search,
 the strategy reflects the shortest path from vertices in the extended attractor
 set to vertices in the initial set.
 The algorithm is presented in detail as Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Attractor-set-computation"

\end_inset

.
\end_layout

\begin_layout Standard
Computing attractor sets requires both predecessor and successor information
 be stored in the graph, and the resulting algorithm is reasonably efficient
 for sufficiently sparse graphs.
 However, the worst-case complexity is as high as 
\begin_inset Formula $O(ev)$
\end_inset

 where 
\begin_inset Formula $v$
\end_inset

 is the size of the resulting set and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $e$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 is the number of edges incident to vertices in the set.
 This complexity arises from the fact that when a predecessor is controlled
 by the opponent of the player for whom the attractor set is computed, then
 all successors of this vertex must be evaluated to see if an edge to a
 vertex outside the attractor set exists; in a worst-case scenario, all
 vertices currently in the attractor set could be reachable before a successor
 outside it is found.
\end_layout

\begin_layout Standard
The complexity can be reduced to 
\begin_inset Formula $O(e)$
\end_inset

 by keeping track of the last successor evaluated for every vertex outside
 the vertex set, so that we can restart the search there (knowing that the
 preceding successors are already known to lie inside the attractor set),
 which limits the number of times an edge is examined to 
\begin_inset Formula $3e$
\end_inset

.
 In typical sparse graphs, the overhead of maintaining an additional data
 structure may outweigh the benefit of a lower worst-case complexity bound,
 which is why this optimization is currently not implemented.
 However, for sake of computing the complexity of other algorithms, the
 theoretical bound of 
\begin_inset Formula $O(e)$
\end_inset

 is used.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

Set<Vertex> make_attractor_set(
\end_layout

\begin_layout Plain Layout

	ParityGame game, Player player,
\end_layout

\begin_layout Plain Layout

	Set<Vertex> initial, Strategy s )
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Queue<Vertex> todo
\end_layout

\begin_layout Plain Layout

	Set<Vertex> attr
\end_layout

\begin_layout Plain Layout

	for v in initial {
\end_layout

\begin_layout Plain Layout

		attr.insert(v)
\end_layout

\begin_layout Plain Layout

		todo.push_back(v)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	while not todo.empty() {
\end_layout

\begin_layout Plain Layout

		Vertex v = todo.pop_front()
\end_layout

\begin_layout Plain Layout

		for u in game.graph.predecessors(v) {
\end_layout

\begin_layout Plain Layout

			if u in attr {
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			if game.player(u) == player {
\end_layout

\begin_layout Plain Layout

				strategy[u] = v
\end_layout

\begin_layout Plain Layout

			} else if game.graph.successors(u) is subset of attr {
\end_layout

\begin_layout Plain Layout

				strategy[u] = NO_VERTEX
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			attr.insert(u)
\end_layout

\begin_layout Plain Layout

			todo.push_back(u)
\end_layout

\begin_layout Plain Layout

 		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return attr
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Attractor set computation 
\begin_inset CommandInset label
LatexCommand label
name "alg:Attractor-set-computation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Graph decomposition
\end_layout

\begin_layout Standard
To compute strongly connected components, Tarjan's algorithm from 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1971depth"

\end_inset

 is used, which enumerates all strongly connected components in reverse
 topological order, which means that when a component is found all edges
 lead to vertices within the component, or into one of the components found
 before.
 The algorithm requires 
\begin_inset Formula $O(\left|E\right|)$
\end_inset

 time and 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 space (even if the algorithm is aborted before all components have been
 found).
\end_layout

\begin_layout Standard
The algorithm as described by Tarjan is based on a depth-first search of
 the graph, labeling vertices as they are visited.
 Depth-first search is typically implemented as a recursive procedure, but
 this is impractical for very large graphs, where high recursion depth may
 exhaust the available stack space.
 Therefore, the implementation uses an iterative approach, with an explicit
 stack data structure which is stored in the heap.
 In addition to removing the limitations on recursion depth, this reduces
 memory use substantially, because the on-heap state representation (consisting
 of a vertex and edge index) is much more compact than a full stack frame
 would be.
\end_layout

\begin_layout Standard
Components are passed to a callback function as an array of indices of vertices
 in the original graph.
 Such an array can be used to construct a subgame for the component, as
 described above, though it should be noted that the subgame induced by
 a strongly connected component of the game graph is not typically a proper
 subgame itself, unless there are no edges going out of the current component.
\end_layout

\begin_layout Standard
The decomposition algorithm is used to implement solving of individual component
s, removal of owner-controlled cycles and verification of games.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: browse code for stuff I didn't cover yet
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Small Progress Measures
\end_layout

\begin_layout Standard
Small Progress Measures is a relatively simple, iterative algorithm for
 partially solving parity games proposed by Marcin Jurdziński.
 A game is solved only partially in the sense that the winning set and optimal
 strategy for one player is determined.
 To solve a game completely, the algorithm must therefore be run twice,
 but, fortunately, in the second pass the winning set of the first player
 can be omitted from the game graph, which typically reduces the time required
 to solve the remaining part of the game significantly.
\end_layout

\begin_layout Standard
Small Progress Measures (or SPM for short) is attractive because it is a
 relatively simple which allows it to be implemented easily and provides
 ample opportunity to speed up the core algorithm (for example, through
 parallelization).
 Additionally, the algorithm is among those with the lowest worst-case complexit
y bounds known for solving parity games, requiring at most 
\begin_inset Formula $O\left(\left|E\right|\left(\left|V\right|/\left\lfloor \frac{d}{2}\right\rfloor \right)^{\left\lfloor \frac{d}{2}\right\rfloor }\right)$
\end_inset

 time and 
\begin_inset Formula $O(\left|V\right|d)$
\end_inset

 space (in addition to the space required to store the parity game itself)
 although unfortunately those are also lower bounds on the worst case.
\end_layout

\begin_layout Standard
Oliver Friedmann implemented a variation of the algorithm in PGSolver that
 effectively combines the two passes in one, solving both the game and its
 dual at the same time.
 This does not improve on the worst-case time bounds (and, in fact, may
 require around twice as much time and memory compared to the standard algorithm
), but can avoid some of the pitfalls that cause excessive runtimes with
 the standard algorithm, which makes it a useful alternative in practice.
 Since this variation has not been published before, it will be described
 in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Two-sided-SPM"

\end_inset

.
\end_layout

\begin_layout Standard
A lock-free concurrent version was implemented by Van de Pol and Weber which
 works on shared-memory systems that do not reorder memory operations.
 A concurrent implementation for the Playstation 3 (taking advantage of
 the capabilities of the multi-core Cell processor) was written by Jorne
 Kandziora 
\begin_inset CommandInset citation
LatexCommand cite
key "kandziora2009ps3"

\end_inset

 and later improved upon by Freark van der Berg.
 
\begin_inset CommandInset citation
LatexCommand cite
key "vanderberg2010ps3"

\end_inset


\end_layout

\begin_layout Enumerate
An improvement of the basic algorithm that eliminates failed lifting attempts,
 described in subsection 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
An optimization that reduces the vector space whenever a vertex is lifted
 to 
\begin_inset Formula $\top$
\end_inset

, described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimization-after-lifting"

\end_inset


\end_layout

\begin_layout Enumerate
The development of a novel lifting heuristic that reduces the number of
 lifting attempts required in many cases, described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Maximum-Measure-Propagation"

\end_inset

.
\end_layout

\begin_layout Standard
None of these improvements are present in the existing implementations listed
 above.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
parallel and distributed implementations?
\end_layout

\begin_layout Plain Layout
3.
 the combination of different optimizations into a single tool (which no
 other tool did)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Description
\end_layout

\begin_layout Standard
Here I will outline SPM as described by Jurdziński 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset

.
 Let's assume we want to solve the game for player Even.
 Then, we associate with each vertex a value, which is either the special
 value 
\begin_inset Formula $\top$
\end_inset

 (top) or a vector of 
\begin_inset Formula $d$
\end_inset

 nonnegative integers (whose elements have indexes from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $d-1$
\end_inset

).
 The vector is a member of the vector space 
\begin_inset Formula $M=M_{0}\times M_{1}\times\cdots\times M_{d-1}$
\end_inset

 where 
\begin_inset Formula $M_{i}$
\end_inset

 is defined as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
M_{i}=\begin{cases}
\{0\} & \mbox{if \ensuremath{i\equiv0\mod{2}}}\\
\{0..\left|\{v\in V:\phi(v)=i\}\right|\} & \mbox{if \ensuremath{i\equiv1\mod{2}}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Elements from the set 
\begin_inset Formula $M^{\top}=M\cup\{\top\}$
\end_inset

 are called Small Progress Measures (the term 
\begin_inset Quotes eld
\end_inset

small
\begin_inset Quotes erd
\end_inset

 refers to the fact they are drawn from a reduced vector space: every even
 element is fixed to zero) and will be denoted with lower-case Greek letters.
 On these values a comparison operator 
\begin_inset Formula $<_{i}$
\end_inset

 is defined that compares two vectors lexicographically up to (and including)
 the element with index 
\begin_inset Formula $i$
\end_inset

.
 
\begin_inset Formula $\top$
\end_inset

 is always considered greater than any vector.
 Formally:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{cl}
\alpha<_{i}\beta\;\Leftrightarrow\alpha\neq\top\wedge\beta=\top & \mbox{if }\ensuremath{\alpha=\top\mbox{ or }\beta=\top}\\
\exists j\leq i:\;\alpha_{j}<\beta_{j}\wedge\left(\forall k<j:\;\alpha_{j}=\beta_{j}\right) & \mbox{otherwise}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
The operator 
\begin_inset Formula $<_{i}$
\end_inset

 establishes a strict weak ordering on the elements of 
\begin_inset Formula $M^{\top}$
\end_inset

.
 The other operators can then be defined accordingly:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha>_{i}\beta\;\Leftrightarrow\;\beta<_{i}\alpha
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha\leq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha>_{i}\beta\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha\geq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha<_{i}\beta\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha=_{i}\beta\;\Leftrightarrow\left(\alpha\leq_{i}\beta\right)\wedge\left(\alpha\geq_{i}\beta\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha\neq_{i}\beta\;\Leftrightarrow\left(\alpha<_{i}\beta\right)\vee\left(\alpha>_{i}\beta\right)
\]

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\rho:V\rightarrow M$
\end_inset

 be a function that maps vertices to progress measures.
 First, define a function 
\begin_inset Formula $Prog(\rho,v,w):(V\rightarrow M)\times E\rightarrow M^{\top}$
\end_inset

 that determines the minimum progress measure for 
\begin_inset Formula $v$
\end_inset

 when 
\begin_inset Formula $vw$
\end_inset

 is included in the strategy for player Even as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Prog(\rho,v,w)=\begin{cases}
\top & \mbox{if \ensuremath{\rho(w)=\top}, otherwise:}\\
\min_{m\in M^{\top}}m\geq_{\phi(v)}\rho(w) & \mbox{if \ensuremath{\phi(v)\equiv0\mod{2}},}\\
\min_{m\in M^{\top}}m>_{\phi(v)}\rho(w) & \mbox{if }\ensuremath{\phi(v)\equiv1\mod{2}}.
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Next define a function 
\begin_inset Formula $Lift(\rho,v)$
\end_inset

 which attempts to increase the progress vector assigned to 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $\rho$
\end_inset

, as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Lift(\rho,v)(u)=\begin{cases}
\rho(u) & \mbox{if \ensuremath{u\neq v}}\\
\max\{\rho(v),\min_{vw\in E}Prog(\rho,v,w)\} & \mbox{if \ensuremath{u=v\ \wedge\ v\in V_{0}}}\\
\max\{\rho(v),\max_{vw\in E}Prog(\rho,v,w)\} & \mbox{if }\ensuremath{u=v\ \wedge\ v\in V_{1}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
And similarly, globally:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Lift(\rho)=\begin{cases}
Lift(\rho,v) & \mbox{if \ensuremath{\exists v\in V:\; Lift(\rho,v)\neq\rho},}\\
\rho & \mbox{otherwise}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Now if we iterate 
\begin_inset Formula $Lift(\rho)$
\end_inset

 starting from a zero progress measure (
\begin_inset Formula $\rho(v)=\vec{0}$
\end_inset

 for all 
\begin_inset Formula $v\in V$
\end_inset

) we will arrive at a minimum fixed point 
\begin_inset Formula $\rho=Lift(\rho)$
\end_inset

.
 This is our final progress measure function and Jurdziński proves that
 we can use its value as follows to deduce the winning sets and the strategy
 for player Even:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W_{0}=\{v\in V:\;\rho(v)<\top\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W_{1}=\{v\in V:\;\rho(v)=\top\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\sigma_{0}(v)=w\mbox{ if }v\in W_{0}\ \wedge\ \rho(v)=_{\phi(v)}\rho(w)
\]

\end_inset


\end_layout

\begin_layout Standard
(Note that if in the last definition the choice of 
\begin_inset Formula $w$
\end_inset

 is not unique, we can arbitrarily choose any of the possible successors
 to obtain an optimal strategy.)
\end_layout

\begin_layout Section
Lifting Strategies 
\begin_inset CommandInset label
LatexCommand label
name "sub:Lifting-Strategies"

\end_inset


\end_layout

\begin_layout Standard
Jurdziński's algorithm is straightforward, but it leaves open two important
 implementation details:
\end_layout

\begin_layout Enumerate
How can we determine which vertices are liftable (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)\neq\rho$
\end_inset

) and similarly, how do we know when the minimum fixed point has been reached?
\end_layout

\begin_layout Enumerate
When multiple vertices are liftable, which do we select to improve the progress
 measure?
\end_layout

\begin_layout Standard
Existing implementations generally follow Jurdziński's formulation, and
 just compute 
\begin_inset Formula $Lift(\rho,v)$
\end_inset

 for different vertices until they find one that changes the current progress
 measure.
 The advantage of this approach is that the core algorithm remains very
 simple, altough it still doesn't address where or when termination detection
 occurs.
\end_layout

\begin_layout Standard
Which brings us to the second point: the order in which vertices are selected
 for (potential) lifting is not specified by Jurdziński's formulation, because
 any lifting order will lead to the same, unique fixed point.
 However, the order in which vertices are lifted is important in practice,
 because some sequences may be considerably shorter than others, and thus
 result in a faster calculation.
 Since the optimal lifting sequence cannot be predicted in advance, a heuristic
 approach must be used instead.
\end_layout

\begin_layout Standard
I will call the heuristic used to determine which vertex to (try to) lift
 next a 
\emph on
lifting strategy
\emph default
.
 In practice, the performance of different implementations of the small
 progress measures algorithm will be greatly affected by which lifting strategy
 is used.
\end_layout

\begin_layout Standard
The core algorithm can be described as a function taking a small progress
 measure that is appropriately initialized and a lifting strategy; see Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:SPM v1 Core"

\end_inset

.
 In this arrangement, the core algorithm notifies the lifting strategy of
 succesful lifts, and the lifting strategy decides both the order in which
 vertices are lifted, and signals termination when the minimum fixed point
 has been reached.
\end_layout

\begin_layout Standard
This separation of concerns exists in most previous implementations of Small
 Progress Measures and is attractive because it keeps the core algorithm
 very simple, while still allowing a sophisticated approach to be used by
 the lifting strategy.
 Of course, this also means that the performance of the algorithm depends
 crucially on the strategy chosen.
 Jurdziński already hints at the importance of using a suitable lifting
 strategy (which he calls “evaluation policy”): 
\emph on
“our algorithm can be seen as a generic algorithm allowing many different
 evaluation policies; good heuristics can potentially improve performance
 of the algorithm”
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(Open question: can we determine an optimal sequence with hindsight?)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To summarize: a 
\emph on
lifting strategy
\emph default
 is a heuristical algorithm that, depending on information available about
 a partial solution (such as the structure of the graph, the values of the
 progress measure vectors, or the history of vertices being lifted) determines
 which vertex will be selected for the next lifting attempt.
 Lifting strategies are typically stateful, and although sophisticated lifting
 strategies may cause fewer work to be done in the SPM algorithm itself
 (by reducing the number of lifting attempts performed) it is important
 to keep in mind that this may come at the cost of spending more time and
 memory on internal bookkeeping.
\end_layout

\begin_layout Standard
In the following, I will describe the most commonly used lifting strategies,
 and how I implemented them in my framework.
 After that, I will describe some of the improvements I made to the core
 algorithm as outlined above.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SmallProgressMeasures(spm, lifting_strategy)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    v = lifting_strategy.next()
\end_layout

\begin_layout Plain Layout

	while (v != NO_VERTEX) {
\end_layout

\begin_layout Plain Layout

        new_spm = Lift(spm, v)
\end_layout

\begin_layout Plain Layout

        if (spm[v] > new_spm[v]) {
\end_layout

\begin_layout Plain Layout

            lifting_strategy.lifted(v)
\end_layout

\begin_layout Plain Layout

            spm[v] = new_spm[v]
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        v = lifting_strategy.next()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Core Small Progress Measures Algorithm 
\begin_inset CommandInset label
LatexCommand label
name "alg:SPM v1 Core"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Linear Lifting Strategy
\end_layout

\begin_layout Standard
Arguably the most basic strategy consists of trying to lift vertices in
 order of increasing indices, repeating the process as necessary, until
 all vertices in the graph have failed to be lifted in succession.
 Its advantages are that it is simple to implement and requires very little
 time and memory to select vertices.
 The main disadvantage is that it may spend a majority of the time attempting
 (and failing) to lift vertices in stable parts of the game graph.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Linear-Lifting-Strategy"

\end_inset

 gives pseudo-code for a simple implementation of this algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

num_failed = 0
\end_layout

\begin_layout Plain Layout

next_vertex = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lifted(Vertex v) {
\end_layout

\begin_layout Plain Layout

	num_failed = 0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vertex next() {
\end_layout

\begin_layout Plain Layout

	if num_failed >= V {
\end_layout

\begin_layout Plain Layout

		return NO_VERTEX
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		num_failed = num_failed + 1
\end_layout

\begin_layout Plain Layout

		next_vertex = (next_vertex + 1) mod V
\end_layout

\begin_layout Plain Layout

		return next_vertex
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Linear Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Linear-Lifting-Strategy"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

(In Van de Pol and Weber's implementation, this approach is called 
\emph on
swiping
\emph default
.)
\end_layout

\begin_layout Standard
A variation of the strategy is to iterate vertices in reverse order.
 This can be beneficial in cases where the graph has been constructed in
 a forward fashion, so that vertices tend to have higher indices than their
 predecessors, and therefore since changes in the graph propagate from vertices
 to their predecessors, iterating in reverse may cause more vertices to
 be lifted in one pass.
 For example, in a cycle graph with vertices numbered in cycle order, iterating
 in forward direction would lift only one vertex per pass, while lifting
 in backward direction would lift all.
\end_layout

\begin_layout Standard
There are a few things we can do to minimize the number of passes executed:
\end_layout

\begin_layout Enumerate
Calculate the ratio of “forward” and “backward” edges and choose the optimal
 direction accordingly.
\end_layout

\begin_layout Enumerate
Permute vertex indices based on the order they are visited by depth-first
 or breadth-first search through the graph, which should create a more favorable
 edge ratio.
\end_layout

\begin_layout Enumerate
Alternate the direction of iteration on every pass.
\end_layout

\begin_layout Standard
The advantage of the third approach is that it does not require precalculation/p
reprocessing of the game graph.
 Compared to the first approach, it will create at most twice as much work.
 Permuting vertex indices can produce even better results, but even the
 second approach isn't guaranteed to yield optimal results.
\end_layout

\begin_layout Subsection
Predecessor Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "sub:Predecessor-Lifting-Strategy"

\end_inset


\end_layout

\begin_layout Standard
A more sophisticated lifting strategy takes into account that a known-stable
 vertex can only become unstable after the progress measure vector of one
 of its successors has been updated.
 After all, the value for one vertex depends only on the values for its
 successors.
\end_layout

\begin_layout Standard
The predecessor lifting strategy uses a set datastructure to store potentially
 unstable (“dirty”) vertices, which is initialized to all vertices in the
 graph with progress mesaures less than 
\begin_inset Formula $\top$
\end_inset

.
 A vertex is arbitrarily removed from this set to be lifted, and if this
 succeeds, its predecessors are added back into the set.
 All vertices not in the set are necessarily stable, so when the set becomes
 empty, lifting is complete.
\end_layout

\begin_layout Standard
The advantage of this strategy is that it prevents a lot of unnecessary
 lifting that may occur with the linear lifting strategy.
 In fact, the ratio of unsuccesful to succesful lifts is strictly limited
 by the maximum indegree of a vertex in the graph.
 Again, pathological cases can be constructed where this strategy performs
 badly.
 For example, when the game graph is complete (i.e.
 
\begin_inset Formula $E=V\times V$
\end_inset

) all vertices remain in the set until the game is completely solved.
 Fortunately, graphs with such properties arise rarely in practice.
\end_layout

\begin_layout Standard
The main disadvantage of the lifting strategy is that it requires maintaining
 the set of unstable vertices, which requires 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 extra memory, and extra time proportional to the average indegree of lifted
 vertices.
 In my solver, this set is implemented with a linear array of Boolean variables
 to indicate whether a vertex is in the set, and another array which acts
 as a circular queue of vertices, in order to allow constant time insertion
 and removal of vertices.
\end_layout

\begin_layout Standard
In PGSolver (which is limited to single-threaded operation) the predecessor
 lifting strategy is the only lifting strategy implemented.
 Van de Pol and Weber call this the 
\emph on
work list approach
\emph default
 but reject it in their multi-core solver because they are worried about
 the overhead involved in maintaining the necessary data structures in a
 concurrent setting.
\end_layout

\begin_layout Standard
However, in my experience, available memory is rarely the limiting factor
 when solving parity games, and the data structures used can be implemented
 efficiently even in a lock-free manner, so I think there is little reason
 to omit this strategy from a solver, even one where high performance in
 a concurrent environment is the primary concern.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

queued = Vector<bool>(V)
\end_layout

\begin_layout Plain Layout

queue = Queue<Vertex>()
\end_layout

\begin_layout Plain Layout

for v in [0..V) {
\end_layout

\begin_layout Plain Layout

    if not top(w) {
\end_layout

\begin_layout Plain Layout

   	queued[v] = true
\end_layout

\begin_layout Plain Layout

	   queue.push(v)
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lifted(Vertex v) {
\end_layout

\begin_layout Plain Layout

	for w in predecessors(v) {
\end_layout

\begin_layout Plain Layout

		if not queued[w] and not top(w) {
\end_layout

\begin_layout Plain Layout

			queued[w] = true
\end_layout

\begin_layout Plain Layout

			queue.push(w)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vertex next() {
\end_layout

\begin_layout Plain Layout

	if queue.empty() {
\end_layout

\begin_layout Plain Layout

		return NO_VERTEX
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		v = queue.pop()
\end_layout

\begin_layout Plain Layout

		queued[v] = false
\end_layout

\begin_layout Plain Layout

		return v
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Predecessor Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Predecessor-Lifting-Strategy"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The pseudo-code for the predecessor lifting strategy is given in Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Predecessor-Lifting-Strategy"

\end_inset

 which shows that the main datastructure used is a queue.
 Crucial to the implementation is that every vertex is queued at most once,
 which prevents attempted lifting of vertices which are not dirty, and additiona
lly allows the queue to be implemented as a fixed-length array.
 An invariant maintained by this algorithm is that the set of vertices queued
 corresponds exactly with the set of dirty vertices; 
\begin_inset Formula $\texttt{next()}$
\end_inset

 simply returns a dirty vertex until the queue becomes empty, at which point
 all vertices are necessarily stable.
\end_layout

\begin_layout Standard
There is some freedom of implementation when deciding which vertex from
 the set of potentially unstable vertices to lift next.
 My implementation uses no external information, but can be configured to
 extract vertices from the queue in a first in, first out (FIFO) or last
 in, last out (LIFO) manner, in which case the queue works like a stack.
 Extracting vertices in LIFO order may have the benefit of providing better
 cache locality, even when it doesn't reduce the number of lifts.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
but I have no practical results that show this clearly
\end_layout

\end_inset

 Similar to the linear lifting strategy, vertices can be inserted into the
 initial queque in forward or reverse order.
\end_layout

\begin_layout Subsection
Focus List Approach
\end_layout

\begin_layout Standard
The 
\emph on
focus list approach
\emph default
 is a strategy designed by Van de Pol and Weber to mitigate some of the
 problems of the linear lifting strategy without introducing complicated
 data structures that may be hard to parallellize efficiently.
 Solving occurs by alternation of two phases of operation.
\end_layout

\begin_layout Standard
First, the algorithm iterates linearly over the vertices of the graph, putting
 vertices which are succesfully lifted on a fixed-size work list.
 When the work list is full, the second phase begins: vertices on the work
 list are assigned an initial credit value and are selected for lifting
 again.
 When lifting a vertex succeeds, its credit is incremented linearly (adding
 a constant); if it fails, it is decreased exponentially (dividing by a
 constant).
 A vertex whose credit drops below a certain threshold is removed from the
 work list.
 When the work list is empty or a predetermined amount of lifting attempts
 have been performed, the work list is cleared and the first phase is resumed.
\end_layout

\begin_layout Standard
The idea behind the work list is that it captures unstable parts of the
 graph.
 When processing the work list, either lifting attempts will have a high
 success rate, or the list will be cleared quickly, allowing new vertices
 to be selected.
 Limiting the number of attempts at this time ensures that if little progress
 is made in one part of the game (i.e.
 despite high lifting success rate, vertices do not stabilize) work will
 soon continue on some other part of the game.
\end_layout

\begin_layout Standard
Since Van de Pol and Weber are the only ones to implement this strategy,
 there is little emperical evidence available about its performance, though
 it seems to perform much better than linear lifting in some cases, and
 not much worse in most other cases, which suggests it meets its design
 goals.
 Compared to the predecessor lifting strategy, it has the advantage of being
 able to postpone difficult parts of the game, which may help in some hard
 cases.
\end_layout

\begin_layout Standard
The main downside of the strategy is that it depends on various constants
 (work list size, initial credit, credit increment, credit divisor) to work
 well.
 In Weber's implementation these are emperically derived while testing on
 random games, but it is unclear if and how these values should change for
 other types of games.
\end_layout

\begin_layout Standard
The implementation of the focus list lifting strategy is described in Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Focus-List-Lifting"

\end_inset

.
 For clarity, the algorithm is presented as if the strategy calls the 
\begin_inset Formula $\texttt{lift()}$
\end_inset

 method directly, instead of being called from the core algorithm; this
 is the inverse of how the strategy is implemented in reality.
 (The interaction between the core algorithm and the lifting strategy would
 best be implemented as a pair of coroutines, but unfortunately few programming
 languages support coroutines properly.)
\end_layout

\begin_layout Standard
Some of the parameters in this algorithm are fixed: the initial credit (here:
 2) assigned to vertices on the focus list; the linear increment when lifting
 succeeds (again, 2); and the exponential decay when it doesn't (here: 
\begin_inset Formula $\frac{1}{2}$
\end_inset

).
 With these parameters, which were taken from van de Pol and Weber's implementat
ion, a vertex is selected for lifting at least three times, but will stay
 on the focus list longer if lifting succeeds occassionally (more precesily,
 it needs to be succesfully lifted at least once every three attempts to
 stay on the list).
 The remaining two parameters are 
\begin_inset Formula $\texttt{max\_size}$
\end_inset

 and 
\begin_inset Formula $\texttt{max\_attempts}$
\end_inset

; the maximum size of the focus list and the maximum number of lifting attempts
 performed in phase 2 before switching back to phase 1.
 These parameters can vary, but are chosen as 
\begin_inset Formula $\frac{\left|V\right|}{10}$
\end_inset

 and 
\begin_inset Formula $\left|V\right|$
\end_inset

 (respectively) by default.
\end_layout

\begin_layout Standard
In terms of overhead, the focus list implements a circular buffer with an
 array of vertex/cost pairs.
 The size of this array is equal to 
\begin_inset Formula $\texttt{max\_size}$
\end_inset

 and this is the main factor in the memory used by the strategy.
 Otherwise, the focus list lifting strategy has little overhead.
 In particular, the runtime overhead is smaller than with the predecessor
 lifting strategy.
 When the focus list is small, the algorithm additionally benefits from
 being able to keep the active parts of the game in cache memory.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

phase = 1
\end_layout

\begin_layout Plain Layout

num_attempts = 0
\end_layout

\begin_layout Plain Layout

num_failed = 0
\end_layout

\begin_layout Plain Layout

next_vertex = 0
\end_layout

\begin_layout Plain Layout

focus_list = Queue<Pair<Vertex, Int>>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while true {
\end_layout

\begin_layout Plain Layout

	num_attempts = num_attempts + 1
\end_layout

\begin_layout Plain Layout

	if (phase == 1) {
\end_layout

\begin_layout Plain Layout

		if lift(next_vertex) {
\end_layout

\begin_layout Plain Layout

			num_failed = 0
\end_layout

\begin_layout Plain Layout

			focus_list.push(<next_vertex, 2>)
\end_layout

\begin_layout Plain Layout

		} else {
\end_layout

\begin_layout Plain Layout

			num_failed = num_failed + 1
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		next_vertex = (next_vertex + 1) mod V
\end_layout

\begin_layout Plain Layout

		if num_failed == V {
\end_layout

\begin_layout Plain Layout

			break
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if num_attempts == V || focus_list.size() == max_size {
\end_layout

\begin_layout Plain Layout

			/* N.B.
 focus_list is non-empty because
\end_layout

\begin_layout Plain Layout

			        num_failed < num_attempts */
\end_layout

\begin_layout Plain Layout

			phase = 2
\end_layout

\begin_layout Plain Layout

			num_attempts = 0
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	} else {  /* phase == 2 */
\end_layout

\begin_layout Plain Layout

		v, credit = focus_list.pop()
\end_layout

\begin_layout Plain Layout

		if lift(v) {
\end_layout

\begin_layout Plain Layout

			focus_list.push(<v, credit + 2>)
\end_layout

\begin_layout Plain Layout

		} else if (credit > 0) {
\end_layout

\begin_layout Plain Layout

			focus_list.push(<v, credit / 2>)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if focus_list.empty() || num_attempts == max_attempts {
\end_layout

\begin_layout Plain Layout

			focus_list.clear()
\end_layout

\begin_layout Plain Layout

			phase = 1
\end_layout

\begin_layout Plain Layout

			num_attempts = 0
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Focus List Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Focus-List-Lifting"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Maximum Measure Propagation 
\begin_inset CommandInset label
LatexCommand label
name "sub:Maximum-Measure-Propagation"

\end_inset


\end_layout

\begin_layout Standard
The maximum measure propagation strategy is a variant of the predecessor
 lifting strategy that at each iteration attempts to lift a vertex with
 a successor that has a maximal progress measure vector assigned to it.
 The rationale behind this strategy is the observation that since we increase
 the progress measure vector for at most one vertex every iteration, and
 since the final progress measure for this vertex does not depend on the
 order of lifting, then in order to perform as few (succesful) lifts as
 possible, it makes sense to try to lift vertices with the largest increments
 possible.
\end_layout

\begin_layout Standard
Artificial examples can be constructed in which this order of lifting provides
 obvious benefit.
 Specifically, whenever a vertex is known to be won by player Odd (when
 it is assigned 
\begin_inset Formula $\top$
\end_inset

) all vertices in its attractor set will be set to top before any other
 vertices are lifted, since 
\begin_inset Formula $\top$
\end_inset

 is the maximal value in the graph.
 With the normal predecessor lifting strategy, these vertices might have
 been lifted multiple times before inevitably finally reaching top value.
\end_layout

\begin_layout Standard
In practice, maximum measure propagation does not always outperform the
 simpler predecessor lifting strategy described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Predecessor-Lifting-Strategy"

\end_inset

, but in many cases it does cause fewer (succesful as well as total) lifting
 attempts.
 Its main disadvantage lies in the amount of overhead introduced by the
 implementation of the strategy itself.
 To track vertices with high progress measures, it is necessary to implement
 some sort of priority queue structure.
 Additionally, it must be possible to (quickly) move queued vertices when
 the value for their successor changes.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

queued = Vector<bool>(V)
\end_layout

\begin_layout Plain Layout

queue = BinaryHeap<Vertex>()
\end_layout

\begin_layout Plain Layout

for 0 <= v < V {
\end_layout

\begin_layout Plain Layout

	queued[v] = true
\end_layout

\begin_layout Plain Layout

	queue.push(v)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lifted(Vertex v) {
\end_layout

\begin_layout Plain Layout

	queued_predecessors = false
\end_layout

\begin_layout Plain Layout

	for u in predecessors(v) {
\end_layout

\begin_layout Plain Layout

		if !is_top(spm[u]) {
\end_layout

\begin_layout Plain Layout

			queued[u] = true
\end_layout

\begin_layout Plain Layout

			queued_predecessors = true
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	if queued_predecessors {
\end_layout

\begin_layout Plain Layout

		queue.push(v)
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		queue.pop(v)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vertex next() {
\end_layout

\begin_layout Plain Layout

	while not queue.empty() {
\end_layout

\begin_layout Plain Layout

		v = queue.top()
\end_layout

\begin_layout Plain Layout

		for u in predecessors(v) {
\end_layout

\begin_layout Plain Layout

			if queued[u] {
\end_layout

\begin_layout Plain Layout

				queued[u] = false
\end_layout

\begin_layout Plain Layout

				return u
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		queue.pop(v)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return NO_VERTEX
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Maximum Measure Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Maximum-Measure-Lifting"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An outline of the implementation is given in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Maximum-Measure-Lifting"

\end_inset

.
 The successors of queued vertices (not the vertices themselves!) are kept
 in a complete binary heap structure, ordered by their progress measure
 vectors, so that the vertex with the largest progress measure vector is
 at the top of the heap.
 The heap is stored in a vertex array of size 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 In order to be able to move vertices up in the heap whenever they are lifted,
 another array of size 
\begin_inset Formula $\left|V\right|$
\end_inset

 keeps track of the position of vertices in the heap.
 (Since progress measure vectors are only ever increased, never decreased,
 moving down is not necessary).
 Finally, for each predecessor in the heap the 
\begin_inset Formula $\texttt{queued}$
\end_inset

 array keeps track of whether it is queued.
 Whenever a vertex is succesfully lifted, all of its predecessors that have
 not yet been assigned top value are marked as queued.
 If there are any, then the vertex itself is inserted into the heap or moved
 up from its current position if it is already present.
 If there are none, then the vertex is removed (at this point, the vertex
 was on top of the heap).
 It should be noted that the 
\begin_inset Formula $\texttt{push()}$
\end_inset

 operation either inserts the vertex into the queue (if it did not exists)
 or raises it (if it did exist, but its progress measure vector has changed)
 but does not insert a vertex twice.
\end_layout

\begin_layout Standard
One might ask why it is necessary to store successors rather than the vertices
 themselves in the heap.
 The reason is that we want to keep vertices ordered not by their own progress
 measure vector, but by the maximum of their successors.
 If we would store vertices directly, then when one vertex is lifted, this
 could cause multiple of its predecessors in the heap to violate the ordering
 in the heap.
 This is hard to fix efficiently.
 However, if we store the successor only, then after each lifting, at most
 one vertex (the one just lifted) can violate the heap property and this
 can be resolved easily by moving the vertex up in the heap if necessary.
\end_layout

\begin_layout Standard
Now, to select the next vertex to be lifted, the highest vertex in the heap
 is consulted, and if any of its predecessors are still marked as queued,
 one of them is returned.
 If there are no queued predecessors, the vertex is removed from the heap,
 and we repeat the process.
 As with the predecessor lifting strategies, the 
\begin_inset Formula $\texttt{queued}$
\end_inset

 array corresponds to the set of dirty vertices, and since vertices are
 only marked as queued when one of their successors is in the heap, it follows
 that when the heap is empty then the dirty set is empty and therefore the
 solution is complete.
\end_layout

\begin_layout Standard
Note that the amount of overhead introduced per lifting attempt is 
\begin_inset Formula $O(\log\left|V\right|)$
\end_inset

 time to insert/move/remove vertices in the heap plus the cost of looping
 over the predecessors of the vertex under consideration, which is quite
 a bit more than the 
\begin_inset Formula $O(1)$
\end_inset

 overhead incurred by the previously described lifting strategies.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
insert reference to benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Section
Improvements
\end_layout

\begin_layout Standard
Apart from implementing better lifting strategies, some improvements to
 the core algorithm are possible too.
 I will discuss the techniques I implemented below; some are novel, and
 others have been previously implemented.
\end_layout

\begin_layout Subsection
Eliminating failed lifting attempts
\end_layout

\begin_layout Standard
When implementing some of the more sophisticated lifting strategies (such
 as the predecessor- and maximum-measure strategies) it became apparant
 that the core algorithm as described in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:SPM v1 Core"

\end_inset

 (and as implemented in all tools that I know of) is rather wasteful.
 To determine if a vertex is stable, it must be lifted.
 In order to lift it, the minimum (or maximum) successor must be found,
 and its progress measure vector must be compared with that of the predecessor.
 Many of these comparisons can be avoided if the core algorithm keeps track
 of the relevant minimum/maximum successor for each vertex.
\end_layout

\begin_layout Standard
For example, if there is a vertex 
\begin_inset Formula $v$
\end_inset

 controlled by Even, and one of its successors (say: 
\begin_inset Formula $w$
\end_inset

) is lifted, this affects 
\begin_inset Formula $v$
\end_inset

's stability if (and only if) 
\begin_inset Formula $w$
\end_inset

 is the current minimum successor for 
\begin_inset Formula $v$
\end_inset

.
 Without retaining this information, however, the only way of knowing whether
 
\begin_inset Formula $v$
\end_inset

's progress measure vector is too low is to re-examine all its successors.
\end_layout

\begin_layout Standard
By allocating only O(
\begin_inset Formula $V$
\end_inset

) extra space in the core algorithm (to store the “dirty” array and the
 minimum/maximum successor for Even/Odd-controlled vertices respectively)
 we can eliminate failed lifting attempts completely, at the cost of somewhat
 greater complexity in the core algorithm implementation.
 However, this also results in a reduction of complexity in the lifting
 strategy; the predecessor lifting strategy becomes absolutely trivial (maintain
ing just a queue/stack of unstable vertices).
\end_layout

\begin_layout Standard
Effectively, this turns the core algorithm inside out: instead of checking
 the successors of a vertex to see if it can be lifted, we only lift known-unsta
ble vertices and then check its predecessors to see if the new value needs
 to be propagated backward.
 This may first appear to be a rather trivial variation, and while it is
 true it doesn't change the worst-case performance of the algorithm, the
 fundamental difference is that it eliminates many redundant progress measure
 vector comparisons.
\end_layout

\begin_layout Standard
It should be clear that the amount of work done per lifting attempt is roughly
 equal on average for both formulations of the core algorithm: while the
 original formulation requires examining all successors of the vertex being
 lifted, this variant examines its predecessors instead.
 However, since this variant algorithm eliminates all failed lifting attempts
 (which make up a considerable part of lifting attempts in most test cases)
 this variation is faster in practice.
\begin_inset Note Note
status open

\begin_layout Plain Layout
REFER TO BENCHMARK RESULTS!
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
pseudo-code of SmallProgressMeasures2?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In my opinion, this approach should be the default, rather than the exception
 to the rule.
 However, all prior implementations seem to follow the more simplistic approach
 described above.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

for (verti v = 0; v < V; ++v) {
\end_layout

\begin_layout Plain Layout

	if (is_top(v)) {
\end_layout

\begin_layout Plain Layout

		stable[v] = true;
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		if v is controlled by Even:
\end_layout

\begin_layout Plain Layout

			strategy[v] = minimum successor
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			strategy[v] = maximum successor
\end_layout

\begin_layout Plain Layout

		stable[v]  = !(spm[v] <? spm[strategy[v]])
\end_layout

\begin_layout Plain Layout

		if (!stable[v]) q.push(v);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while (!queue.empy())
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	verti w = queue.pop()
\end_layout

\begin_layout Plain Layout

	for each predecessor v:
\end_layout

\begin_layout Plain Layout

		if v is not top:
\end_layout

\begin_layout Plain Layout

			if v controlled by Even:
\end_layout

\begin_layout Plain Layout

				if strategy[v] = w:
\end_layout

\begin_layout Plain Layout

					strategy[v] = get_min_succ(v)
\end_layout

\begin_layout Plain Layout

					stable[v] = !(spm[v] <? spm[strategy[v]])
\end_layout

\begin_layout Plain Layout

			if v is controlled by Odd:
\end_layout

\begin_layout Plain Layout

				if strategy[v] = w or spm[w] > spm[strategy[v]]:
\end_layout

\begin_layout Plain Layout

					strategy[v] = w
\end_layout

\begin_layout Plain Layout

					stable[v] = !(spm[v] <? spm[strategy[v]])
\end_layout

\begin_layout Plain Layout

			if !stable[v]:
\end_layout

\begin_layout Plain Layout

				queue.push(v)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SPMv2 (TODO)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Optimization after lifting to top 
\begin_inset CommandInset label
LatexCommand label
name "sub:Optimization-after-lifting"

\end_inset


\end_layout

\begin_layout Standard
The implemention of 
\begin_inset Formula $\texttt{lift}$
\end_inset

 follows the definition above, but with one important enhancement: whenever
 a vertex with odd priority 
\begin_inset Formula $p$
\end_inset

 is lifted to 
\begin_inset Formula $\top$
\end_inset

, the value of 
\begin_inset Formula $M_{p}$
\end_inset

 is decreased by 1.
 As a result, during solving, 
\begin_inset Formula $M$
\end_inset

 is effectively determined by the cardinalities of only those vertices with
 progress measures less than 
\begin_inset Formula $\top$
\end_inset

.
 Note that this may cause some progress measure vectors to temporarily exceed
 the new vector space 
\begin_inset Formula $M'$
\end_inset

, but this will be resolved when the vertex is lifted.
\end_layout

\begin_layout Standard
To see that decreasing the vector space is permissible, even without fixing
 any vectors that are now out of range, consider that if vertex 
\begin_inset Formula $v$
\end_inset

 with priority 
\begin_inset Formula $p$
\end_inset

 is set to 
\begin_inset Formula $\top$
\end_inset

, then 
\begin_inset Formula $v\in W_{1}$
\end_inset

 and thus 
\begin_inset Formula $Attr^{1}(\left\{ v\right\} )\subseteq W_{1}$
\end_inset

, and we could solve the subgame induced by 
\begin_inset Formula $V\setminus Attr^{1}(\left\{ v\right\} )$
\end_inset

 with vector space 
\begin_inset Formula $M"$
\end_inset

 instead.
 However, since 
\begin_inset Formula $M"{}_{p}\subseteq M_{p}'$
\end_inset

 and since we compute a minimum fixed point in both cases, the final progress
 measures vectors must be the same for corresponding vertices in both games.
 This guarantees that the final value of all vectors will lie in 
\begin_inset Formula $M"{}^{\top}$
\end_inset

 in both games, which means any vectors which exceed it in the original
 game cannot be final values, and the corresponding vertices will have to
 be lifted again, at which point they will be brought back in range.
\end_layout

\begin_layout Standard
This enhancement is not described by Jurdziński and not implemented in any
 of the other solvers based on Small Progress Measures, to my knowledge;
 all of these assume 
\begin_inset Formula $M$
\end_inset

 to be constant during solving.
 It was invented specifically to remedy cases where the dual solving approach
 (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Two-sided-SPM"

\end_inset

) would perform worse compared to the approach of solving the normal and
 dual game in succession.
 These cases arise because in the latter approach vertices won by Even (in
 the normal game) are removed from the dual game before solving, which reduces
 the complexity of the second problem.
 With the two-sided approach no vertices are ever removed, which would cause
 the dual game to have a significantly larger vector space.
\end_layout

\begin_layout Standard
Besides eliminating this disadvantage in the dual-solving approach, the
 enhancement benefits both variations of the algorithm.
\end_layout

\begin_layout Subsubsection
Correctness proof
\end_layout

\begin_layout Standard
Recall that the goal of Small Progress Measures is to compute the least
 fixed point of 
\begin_inset Formula $Lift(\cdot,v)$
\end_inset

 for any 
\begin_inset Formula $v$
\end_inset

.
 I will describe a function 
\begin_inset Formula $Lift'(\cdot,v)$
\end_inset

 that behaves like 
\begin_inset Formula $Lift(\cdot,v)$
\end_inset

 but implements the optimization described above and prove that fixed point
 iteration yields the same result as the original 
\begin_inset Formula $Lift(\cdot,v)$
\end_inset

 would have.
\end_layout

\begin_layout Standard
Let's redefine 
\begin_inset Formula $M$
\end_inset

 as a vector space 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $M'(\rho)$
\end_inset

 whose dimensions are dependent on the count of 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
non-top
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 vertices in a partially constructed progress measure 
\begin_inset Formula $\rho$
\end_inset

:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula 
\[
M'_{i}(\rho)=\begin{cases}
\{0\} & \mbox{if \ensuremath{i\equiv0\mod{2}}}\\
\{0..\left|\{v\in V:\phi(v)=i\;\wedge\;\rho(v)\neq\top\}\right|\} & \mbox{if \ensuremath{i\equiv1\mod{2}}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Clearly, 
\begin_inset Formula $M'(\rho)\subseteq M$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 Then, define 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $Prog'(\rho,v,w)$
\end_inset

 to draw from 
\begin_inset Formula $M'(\rho)$
\end_inset

 instead of 
\begin_inset Formula $M$
\end_inset

 and similarly 
\begin_inset Formula $Lift'(\rho,v)$
\end_inset

 in terms of 
\begin_inset Formula $Prog'(\rho,v,w)$
\end_inset

 instead of 
\begin_inset Formula $Prog(\rho,v,w)$
\end_inset

.
 The monotonicity of the lifting function is preserved and thus fixed point
 iteration can still be used to find a minimal fixed point of 
\begin_inset Formula $Lift'(\rho,v)$
\end_inset

, but what remains to be shown is that the value computed in this way is
 the same as for the original definitions of these functions.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $\rho(v)\in M'(\rho)$
\end_inset

 for all 
\begin_inset Formula $v\in V$
\end_inset

 then 
\begin_inset Formula $\rho=Lift(\rho,v)\iff\rho=Lift'(\rho,v)$
\end_inset

, since the equations involved in the definitions are exactly the same.
\end_layout

\begin_layout Enumerate
If 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\rho$
\end_inset

 is a fixed point of 
\begin_inset Formula $Lift'(\cdot,v)$
\end_inset

 then 
\begin_inset Formula $\rho$
\end_inset

 is also a fixed point of 
\begin_inset Formula $Lift(\cdot,v)$
\end_inset

, which follows from the fact that the range of 
\begin_inset Formula $Prog'$
\end_inset

 is limited to 
\begin_inset Formula $M'(\rho)$
\end_inset

 and 1.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $\rho$
\end_inset

 is the least fixed point of 
\begin_inset Formula $Lift(\cdot,v)$
\end_inset

 then 
\begin_inset Formula $\rho$
\end_inset

 is also a fixed point of 
\begin_inset Formula $Lift'(\cdot,v)$
\end_inset

, which follows from the fact that 
\begin_inset Formula $\rho(v)\in M'(\rho)$
\end_inset

 for all 
\begin_inset Formula $v\in V$
\end_inset

 and 1.
 To see why 
\begin_inset Formula $\rho(v)\in M'(\rho)$
\end_inset

, consider that if 
\begin_inset Formula $i$
\end_inset

 is odd and 
\begin_inset Formula $\rho$
\end_inset

 is a least progress measure, then the 
\begin_inset Formula $i$
\end_inset

th element of the progress measure vectors encodes the maximum number of
 vertices of priority 
\begin_inset Formula $i$
\end_inset

 that can be visited in any play consistent with the strategy induced by
 
\begin_inset Formula $\rho$
\end_inset

 before a vertex of priority 
\begin_inset Formula $j<i$
\end_inset

 is encountered, and there are only 
\begin_inset Formula $M'_{i}(\rho)$
\end_inset

 of those with non-top value, by definition of 
\begin_inset Formula $M'_{i}(\rho)$
\end_inset

 .
\end_layout

\begin_layout Standard
From 2 and 3 it follows that if 
\begin_inset Formula $\rho$
\end_inset

 is the least fixed point of 
\begin_inset Formula $Lift(\cdot,v)$
\end_inset

 then 
\begin_inset Formula $\rho$
\end_inset

 is also the least fixed point of 
\begin_inset Formula $Lift'(\cdot,v)$
\end_inset

 and computing the latter by fixed point iteration suffices to determine
 the former.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
is this redundant compared to 4.1.4?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Game/Graph Preprocessing
\end_layout

\begin_layout Standard
Instead of improving SPM itself, there are a few transformations that can
 be applied to the parity game before passing it to the solver.
 These preprocessing operations are intended to be relatively cheap compared
 to solving the game itself (at least in the worst case).
\end_layout

\begin_layout Subsubsection
Loop removal
\end_layout

\begin_layout Standard
One peculiarity of Small Progress Measures is that it may spend a lot of
 time lifting vertices with high priority values which lie on a cycle.
 The most typical example of this is a vertex which is controlled by player
 Odd, has a high, odd priority and a loop as its only edge.
 The final progress measure for such a vertex will obviously be 
\begin_inset Formula $\top$
\end_inset

 (since Odd will keep the token at this vertex indefinitely), but its progress
 measure will change only in small increments, requiring many lifts to reach
 its final value.
\end_layout

\begin_layout Standard
Something similar occurs for vertices of odd priority which are controlled
 by Even.
 Although these cannot be initialized to 
\begin_inset Formula $\top$
\end_inset

 (they may still be won by Even) we can discard the loop edge to speed up
 propagation of values from successor vertices through this vertex.
\end_layout

\begin_layout Standard
All known implementations of Small Progress Measures do some form of preprocessi
ng where such cases are detected and the progress measures of vertices won
 by Odd are set to 
\begin_inset Formula $\top$
\end_inset

 before running the main algorithm.
 Four cases can be distinguished based on the controller and parity of a
 vertex, as summarized in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SPM-preprocessing"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Player
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Priority
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Winner
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loop edge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Other edges
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
undecided
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
undecided
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\top$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Preprocessing of vertices with loops
\begin_inset CommandInset label
LatexCommand label
name "tab:SPM-preprocessing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Note that when a vertex has only one outgoing edge, then it can be considered
 to belong to either player; in this case it's most beneficial to assign
 it to the player corresponding to the parity of its priority.) There are
 different ways to use this information; the simplest is to remove the useless
 edges and initialize the progress measure vector to 
\begin_inset Formula $\top$
\end_inset

 for the fourth case, and then solve the rest of the game as usual.
\end_layout

\begin_layout Standard
It should be noted that in two of the four cases, it is known to which winning
 set the vertex belongs, and the associated strategy is to use the loop
 back to the vertex.
 A simple extension is then to collect sets of these vertices for each player,
 and extend these to their attractor sets, to obtain a larger subset of
 vertices that are completely solved and can be removed from the game entirely.
 The resulting game graph then has no more loops.
\end_layout

\begin_layout Subsubsection
Winner-controlled cycle removal 
\begin_inset CommandInset label
LatexCommand label
name "sub:Winner-controlled-cycle-removal"

\end_inset


\end_layout

\begin_layout Standard
In his solver, Freark van der Berg introduced a more sophisticated version
 of the loop removal process described above.
 He searches for cycles of vertices controlled by Odd with odd priority,
 using a depth-first-search approach limited to a relatively shallow depth
 (up to 8 deep, in his experiments).
 This results in detection of small cycles only but despite this limitation,
 his benchmark results show that this already provides significant benefits
 over the removal of loops only; at least in large random games, where small
 cycles are common.
\end_layout

\begin_layout Standard
This idea can be improved upon in several ways:
\end_layout

\begin_layout Enumerate
Search for cycles of any size (not just small ones).
\end_layout

\begin_layout Enumerate
Don't limit the search to fixed parity vertices: only the parity of the
 least priority of a cycle matters; if that matches the controlling player,
 the priorities for the other vertices is irrelevant.
\end_layout

\begin_layout Enumerate
Search for cycles controlled by Even as well as Odd.
\end_layout

\begin_layout Standard
The last generalization isn't directly useful to initialize the SPM vector
 space, but it is beneficial when attractor sets of winning regions are
 removed from the graph too.
 The general process is called 
\emph on
winner-controlled cycle removal
\emph default
; i.e.
 removal of all cycles which are entirely controlled by their winning player.
 To find these cycles, depth-first searching through all cycles in the graph
 would be too slow, but fortunately there is a more efficient solution,
 which is similar to the approach used to verify strategies.
\end_layout

\begin_layout Standard
To detect all 
\begin_inset Formula $i$
\end_inset

-cycles controlled by player 
\begin_inset Formula $p$
\end_inset

 (where 
\begin_inset Formula $p\equiv i\mod{2})$
\end_inset

 in the graph, construct the subgraph induced by the vertices controlled
 by 
\begin_inset Formula $p$
\end_inset

 with priority greater than or equal to 
\begin_inset Formula $i$
\end_inset

.
 (Vertices controlled by 
\begin_inset Formula $1-p$
\end_inset

 with outdegree 1 may be considered controlled by 
\begin_inset Formula $p$
\end_inset

.) Decompose the graph into strongly connected components.
 Vertices with priority 
\begin_inset Formula $i$
\end_inset

 that occur in a connected component with at least one edge (i.e.
 either the component contains at least two vertices or the vertex has a
 loop) are part of a cycle with dominant priority 
\begin_inset Formula $i$
\end_inset

.
 If we collect one such vertex per component (if one exists) and then compute
 the attractor set for these vertices, we have identified all vertices which
 either lie on 
\begin_inset Formula $p$
\end_inset

-controlled 
\begin_inset Formula $i$
\end_inset

-cycles or in their attractor set.
\end_layout

\begin_layout Standard
Strategies can be constructed as follows.
 For each vertex in the initial vertex set, pick an arbitrary successor
 
\emph on
in the same component
\emph default
.
 The rest of the strategy is generated as part of attractor set computation.
 Finally, we can extend the winning regions identified in the subgame to
 the attractor set in the global game.
 All vertices identified this way are solved and may be removed from the
 game.
\end_layout

\begin_layout Standard
It may appear redundant to compute attractor sets twice, but this is required
 to create correct strategies.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
CHECKME: is this true??
\end_layout

\end_inset

 Computing only one attractor set (in the global game) does work for purposes
 of computing the winning sets, but it could create cycles in 
\begin_inset Formula $p$
\end_inset

's strategy including vertices with priority less than 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
The process is repeated for every priority in the game.
 Every iteration requires constructing a subgraph with the appropriate vertices,
 decomposing it into strongly connected components, computing the attractor
 set in that subgraph, again in the original game, and finally computing
 a subgame with the remaining vertices.
 Using appropriate data structures, each of these operations takes at most
 time linear in the number of the edges in the graph, for a total runtime
 complexity of 
\begin_inset Formula $O(dE)$
\end_inset

.
\end_layout

\begin_layout Standard
This is considerably more than the 
\begin_inset Formula $O(E)$
\end_inset

 time required for winner-controlled loop removal only, but the potential
 benefits are much larger too, making this preprocessing step useful in
 practice.
 Although cycle removal makes loop removal obsolete (since loops are simply
 very short cycles) it may still be beneficial to run the loop-removal routine
 first to remove winner-controlled loops (and vertices in their attractor
 set) more quickly than the more general procedure could.
\end_layout

\begin_layout Subsubsection
Decomposition into strongly-connected components
\end_layout

\begin_layout Standard
If the game graph contains multiple strongly-connected components, the game
 can be solved in smaller chunks by identifying these components and then
 solving them individually in reverse topological order (i.e.
 starting with components without outgoing edges).
 The question then becomes how to handle edges between components, since
 a subgame induced by a component with outgoing edges may not be a proper
 game.
 A simple approach is to collapse the winning sets of solved components
 into single vertices, but more can be gained by extending winning regions
 identified in one component into attractor sets which may extend into other
 areas of the graph and yield solutions for those vertices basically for
 free.
\end_layout

\begin_layout Standard
This approach can be taken even further by recursively decomposing components
 in the main graph that have been partially solved in the above way.
 This approach is taken in PGSolver and for ease of comparison also in my
 own tool, but it should be noted that it's not strictly an improvement
 of the above method.
 There may be cases where decomposition yields a large component every time,
 and then solving the whole game would take 
\begin_inset Formula $O(EV)$
\end_inset

 time and 
\begin_inset Formula $O(V)$
\end_inset

 invocations of the underlying solver, which sounds good considering the
 worst-case complexity of most solvers, but may be rather slow in practice.
\end_layout

\begin_layout Standard
To prevent such degenerate cases my implementation limits the maximum recursion
 depth in the component solver (which has the additional benefit of preventing
 the solver from crashing due to stack overflow).
\end_layout

\begin_layout Subsubsection
Priority propagation
\end_layout

\begin_layout Standard
Finally, a simple preprocessing step that can be applied to speed up solving
 with Small Progress Measures (and possibly other algorithms as well), is
 a process called 
\emph on
priority propagation
\emph default
 (a term suggested in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

 though the concept already appears in 
\begin_inset CommandInset citation
LatexCommand cite
key "antonik2009polynomial"

\end_inset

): we can replace the priority assigned to a vertex with the greatest priority
 among its successors, if the latter is less than the former, without affecting
 winning sets or optimal strategies in the game, and similarly for the predecess
ors of a vertex.
 (Friedmann & Lange distinguish the two cases by calling them 
\emph on
backwards
\emph default
 and 
\emph on
forwards propagation
\emph default
 respectively, though there seems to be little reason to apply one process
 but not the other.)
\end_layout

\begin_layout Standard
This can be seen to be correct by considering that if a play passes through
 a vertex infinitely often, it must also pass through at least one of its
 successors infinitely often.
 When the vertex priority is greater than all of its successors', then it
 cannot be the dominant priority of the play, so it can be safely decreased.
 The same argument applies to predecessors, of course.
\end_layout

\begin_layout Standard
The rationale for applying this transformation before running SPM is that
 it tends to shift the distribution of priorities towards lower values (since
 lower values can replace higher values, but not the other way around),
 which may both reduce the size of the vector space for progress measures
 and make vector comparisons/updates quicker.
\end_layout

\begin_layout Standard
In practice the performance gain derived from priority propagation appears
 to be small, as has also been noted by Keiren in 
\begin_inset CommandInset citation
LatexCommand cite
key "keiren2009"

\end_inset

.
 Friedmann & Lange report that 
\emph on

\begin_inset Quotes eld
\end_inset

emperically, the use of priority propagation turns out to be harmful
\begin_inset Quotes erd
\end_inset


\emph default
, though their emperical data is not presented.
 Presumably they mean that the time spend preprocessing the graph exceeds
 the time saved during solving.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
experiment!
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Vertex reordering
\end_layout

\begin_layout Standard
The vertices of a graph are not intrinsically ordered.
 However, algorithms that iterate over vertices one by one (such as the
 linear lifting strategy) must assign some order to the vertices, at least
 implicitly.
\end_layout

\begin_layout Standard
With Small Progress Measures, information is propagated backwards against
 the direction of edges: when a vertex is lifted, this may cause some of
 its predecessors to become unstable and suitable for lifting too.
 As a result, the linear lifting strategy is more efficient when vertices
 are ordered such that predecessors are lifted after their successors.
 In order to make such algorithms more efficient, my tool supports several
 options to reorder vertices before running the solving algorithm:
\end_layout

\begin_layout Enumerate
Re-order vertices by depth-first search order.
\end_layout

\begin_layout Enumerate
Re-order vertices by breadth-first search order.
\end_layout

\begin_layout Enumerate
Reverse the order of vertices.
\end_layout

\begin_layout Standard
Reversing the order of vertices is useful when the graph has been constructed
 in a forward fashion, which occurs for example when exploring a state space
 explicitly.
 These reordering operations can also be combined; for example, it may make
 sense to use reverse search order to maximize the ratio of backward to
 forward edges.
\end_layout

\begin_layout Standard
Although vertex reordering makes little difference in practice, it is a
 cheap preprocessing pass that is useful to have as an option.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
benchmark
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Two-sided SPM 
\begin_inset CommandInset label
LatexCommand label
name "sub:Two-sided-SPM"

\end_inset


\end_layout

\begin_layout Standard
A noteworthy variant of the Small Progress Measures algorithm was implemented
 by Oliver Friedmann in PGSolver, although it has not been described in
 literature.
 In this case, the algorithm is not run for one player at a time, but for
 both players at once.
 In Friedmann's implementation this means that a single vertex is selected,
 and it is lifted both in the normal game and its dual, and if either attempt
 succeeds, the predecessor vertices are queued.
 Effectively, the queue is shared between the two games.
 Conceivably, the two games could be processed independently, even in parallel
 on separate machines.
\end_layout

\begin_layout Standard
Periodically (in the current implementation after every 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifting attempts) information about winning vertices is exchanged between
 the games, by conservatively identifying vertices in one game that are
 won by the player for which we are computing the strategy, and setting
 the progress measures of these vertices to 
\begin_inset Formula $\top$
\end_inset

 in the corresponding dual game for his opponent.
 These vertices are identified as follows.
\end_layout

\begin_layout Standard
Without loss of generality, assume we are computing the strategy for player
 Even.
 Then, we add a mark to every vertex for which any of the following conditions
 apply:
\end_layout

\begin_layout Enumerate
Its progress measure is 
\begin_inset Formula $\top$
\end_inset


\end_layout

\begin_layout Enumerate
The vertex is controlled by Even and either:
\end_layout

\begin_deeper
\begin_layout Enumerate
all of its successors are marked; or
\end_layout

\begin_layout Enumerate
its progress measure is less than (or equal to, if the vertex priority is
 odd) all of its unmarked successors
\end_layout

\end_deeper
\begin_layout Enumerate
The vertex is controlled by Odd and either:
\end_layout

\begin_deeper
\begin_layout Enumerate
one of its successors is marked; or
\end_layout

\begin_layout Enumerate
its progress measure is less than (or equal to, if the vertex priority is
 odd) one of its successors
\end_layout

\end_deeper
\begin_layout Standard
Here, 
\begin_inset Quotes eld
\end_inset

less
\begin_inset Quotes erd
\end_inset

 means less with respect to the priority of the current vertex.
 Note that these conditions are consistent with the usual criteria for lifting
 vertices, where the marked vertices are considered to be set to 
\begin_inset Formula $\top$
\end_inset

.
 The interpretation of the marks is that marked vertices may be won by Odd,
 and unmarked vertices are known to be won by Even.
 The unmarked vertices therefore are a subset of the winning set of Even,
 and the corresponding vertices in the dual game being solved for Odd can
 be set 
\begin_inset Formula $\top$
\end_inset

.
 The same process can, of course, be applied for Odd in the dual game to
 get vertices which should be set to 
\begin_inset Formula $\top$
\end_inset

 in Even's game.
\end_layout

\begin_layout Standard
To compute a maximal set of marked vertices, a similar approach as in the
 main SPM algorithm is used: all vertices are queued, checked against the
 properties mentioned above, and whenever a mark is add to a vertex, its
 predecessors must be re-examined, so they are queued again.
 The difference with the main SPM algorithm is that a mark can be added
 only once, which bounds the total processing time to the number of edges
 in the graph.
\end_layout

\begin_layout Standard
The rationale for propagating this information  every 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifting attempts is that this amortizes the overhead involved against the
 work done lifting vertices, so that the worst-case complexity remains unchanged.
\end_layout

\begin_layout Subsubsection
Advantages & Disadvantages
\end_layout

\begin_layout Standard
In practice, a game and its dual are often not of the same difficulty.
 In that case, it makes sense to try to solve them both, in order to discover
 the solution to the easiest one, and then use the information gained to
 construct a subgame with the remaining unsolved vertices in the dual game,
 which is then usually much easier to solve.
 The extra amount of work done in this case is at most equal to the amount
 of work done for the easiest game, but with the benefit that we do not
 have to know or guess in advance which of two players is easier to solve
 for.
 The worst case occurs when a game and its dual are of comparable difficulty;
 in that case up to twice as much work may be done when solving in parallel
 rather than sequentially.
\end_layout

\begin_layout Standard
Friedmann's two-sided approach has the benefit that it is not applied on
 the entire game, but also on smaller regions of the games, which is beneficial
 in cases where games contain different parts which are hard to solve for
 different players.
 In those cases, the two-sided approach can result in both sides being solved
 in less time than would be possible starting from either side.
\end_layout

\begin_layout Standard
There is some similarity with Schewe's “big step
\begin_inset Quotes erd
\end_inset

 approach 
\begin_inset CommandInset citation
LatexCommand cite
key "schewe2007solving"

\end_inset

 to solving parity games, which also tries to find small winning regions
 first in order to reduce the rest of the problem to simpler terms.
 The similarity is that both approaches provide a way to avoid “getting
 stuck” repeatedly lifting vertices by very small increments.
 Schewe achieves this by using a reduced vector space to find small winning
 regions, obtaining only a partial solution using Small Progress Measures,
 and relies on the recursive algorithm (see chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Zielonka's-Recursive-Algorithm"

\end_inset

) to solve the remainder of the game.
\end_layout

\begin_layout Standard
The two-sided approach solves games entirely with Small Progress Measures
 and is therefore simpler, but doesn't benefit from the theoretical speedup
 achieved by reducing the vector space.
 It should be noted however, that in PGSolver the two approaches are combined:
 the “big steps” solver uses the SPM implementation with the two-sided optimizat
ion.
\end_layout

\begin_layout Subsubsection
Implementation differences
\end_layout

\begin_layout Standard
Unfortunately, there is one flaw in the PGSolver implementation that I tried
 to rectify in my solver.
 PGSolver suffers from regressions where some games require orders of magnitudes
 more lifting attempts before arriving at a solution, compared to the original
 approach (implemented in older versions), rather than the overhead being
 bound by a worst-case factor two as expected.
 This is caused by the fact that PGsolver omits construction of subgames
 entirely, even after one of the sides is completely solved, and as a result
 misses out on the reduction in progress measure vector space that can reduce
 the solving time necessary to solve the harder part of the game.
 The optimization described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimization-after-lifting"

\end_inset

 remedies this.
\end_layout

\begin_layout Standard
Another difference between PGSolver and my implementation is that PGSolver
 uses a single lifting strategy for both the normal and dual game, and when
 lifting vertices, recomputes progress measures for both games at once.
 Although that works, it seems plausible that the sets of liftable vertices
 in the normal and dual game will diverge, so it seems more reasonable to
 instantiate separate lifting strategies for the two games in order to do
 more useful work.
\end_layout

\begin_layout Standard
Finally, in an attempt to propagate information about losing vertices earlier,
 my solver attempts 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifts in one game, before propagating information and switching to the
 dual game (rather than performing 
\begin_inset Formula $2\left|V\right|$
\end_inset

 lifting attempts in total before propagating information in both directions).
\end_layout

\begin_layout Standard
Of these three differences, the first is crucial for optimal performance,
 while the other two are at best small improvements over Friedmann's implementat
ion.
\end_layout

\begin_layout Section
Distributed implementation
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Partition graph, process independently, propagate changes at overlapping
 vertices.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Zielonka's Recursive Algorithm 
\begin_inset CommandInset label
LatexCommand label
name "chap:Zielonka's-Recursive-Algorithm"

\end_inset


\end_layout

\begin_layout Standard
An entirely different approach to solving parity games arises from a constructiv
e proof of the existince of memoryless strategies by Wiesław Zielonka in
 
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset

.
 It is presented solely as a proof, not as an efficient algorithm, but it
 has been shown (e.g.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

 and in 
\begin_inset CommandInset citation
LatexCommand cite
key "keiren2009"

\end_inset

) to work well as an actual solver too.
\end_layout

\begin_layout Standard
Zielonka's formulation of the algorithm is based on previous work by McNaughton
 
\begin_inset CommandInset citation
LatexCommand cite
key "mcnaughton1993infinite"

\end_inset

.
 The main difference is that McNaughton limits himself to finite graphs,
 while Zielonka concerns himself with infinite graphs as well.
 Beauces of their fundamental similarity, Zielonka's algorithm is sometimes
 referred to as McNaughton's algorithm in literature on parity games.
\end_layout

\begin_layout Standard
The algorithm is based on a proof by induction on the number of different
 priorities: when there is a single priority, the game is trivially solved
 (this is the basis for the induction).
 Then, assuming that we can solve any game with 
\begin_inset Formula $d$
\end_inset

 priorities, we can solve any game with 
\begin_inset Formula $d+1$
\end_inset

 priorities as follows.
\end_layout

\begin_layout Standard
Without loss of generality (using priority compression if necessary) suppose
 we start with a game 
\begin_inset Formula $\Gamma$
\end_inset

 in wich some vertices have priority 0.
 Then, we can compute the attractor set of these vertices for player Even
 (
\begin_inset Formula $U=Attr^{0}(\Gamma,\phi^{-1}(0)$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 and its complement 
\begin_inset Formula $V'$
\end_inset

 (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V'=V\setminus U)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 and call the induced subgame
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\Gamma'$
\end_inset

 (
\begin_inset Formula $\Gamma'=\Gamma|V'$
\end_inset

).
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
Since there are no vertices with priority 
\begin_inset Formula $0$
\end_inset

 in 
\begin_inset Formula $\Gamma'$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 left, it has at most 
\begin_inset Formula $d$
\end_inset

 different priorities and
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 we can invoke the induction hypothesis to solve 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\Gamma'$
\end_inset

, yielding winning sets 
\begin_inset Formula $W'_{0}$
\end_inset

 and 
\begin_inset Formula $W'_{1}$
\end_inset

 and associated strategies.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
At this point, we know that 
\begin_inset Formula $W'_{1}\subseteq W_{1}$
\end_inset

 because 
\begin_inset Formula $V'$
\end_inset

 is a trap for Even in 
\begin_inset Formula $\Gamma$
\end_inset

 and therefore any strategy which works for Odd in 
\begin_inset Formula $\Gamma'$
\end_inset

 is winning in 
\begin_inset Formula $\Gamma$
\end_inset

 too.
 The same does not apply to 
\begin_inset Formula $W_{0}$
\end_inset

, because it is possible that Odd can escape from 
\begin_inset Formula $W_{0}$
\end_inset

 into 
\begin_inset Formula $U$
\end_inset

 as 
\begin_inset Formula $V'$
\end_inset

 is not a trap for Odd.
 Let 
\begin_inset Formula $U'=Attr^{1}(\Gamma,W'_{1})$
\end_inset

 then since 
\begin_inset Formula $V\setminus U'$
\end_inset

 is a trap for Odd, we can solve the subgame 
\begin_inset Formula $\Gamma|(V\setminus U')$
\end_inset

 independently to determine the remainder of the winning sets.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: picture!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We thus repeat the process to solve increasingly smaller subgames, until
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
either 
\begin_inset Formula $U=\emptyset$
\end_inset

 (i.e.
 no vertices with priority 0 remain and we we can invoke the induction hypothesi
s to solve it) or 
\begin_inset Formula $U'=\emptyset$
\end_inset

 (i.e.
 all remaining vertices are won by Even).
 Winning strategies can be constructed along the way by combing the strategies
 obtained recursively with those found by computing attractor sets.
\end_layout

\begin_layout Standard
From the above, it is clear that to solve a game with 
\begin_inset Formula $d$
\end_inset

 priorities, we must recursively call the solver at most 
\begin_inset Formula $V$
\end_inset

 times for a worst-case runtime of 
\begin_inset Formula $O(V^{d})$
\end_inset

.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann-recursive-lower-bound"

\end_inset

, Friedmann presents a class of games requiring exponential time to solve,
 with 
\begin_inset Formula $\Omega(fib(V))$
\end_inset

 as a lower bound (where 
\begin_inset Formula $fib(i)$
\end_inset

 returns the 
\begin_inset Formula $i$
\end_inset

-th Fibonacci number).
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The actual algorithm implementation varies a little from the proof structure
 for practical reasons.
 For one thing, the implementation is restricted to finite graphs.
 The inductive proof lends itself to being implemented recursively, but
 a straightforward recursive formulation is undesirable here, because deep
 recursion on a large game may overflow the runtime stack.
 Instead, the implementation is iterative and recurses only when computing
 subgames with fewer priorities, bounding the maximum recursion depth by
 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
Additionally, instead of solving one priority at a time, we will speed up
 the solving process by always looking for the next inversion of parity
 in the game.
 Let an inversion of parity be a priority 
\begin_inset Formula $p$
\end_inset

 such that there is a priority 
\begin_inset Formula $n<p$
\end_inset

 with 
\begin_inset Formula $n\not\equiv p\mod{2}$
\end_inset

 and there are some vertices with priority 
\begin_inset Formula $n$
\end_inset

, some vertices with priority 
\begin_inset Formula $p$
\end_inset

, but no vertices with priority 
\begin_inset Formula $o$
\end_inset

 for any 
\begin_inset Formula $n<o<p$
\end_inset

.
 The number of inversions of parity in the initial game is a limit on the
 recursion depth, but typically (after priority compression) this is equal
 to 
\begin_inset Formula $d$
\end_inset

.
 However, for smaller subgames, the number of inversions may be much lower,
 as not all priority values are necessarily used.
 Specifically, if there are no inversions of parity, then all priorities
 assigned to vertices have the same parity, and the corresponding player
 trivially wins the entire game.
\end_layout

\begin_layout Standard
Otherwise, all vertices with priority less than 
\begin_inset Formula $p$
\end_inset

 (or, equivalently, less than or equal to 
\begin_inset Formula $n$
\end_inset

) can be compressed into a single value.
 In the implementation, this is done implicitly by adding all of these vertices
 to the minimum-priority attractor set (though the game itself is unchanged).
\end_layout

\begin_layout Standard
The recursive algorithm is presented in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Zielonka's-Recursive-Algorithm"

\end_inset

.
 Recall that Strategy is maps vertices to successor vertices (where the
 value 
\begin_inset Formula $\texttt{NO\_VERTEX}$
\end_inset

 is used to indicate that a vertex is not in the controller's winning set).
 This requires that subgame construction preserves vertex indices, at least
 conceptually.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

solve(ParityGame game, Strategy strategy)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Priority p = least_inversion(game)
\end_layout

\begin_layout Plain Layout

	while p < game.d {
\end_layout

\begin_layout Plain Layout

		Set<Vertex> min_prio = { v in game.graph.V
\end_layout

\begin_layout Plain Layout

			where game.priority(v) < p }
\end_layout

\begin_layout Plain Layout

		Set<Vertex> min_prio_attr =
\end_layout

\begin_layout Plain Layout

			make_attractor_set(min_prio, (p-1) mod 2, strategy)
\end_layout

\begin_layout Plain Layout

		Set<Vertex> unsolved =
\end_layout

\begin_layout Plain Layout

			game.graph.get_complement(min_prio_attr)
\end_layout

\begin_layout Plain Layout

		if |unsolved| == 0 { break }
\end_layout

\begin_layout Plain Layout

		ParityGame subgame = game.make_subgame(unsolved)
\end_layout

\begin_layout Plain Layout

		solve(subgame, strategy)
\end_layout

\begin_layout Plain Layout

		Set<Vertex> lost = { v in subgame.graph.V
\end_layout

\begin_layout Plain Layout

			where strategy.winner(v) == p mod 2 }
\end_layout

\begin_layout Plain Layout

		if |lost| == 0 { break }
\end_layout

\begin_layout Plain Layout

		Set<Vertex> lost_attr = 
\end_layout

\begin_layout Plain Layout

			make_attractor_set(lost, p mod 2, strategy)
\end_layout

\begin_layout Plain Layout

		Set<Vertex> remaining =
\end_layout

\begin_layout Plain Layout

			game.graph.get_complement(lost_attr)
\end_layout

\begin_layout Plain Layout

		game = game.make_subgame(remaining)
\end_layout

\begin_layout Plain Layout

		p = least_inversion(game)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for v in game.graph.V {
\end_layout

\begin_layout Plain Layout

		if game.priority(v) < p {
\end_layout

\begin_layout Plain Layout

			if game.player(v) == game.priority(v) mod 2 {
\end_layout

\begin_layout Plain Layout

				strategy[v] = any successor of v
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				strategy[v] = NO_VERTEX
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zielonka's Recursive Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Zielonka's-Recursive-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The solver function itself takes an initial parity game and a strategy array;
 the initial contents of the array are irrelevant, but after completion,
 the strategy will be filled in with the optimal strategy for both players,
 but only for the vertices in the initial game graph.
 Note that the strategy is passed by reference: all invocations of 
\begin_inset Formula $\texttt{solve}$
\end_inset

 share the same array, and entries in the array are updated at different
 invocations, and sometimes overwritten.
 It remains to be shown that the when 
\begin_inset Formula $\texttt{solve}$
\end_inset

 terminates, a complete strategy for both players has been computed.
\end_layout

\begin_layout Standard
The execution of the main algorithm depends on several, simpler helper functions
:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{least\_inversion}$
\end_inset

 returns the least inversion in the game, as described above, by analyzing
 the cardinality of priorities in use.
 If there is no inversion, the game index 
\begin_inset Formula $\texttt{d}$
\end_inset

 is returned instead.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{make\_attractor\_set}$
\end_inset

 takes a vertex set and extends it to its attractor set with respect to
 the given player, as described earlier.
 For all vertices that are added to the set (but not those in initial set)
 the accompanying strategy is also assigned, so that play according to the
 strategy leads to the vertices in the initial set.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{get\_complement}$
\end_inset

 returns the complement of a given vertex set, with respect to the vertex
 set of a graph.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{make\_subgame}$
\end_inset

 constructs the subgame induced by the given vertex set.
 Since in Zielonka's algorithm subgames are constructed from the complement
 of an attractor set, this always results in a proper game.
 (For purposes of the algorithm outlined above, it is assumed that vertex
 identifiers are preserved, so that assignments to the global strategy array
 are consistent with the global game.)
\end_layout

\begin_layout Standard
From a high-level point of view, the algorithm operates by first assuming
 that all vertices in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\texttt{min\_prio\_attr}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 are won by the corresponding player and then recursively solving the rest
 of the game.
 If the rest of the game is won by the same player, the procedure is complete;
 otherwise, the opponent has a non-empty winning set, and can win from any
 vertices in its attractor set as well.
 This attractor set is removed from the game, and the procedure is repeated
 with the remainder, until it becomes empty or entirely won by one player.
\end_layout

\begin_layout Subsection
Strategy computation
\end_layout

\begin_layout Standard
The strategy for vertices in 
\begin_inset Formula $\texttt{min\_prio\_attr}\setminus\texttt{min\_prio}$
\end_inset

 is assigned during attractor set computation.
 The strategy for vertices in its complement are assigned by the recursive
 invocation of 
\begin_inset Formula $\texttt{solve}$
\end_inset

.
 The strategy for vertices in the attractor set of vertices lost to the
 opponent are overwritten by the next attractor set computation; this part
 of the strategy is then final, and the vertices in this set are removed
 from the graph.
\end_layout

\begin_layout Standard
The while-loop exits in three cases: when the game has no more inversions,
 when the attractor set of the minimum priority vertices covers the entire
 game graph, or when the vertices outside this attractor set are all won
 by the player corresponding to the minimum priority vertices.
 In all of these cases, the remaining game has no inversions (i.e.
 it is a single-parity game).
 At this point, the only vertices for which the strategy has not been assigned,
 are those with priority less than 
\begin_inset Formula $\texttt{p}$
\end_inset

.
 For those, it suffices to pick an arbitrary successor in the remaining
 part of the game (which is done in the for-loop at the end) to complete
 the strategy.
\end_layout

\begin_layout Subsection
Termination
\end_layout

\begin_layout Standard
In this algorithm every recursive invocation removes at least one inversion
 from the game (when 
\begin_inset Formula $\texttt{solve}$
\end_inset

 is called recursively, all vertices with priority less than 
\begin_inset Formula $\texttt{p}$
\end_inset

 are removed, so 
\begin_inset Formula $\texttt{p}$
\end_inset

 is not an inversion in the subgame) so the number of inversions in the
 initial game is an upper bound on the recursion depth.
 Further more, every complete iteration of the while loop removes at least
 two vertices from the game (one in 
\begin_inset Formula $\texttt{lost}$
\end_inset

 and another in its attractor set, overlapping 
\begin_inset Formula $\texttt{min\_prio\_attr}$
\end_inset

) until the game is empty or completely solved, so the maximum number of
 iterations in the while loop is 
\begin_inset Formula $\frac{\left|V\right|}{2}$
\end_inset

.
 Combined, these observations guarantee the algorithm terminates.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- real worst case is probably smaller than 
\begin_inset Formula $\left(\frac{\left|V\right|}{2}\right)^{d}$
\end_inset

; need to figure out how small, and if possible construct a worst-case example.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parallelization
\end_layout

\begin_layout Standard
Zielonka's recursive algorithm is entirely deterministic, in the sense that
 the subgames that must be computed to arrive at an answer are fixed, and
 they can only be computed in a fixed order.
 This is very different from Small Progress Meaures, where individual lifting
 operations can be performed in any order, and can even be performed independent
ly in parallel, without affecting the final outcome of the algorithm.
\end_layout

\begin_layout Standard
This property of Zielonka's algorithm can be seen clearly in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Zielonka's-Recursive-Algorithm"

\end_inset

: every statement in the while-loop depends directly on the result obtained
 in the immediately preceding statement.
 As a result, it is impossible to reorder any statements, let alone evaluate
 different statements in parallel, which suggests that the algorithm cannot
 be parallelized at this level; at least, not without reformulating the
 algorithm.
\end_layout

\begin_layout Standard
Fortunately, parallelizing the algorithm at the top level is not the only
 possible approach.
 Although the algorithm is highly determinstic in its execution, the operations
 that are performed are relatively high-level and computationally expensive.
 Again, in this regard the algorithm differs from Small Progress Measures,
 where the basic operation (a lifting attempt) is so simple that it makes
 little sense to try and parallelize it, for the synchronization overhead
 would likely negate the speedup gained by parallelization.
\end_layout

\begin_layout Subsection
Distributed computation
\end_layout

\begin_layout Standard
My approach to parallelizing Zielonka's algorithm is therefore based on
 attempting to parallize the basic high-level operations on which the algorithm'
s execution is based: 
\begin_inset Formula $\texttt{make\_attractor\_set}$
\end_inset

, 
\begin_inset Formula $\texttt{get\_complement}$
\end_inset

, 
\begin_inset Formula $\texttt{make\_subgame}$
\end_inset

 and the construction of vertex sets in the while-loop, and the construction
 of a final strategy in the for-loop at the end.
 To this end, the initial game graph is partitioned over all available processes
 by assigning every process a distinct part of the vertex set.
 Every process will execute the main algorithm independently, and compute
 the part of the strategy that applies to its local vertex set.
\end_layout

\begin_layout Standard
In the following, it is assumed that processes execute symmetrically (all
 execute the same program) and independently (requiring no synchronization
 between instructions) but that communication is possible between any pair
 of processes by way of message passing.
 This is a fairly common distributed computing scenario, that requires a
 fast local network between otherwise independent computers.
\end_layout

\begin_layout Standard
Besides distributing the computation over several processes, the data structures
 are distributed as well.
 Every process stores the following information locally:
\end_layout

\begin_layout Itemize
The part of the global vertex set assigned to this process; this will be
 called the 
\emph on
internal vertex set
\emph default
.
\end_layout

\begin_layout Itemize
The part of the global strategy corresponding with the internal vertex set.
\end_layout

\begin_layout Itemize
A subgame of the global game graph that contains at least the internal vertex
 set.
\end_layout

\begin_layout Standard
Since no global data needs to be stored at individual processes, the amount
 of memory required per process for a given game decreases as the number
 of assigned processes increases.
 This approach therefore allows the size of games that can be solved to
 be scaled up with the number of processes.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Need to check: is this implemented? If so, more clearly list that as a feature!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With a fixed graph partition, most of the basic operations can be parallelized
 trivially.
 For example, when constructing the minimum priority vertex set, every process
 only considers the vertices in its assigned partition, and constructs a
 local set accordingly.
 The local sets computed by the individual processes form a partition of
 the set computed by the global algorithm.
 Set complements, subgames and final strategies can be constructed this
 way as well, requiring no synchronization between processes.
 The only tricky operation, and the only operation that requires communication
 between processes, is the computation of attractor sets.
 After all, containment of a vertex in an attractor set depends on whether
 none, one or all of its successors are already in the set, but these successors
 may not be part of the local vertex set.
\end_layout

\begin_layout Standard
To allow processes to communicate information about attractor sets in an
 efficient manner, it is useful to include in the local game graph not only
 vertices and edges in the internal vertex set, but also all adjacent vertices
 and the corresponding edges.
 This allows processes to share information with just the other interested
 processes, without having to resort to broadcasting all locally computed
 data, which may well generate so much communication overhead to negate
 any possible benefits from parallelization.
\end_layout

\begin_layout Subsection
Distributed attractor set computation
\end_layout

\begin_layout Standard
The distributed attractor set computation algorithms are based on the sequential
 implementation of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Attractor-set-computation"

\end_inset

, but now each process maintains its own queue of vertices (both internal
 and successors of internal vertices) and a part of the attractor set (internal
 vertices only).
 Processes can work through their local queue independently, but when an
 internal vertex is added to the local attractor set, this information must
 be communicated to the processes responsible for the predecessors of that
 vertex, so they the may add this vertex to their queue too.
\end_layout

\begin_layout Standard
Logically, internal vertices are only ever added to the queue by the process
 itself, and external vertices only by the corresponding external process.
\end_layout

\begin_layout Standard
I implemented two distributed algorithms, which differ in the way they communica
te vertex updates and detect termination.
 The first method is the simplest, but it may require a lot of synchronization
 between processes (and thus cause processes to waste time waiting on each
 other).
 The second method synchronizes only at the end of the calculation, and
 should therefore be more efficient.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
This needs a benchmark.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Synchronous method
\end_layout

\begin_layout Standard
In the synchronous method, the incremental sets from subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Attractor-sets"

\end_inset

 are computed explicitly, with full synchronization between all processes
 in between.
 Each step conists of two phases:
\end_layout

\begin_layout Enumerate
Each process independently calculates the next incremental attractor subset,
 keeping a list of newly added vertices in this phase.
\end_layout

\begin_layout Enumerate
All processes communicate their queued vertices with each other, making
 them aware of the external vertices added to the attractor set in the first
 phase.
\end_layout

\begin_layout Standard
The calculation ends when all processes report that their queues are empty.
 Separating the algorithm in discrete phases makes this case easy to detect.
 However, many steps may be required to reach this state, incurring a proportion
al amount of synchronization overhead.
\end_layout

\begin_layout Subsubsection
Asynchronous method
\end_layout

\begin_layout Standard
In the asynchronous method, processes send updates about vertices as soon
 as they add them to their local attractor set, and add external vertices
 to their queue as soon as they receive them.
\end_layout

\begin_layout Standard
A process is considered 
\emph on
active
\emph default
 when it has vertices remanining in its local queue.
 When its queue becomes empty the process is 
\emph on
idle
\emph default
, but it will be reactivated when it receives an external vertex update
 from another process.
 The algorithm should terminate when all processes are idle, because then
 all queues are empty and the computation is complete.
 To detect distributed termination, I implemented the four-counter method
 described by Friedemann Mattern in 
\begin_inset CommandInset citation
LatexCommand cite
key "mattern1987algorithms"

\end_inset

.
\end_layout

\begin_layout Standard
Because processes are free to interleave three kinds of operations (processing
 queued vertices, sending vertex updates and receiving them), this method
 may be somewhat faster in practice.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
discuss the effect of partitioning schemes on the efficiency of these algorithms
?
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Empirical Evaluation 
\begin_inset CommandInset label
LatexCommand label
name "chap:Empirical-Evaluation"

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

, Friedmann & Lange report on an emperical evaluation of their parity game
 solver on a variety of problems.
 They report the results for three major algorithms: Jurdziński's small
 progress measures algorithm, Zielonka's recursive algorithm and Jurdziński
 & Vöge's strategy improvement algorithm.
 Their solver is written in OCaml and does not support concurrency.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Copy description of games from log (Sunday 19 December)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Benchmark games
\end_layout

\begin_layout Subsection
Generating random games 
\begin_inset CommandInset label
LatexCommand label
name "sub:Random-games"

\end_inset


\end_layout

\begin_layout Standard
To obtain meaningful results using randomly-generated data, the random graphs
 used for benchmarking are generated in a way that is intended to withstand
 at least a few of the most common preprocessing techniques.
\end_layout

\begin_layout Standard
Random games are characterized by the size of the vertex set 
\begin_inset Formula $|V|$
\end_inset

, the average outdegree (or, equivalently, average indegree), and the number
 of priorities 
\begin_inset Formula $d$
\end_inset

.
 For each vertex, the outdegree is chosen uniformly at random between 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $2\times outdegree-1$
\end_inset

 (to guarantee each vertex has at least one outgoing edge) and then adjacent
 vertices are chosen uniformly at random from the vertex set without duplicates
 and exluding the vertex itself (to exclude the possibility of loops).
 Finally, a priority for the vertex is chosen uniformly at random between
 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $d-1$
\end_inset

 (inclusive).
\end_layout

\begin_layout Standard
Graphs generated in this way typically consist of one large, strongly-connected
 component, and several small (usually single-vertex) components.
 For very small graphs there is even a risk of disconnecting the game graph
 entirely! To remedy this, after graph generation, strongly-connected components
 are identified, and those components that have either no incoming or no
 outgoing edges (i.e.
 they lie at the top or bottom of the hierarchy of strongly-connected components
) are connected to each other in a cycle in random order.
 This guarantees the output consists of a single, strongly-connected component
 (at the cost of introducing some extra edges).
\end_layout

\begin_layout Subsection
Generating clustered random games 
\begin_inset CommandInset label
LatexCommand label
name "sub:Clustered-random-games"

\end_inset


\end_layout

\begin_layout Standard
To create games with a little less uniform graph structure (which more closely
 resemble instances arising in practice, as well as being somewhat less
 likely to be solved completely by the cycle-removal preprocessor) it is
 useful to structure the game graph around clusters of some fixed size.
 To generate a game with 
\begin_inset Formula $|V|$
\end_inset

 vertices and clusters of size 
\begin_inset Formula $C$
\end_inset

, first 
\begin_inset Formula $\left\lfloor \frac{|V|}{C}\right\rfloor $
\end_inset

 clusters of size 
\begin_inset Formula $C$
\end_inset

 are randomly-generated using the procedure described in the previous subsection.
 Then, clusters are grouped together, at most 
\begin_inset Formula $C$
\end_inset

 at a time, and connected together according to a randomly-generated game
 with the same parameters.
\end_layout

\begin_layout Standard
For example, if 
\begin_inset Formula $|V|=50$
\end_inset

 and 
\begin_inset Formula $C=10$
\end_inset

, then 5 clusters of 10 vertices each are generated, as well as one 5-vertex
 top-level game that is used to connect these clusters: if there is an edge
 from, say, vertex 1 to 2 in the top-level game, then an edge is added from
 a random vertex in the first cluster to a random vertex in the second cluster.
 If 
\begin_inset Formula $|V|>C^{2}$
\end_inset

 then a third level is needed to combine groups of clusters, and so on,
 for a hierarchy of 
\begin_inset Formula $\left\lceil ^{C}\log\left|V\right|\right\rceil $
\end_inset

 levels in the final graph.
\end_layout

\begin_layout Standard
Since all games generated were strongly-connected, the combined graph will
 be strongly-connected as well.
 However, it does contain somewhat more edges, limited by a factor 
\begin_inset Formula $\frac{C}{C-1}$
\end_inset

 (as the sum of a geometric series).
 Consequently, if few extra edges are desired, the cluster size should not
 be set too small.
\end_layout

\begin_layout Section
Small Progress Measures
\end_layout

\begin_layout Standard
Data set:
\end_layout

\begin_layout Itemize
random graphs
\end_layout

\begin_layout Itemize
spgip cases (decision procedures and elevator verification from SPGIP generated
 with MLSolver/PGSolver)
\end_layout

\begin_layout Standard
I want to show three things:
\end_layout

\begin_layout Itemize
maximum measure propagation is a valid strategy
\end_layout

\begin_layout Itemize
decrement after lifting to top improves SPM in two-sided approach
\end_layout

\begin_layout Itemize
decycle solver works great (also compare with deloop solver)
\end_layout

\begin_layout Standard
(Really emphasize my contributions here!)
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Probably split into sequential/parallel results; depends a bit on what we
 have and what is new.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Subsection
Quantifying lifting strategy overhead
\end_layout

\begin_layout Standard
As has been alluded to in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Lifting-Strategies"

\end_inset

, different lifting strategies may incur different runtime overhead.
 To quantify this overhead, I have run different lifting strategy configurations
 on random graphs with 10 million vertices and average outdegrees of 2 or
 8, disabling all possible optimizations.
 Each experiment was allowed to run up to 10 seconds (which was not enough
 to solve the game in any case).
 For each configuration ten experiments have been performed with ten different
 random seeds and the results have been combined.
\end_layout

\begin_layout Standard
The focus list strategy was configured to retain 1 million vertices, and
 perform a maximum of 10 million lifting attempts on a single focus list.
\end_layout

\begin_layout Chapter
Conclusion
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quickly summarize results and explain how they relate to the research question;
 describe how my research improved the state of the art (which was the research
 goal).
 Hopefully, we can get some useful conclusion like "I've found a lifting
 strategy that works well" and "I found an efficient way to solve a parity
 game concurrently" (this can be quantified pretty well since we have a
 serial algorithm to compare with).
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Future work
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe any untested hypotheses (things I thought about but don't have
 any results on).
 Describe possible ways to extend/improve the research.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
-- solving parametrized parity games symbolically.
\end_layout

\begin_layout Chapter
TODO LIST
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- have I described everything I came up with?
\end_layout

\begin_layout Plain Layout
- should I say `minimum' or `minimal' fixed point?
\end_layout

\begin_layout Plain Layout
The following comes from an old version of the thesis; probably need to
 work this in somehow:
\end_layout

\begin_layout Plain Layout
- Explain how parity games relate to binary equation systems, mu-calculus.
 This basically motivates why research into parity games is of practical
 interest.
 Explain that improving practical performance is of interest even if computation
al complexity doesn't improve.
 (This is critical for motivating research into lifting heuristics and parallel
 algorithms.)
\end_layout

\begin_layout Plain Layout
- Need a 
\begin_inset Quotes eld
\end_inset

research question
\begin_inset Quotes erd
\end_inset

-like section that contains the research question from my proposal.
\end_layout

\begin_layout Plain Layout
- Describe globally what I'm going to do to improve the state of the art:
 Mainly two parts: (0.
 efficient implementation of existing algorithms => not really interesting
 on an academic level) 1.
 find better heuristics for small progress measures (detailed evaluation
 of SPM would be novel?) 2.
 find good way to parallelize small progress measures (this would be somewhat
 novel, although a lockfree implementation exists)
\end_layout

\begin_layout Plain Layout
- Note that source code + documentation is available online/at request
\end_layout

\begin_layout Plain Layout
- 
\begin_inset Quotes eld
\end_inset

small progress measures
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Small Progress Measures
\begin_inset Quotes erd
\end_inset

? (Be consistent!)
\end_layout

\begin_layout Plain Layout
- Finally: spell check!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "bibtotoc,plainurl"

\end_inset


\end_layout

\end_body
\end_document
