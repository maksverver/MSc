#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_author "Maks Verver"
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Title goes here
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
A 
\emph on
parity game
\emph default
 is a game played by two players, called Even and Odd, on a directed graph.
 Each vertex in the graph is associated with (
\emph on
owned
\emph default
 or 
\emph on
controlled
\emph default
 by) one of the two players.
 Furthermore, to each vertex a 
\emph on
priority
\emph default
 is assigned, which is a non-negative integer.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename illustrations/introduction-example.svg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
A small example of a parity game
\begin_inset CommandInset label
LatexCommand label
name "fig:introduction-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are different conventions for the names of players.
 They can be called Even and Odd, or denoted by symbols ◇ and ◻, which is
 particularly useful when visualizing games, as can be seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:introduction-example"

\end_inset

: the shape of the vertices corresponds with the players that control them.
 For the description of algorithms and data structures, especially when
 computations are involved, it is more convenient to use integers 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

.
 For example, if we consider a player 
\begin_inset Formula $x$
\end_inset

, his opponent can be described as 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
A parity game can be described as a quadruple 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

, where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V_{\text{0}}$
\end_inset

 and 
\begin_inset Formula $V_{\text{1}}$
\end_inset

 partition the set of vertices 
\begin_inset Formula $V=V_{0}\cup V_{1}$
\end_inset

 of the graph into vertices controlled by
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 Even and Odd respectively.
 
\begin_inset Formula $E$
\end_inset

 is the set of directed edges in the game graph.
 Note that 
\begin_inset Formula $E$
\end_inset

 is a true set: every ordered pair of vertices has at most one edge between
 them.
 Duplicate edges are not allowed, but loops (edges which lead from a vertex
 back to itself) may occur.
 
\begin_inset Formula $\phi:V\rightarrow\mathbb{N}_{0}$
\end_inset

 is the priority function that assigns a priority to every vertex in the
 graph.
 The number of distinct priority values assigned to vertices in the game,
 is called the 
\emph on
order of the game
\emph default
, wich is equal to the cardinality of the range of 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
Parity games can be played on finite as well as infinite graphs.
 A parity game is called finite if it is played on a graph with a finite
 number of vertices.
 Consequently, the number of edges will be finite too (since the edge set
 is 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
a subset of
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V\times V$
\end_inset

)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
.
 Finally, because the number of distinct priorities is bounded by 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left|V\right|$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
, the order of a finite game is finite as well.
\end_layout

\begin_layout Subsection
Game Play and Winning Conditions
\end_layout

\begin_layout Standard
A parity game is played by placing a token on some initial vertex.
 The player to whom the vertex belongs moves the token to an adjacent vertex,
 which may belong to either player, who then makes the next move.
 When the token lands on a vertex without any outgoing edges, the game ends.
 However, it is more common for a game to continue indefinitely, causing
 an infinite sequence of moves.
 The sequence of moves on the graph is called a 
\emph on
play
\emph default
 and it can be described as the sequence of vertices visited by the token.
 Formally, a sequence 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\pi=v_{1}v_{2}\ldots v_{n}$
\end_inset

 is a finite play if and only if 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\forall i<n\; v_{i}v_{i+1}\in E$
\end_inset

 and 
\begin_inset Formula $v_{n}$
\end_inset

 has no outgoing edges.
 Similarly, an infinite sequence 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is an infinite play if and only if 
\begin_inset Formula $\forall i\in\mathbb{N}\; v_{i}v_{i+1}\in E$
\end_inset

.
 A subsequence of a play that ends on a vertex with outgoing edges is called
 a 
\emph on
partial play
\emph default
.
\end_layout

\begin_layout Standard
For finite plays, the loser of the game is the player who is first unable
 to move.
 His opponent is the winner.
 In a finite play, the loser is therefore simply the controller of the final
 vertex in the play.
\end_layout

\begin_layout Standard
For infinite plays, a more complicated notion of winning is used.
 Let the 
\emph on
dominant priority
\emph default
 
\begin_inset Formula $P(\pi)$
\end_inset

 for a play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 be the smallest value that occurs infinitely often in the sequence 
\begin_inset Formula $\phi(v_{1})\phi(v_{2})\ldots$
\end_inset

 or formally:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
P(\pi)=\min\left\{ p\in\mathbb{N}_{0}:\left|\left\{ i\in\mathbb{N}:\phi(v_{i})=p\right\} \right|=\aleph_{0}\right\} \]

\end_inset


\end_layout

\begin_layout Standard
A play is won by player Even if the dominant priority for the play is even,
 and won by Odd otherwise (hence their names).
 When the set of priorities is finite, the dominant priority is well-defined,
 assigning a winner to every infinite play.
\end_layout

\begin_layout Standard
It should be noted that there is no consensus in literature on how priorities
 should be ordered.
 Throughout this report I will use the convention of lower priority values
 taking precedence over higher values, thus 
\begin_inset Formula $0$
\end_inset

 being the 
\begin_inset Quotes eld
\end_inset

highest
\begin_inset Quotes erd
\end_inset

 priority, which is consistent with the definition given above.
\end_layout

\begin_layout Subsection
Strategies and Solutions
\end_layout

\begin_layout Standard
A strategy for player 
\begin_inset Formula $x$
\end_inset

 assigns a move to each position in which 
\begin_inset Formula $x$
\end_inset

 is to move.
 Formally, the strategy is a function 
\begin_inset Formula $\dot{\sigma}_{x}:V^{*}\times V_{x}\rightarrow V$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 such that if 
\begin_inset Formula $v_{1}\ldots v_{n}$
\end_inset

 is a partial play, then 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=v_{n+1}$
\end_inset

 and 
\begin_inset Formula $v_{1}\ldots v_{n+1}$
\end_inset

 is a (partial) play too.
 A play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is called consistent with a strategy 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
for player 
\begin_inset Formula $x$
\end_inset

 if 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{i})=v_{i+1}$
\end_inset

 for all 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $v_{i}\in V_{x}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
.
\end_layout

\begin_layout Standard
A strategy 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called 
\emph on
winning
\emph default
 for player 
\begin_inset Formula $x$
\end_inset

 at starting vertex 
\begin_inset Formula $v_{1}$
\end_inset

 if all plays 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 consistent with 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 are won by player 
\begin_inset Formula $x$
\end_inset

.
 Parity games of a finite order have the important property that they are
 fully 
\emph on
determined
\emph default
, i.e.
 for every starting vertex either player Even or player Odd has a winning
 strategy.
 Thus, for these games, we can partition the vertex set 
\begin_inset Formula $V$
\end_inset

 of the game graph into two sets of vertices 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

 which can be won by player Even and Odd respectively.
 When the order is infinite, we can still identify disjoint sets 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

, but they may not be a true partition.
\end_layout

\begin_layout Standard
In many practical applications, determination of winning sets is enough
 to constitute a solution.
 For example, when using parity games as a vehicle for model checking, the
 question whether a formal property holds corresponds with the question
 wether a particular vertex in a game graph is won by player Even or Odd.
 In this case it would suffice to determine which player wins from this
 particular vertex without computing strategies and even without fully determini
ng winning sets for either player.
\end_layout

\begin_layout Standard
An objection against determining winning sets without associated strategies
 is that even if we assume the output to be correct, the winning sets alone
 do not provide any insight in 
\emph on
why
\emph default
 a particular vertex is won by a particular player.
 Strategies are useful to understand the outcome of the games.
 In the application of model checking, strategies can be used to show why
 a certain property holds, or generate counter-examples if it doesn't.
 Moreover, if we have not just a winning set, but also associated strategies,
 we can readily verify their correctness (as will be described in detail
 later).
\end_layout

\begin_layout Standard
Therefore, 
\emph on
solving a game
\emph default
 in the most general sense means to identify optimal strategies for both
 players in addition to winning sets for both players.
 Note that even in finite games, strategies (unlike winning sets) do not
 complement each other, so given an optimal strategy for one player, we
 cannot (easily) deduce the strategy for his opponent.
\end_layout

\begin_layout Subsection
Optimal Strategies and Finite Memory
\end_layout

\begin_layout Standard
A strategy 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called an 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
optimal strategy
\emph default
 when it is winning for player 
\begin_inset Formula $x$
\end_inset

 starting from any vertex 
\begin_inset Formula $v\in W_{x}$
\end_inset

.
\end_layout

\begin_layout Standard
Strategy as described above are called 
\emph on
infinite-memory strategies
\emph default
, because they can take the entire move history into account to determine
 the next move.
 In contrast, 
\emph on
memoryless strategies
\emph default
 are strategies which depend only on the current position of token, i.e.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=\dot{\sigma}_{x}(w_{1}\ldots w_{n})$
\end_inset

 whenever 
\begin_inset Formula $v_{n}=w_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
We will define memoryless strategies as functions 
\begin_inset Formula $\sigma_{x}:V_{x}\rightarrow V$
\end_inset

 such that if
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\sigma_{x}(v)=w$
\end_inset

 then 
\begin_inset Formula $vw\in E$
\end_inset

.
 A memoryless strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 is then consistent with a play 
\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset

 if 
\begin_inset Formula $\sigma_{x}(v_{i})=v_{i+1}$
\end_inset

 for all 
\begin_inset Formula $v_{i}\in V_{x}$
\end_inset

.
 We can restrict the domain of 
\begin_inset Formula $\sigma_{\text{x}}$
\end_inset

 to 
\begin_inset Formula $V_{\text{x}}\cap W_{x}$
\end_inset

 since for vertices in 
\begin_inset Formula $V_{x}$
\end_inset

but not in 
\begin_inset Formula $W_{\text{x}}$
\end_inset

, player 
\begin_inset Formula $x$
\end_inset

 has no winning move, and therefore any adjacent vertex can be selected
 without affecting the optimality of the strategy.
 Even if we leave out these vertices for which the controlling player has
 no winning move, optimal strategies are not (necessarily) uniquely defined,
 unlike winning sets.
\end_layout

\begin_layout Standard
Sometimes we want to refer to the combined strategies of both players, 
\begin_inset Formula $\sigma$
\end_inset

, defined as:
\begin_inset Formula \[
\sigma(v)=\begin{cases}
\sigma_{0}(v) & \mbox{if }v\in V_{0}\\
\sigma_{1}(v) & \mbox{if }v\in V_{1}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
It turns out that for all games of finite order optimal memoryless strategies
 exist.
 Research on finite-order games typically focuses on finding memoryless
 strategies for both players, which can be described succinctly by simply
 listing an optimal move for every vertex, which is especially practical
 for games on finite graphs.
\end_layout

\begin_layout Standard
Since this report is about finding optimal strategies to finite parity games,
 the term 
\emph on
strategy
\emph default
 without further qualification will be used to mean 
\emph on
optimal memoryless strategy
\emph default
, and the 
\emph on
solution
\emph default
 to a parity game is a triple 
\begin_inset Formula $W_{0},W_{1},\sigma$
\end_inset

 describing the winning sets and optimal strategy for both players.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename illustrations/introduction-example-solved.svg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The example game solved
\begin_inset CommandInset label
LatexCommand label
name "fig:introduction-example-solved"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:introduction-example-solved"

\end_inset

 the solution for the example game presented earlier is shown.
 Vertices are partioned into winning sets for both players.
 Edges that cannot be part of winning strategies are dashed.
 In this particular case, any of the solid edges can be chosen to yield
 an optimal strategy.
\end_layout

\begin_layout Section
Computational Complexity
\end_layout

\begin_layout Standard
The computational complexity of parity games as a decision problem (i.e.
 asking whether a particular vertex is won by a particular player) is not
 yet known.
 Assuming that a polynomial-time algorithm to verify the optimality of a
 pair of winning strategies exists (and indeed it does; one will be presented
 later on) then we can solve the more general problem of determining winning
 sets as well as strategies by nondeterministically guessing the winner
 and an optimal move for each vertex, which puts the problem in NP (the
 set of problems decidable by a non-deterministic Turing machine and verifiable
 by a deterministic Turing machine in polynomial time), where the strategies
 are certificates for the solution.
\end_layout

\begin_layout Standard
The problem of determining winning sets alone is in UP.
 From the symmetry of the problem (winning sets complement each other) it
 follows that the problem is in co-NP and co-UP as well, simply by reversing
 the roles of the players.
\end_layout

\begin_layout Standard
It is not known whether or not solving parity games is an NP-complete problem.
 The fact that it is in both NP and co-NP suggests that it is not, for otherwise
 it would be co-NP-complete as well, and NP and co-NP would be equal, which
 current evidence suggests is not the case, unless P equals NP (and consequently
 co-NP) as well.
 Therefore, it is suspected that it should be possible to solve parity games
 in polynomial time only.
 However, no proof of this property exist.
 The known algorithms are exponential in the order of the game.
\end_layout

\begin_layout Standard
The best known time complexity bound on the problem is that of Jurdziński's
 Small Progress Measures algorithm which has an upper bound of 
\begin_inset Formula $O\left(d\left|E\right|\left(\frac{\left|V\right|}{\left\lfloor d/2\right\rfloor }\right)^{\left\lfloor d/2\right\rfloor }\right)$
\end_inset

 where 
\begin_inset Formula $d$
\end_inset

 is the order of the game, and this bound is tight for particular known
 instances.
 Fortunately, many instances arising in practice can be solved much more
 quickly than the worst-case complexity, making parity game algorithms feasible
 in graphs with dozens of different priorities and thousands to billions
 of vertices.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add citation for proof of complexity bounds (probably below to related work).
 Add complexity of Zielonka, SPM and strategy improvement? Maybe add section
 about reduction to other (NP-complete of course) problems?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Application To Model Checking
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To write.
 Should include mapping from modal mu calculus + LTS to parity games.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
A considerably amount of literature is available on parity games specifically
 and on more general perfect-information games played on infinite graphs
 and trees, as well as their relationship to computing automata and the
 application to model checking.
 The majority of this work is theorethical in nature.
\end_layout

\begin_layout Standard
A proof of determinacy for Borel games, of which parity games are a specializati
on, was given by Donald A.
 Martin in 
\begin_inset CommandInset citation
LatexCommand cite
key "martin1975borel"

\end_inset

.
 Additionally, Klarlund proves in 
\begin_inset CommandInset citation
LatexCommand cite
key "klarlund1994progress"

\end_inset

, that memoryless strategies exist for players in Borel games when using
 a Rabin winning condition, of which the parity condition is a special case.
 Both of these results are more general than needed for parity games.
 Zielonka gives two direct proofs for the memoryless determinacy of parity
 games specifically in 
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset

.
 Jurdziński points out in 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset

 that a consequence of both players following memoryless strategies on a
 finite graph is that plays will eventually become periodic.
\end_layout

\begin_layout Standard
Zielonka also summarizes and improves many previous results on more general
 classes of games played on infinite labaled graphs, with winning conditions
 that are more complex than the parity condition.
 These games cannot generally be solved by memoryless strategies, but many
 of the concepts he mentions are still applicable to parity games, which
 is why some of his terminology will be used in this report.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe other algorithms not described in this paper (strategy improvement,
 others implemented in PGSolver).
\end_layout

\begin_layout Plain Layout
Describe previous solvers (notably, PGSolver, but also stuff done at UT)
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Building blocks for parity game solvers
\end_layout

\begin_layout Standard
Before discussing algorithms used to solve parity games, it is important
 to have a clear view of which type of games can and cannot be solved, and
 to have established common terminology to identify the components used
 in parity game solvers, as well as known properties of these components.
 Many of these preliminary definitions have been introduced in previous
 work, but unfortunately the terminology varies subtly (and sometimes fundamenta
lly) which makes it hard to continue here without establishing precisely
 what is meant by a number of common terms and concepts.
 
\end_layout

\begin_layout Standard
The purpose of this section of the report is to introduce a number of restrictio
ns and definitions that will apply to the rest of the report.
 Firstly, a number of restrictions on the game structure will be given,
 that simplify the definition and discussion of the algorithms and datastructure
s that follows.
 Secondly, a number of useful properties of parity games will be presented;
 none of these are new, but they will be defined in a manner consistent
 with the preceding definitions.
 Thirdly, a number of notable special cases of parity games will be discussed;
 these deserve to be mentioned but are otherwise outside the scope of this
 report.
 Finally, a polynomial-time algorithm for the verification of parity game
 algorithms will be presented, which is used to guarantee the correctness
 of the reported results.
\end_layout

\begin_layout Section
Restrictions on the graph
\end_layout

\begin_layout Standard
For convenience, I will assume some restrictions on the structure of the
 graph, which simplify the design and analysis of the data structures and
 algorithms involved considerably, but which do not diminish the practical
 utility of parity games algorithms.
 Of these, the first two properties are simplifications that do not limit
 the classes of games that can be analyzed in general.
 Only the third restriction is a true restriction in a theoretical sense.
 These restrictions are as follows:
\end_layout

\begin_layout Enumerate
Every vertex has at least one outgoing edge.
\end_layout

\begin_layout Enumerate
The graph is connected.
\end_layout

\begin_layout Enumerate
The graph is finite.
\end_layout

\begin_layout Standard
The first property makes finite plays impossible, which simplifies the analysis
 of many algorithms.
 We will call a game a 
\emph on
proper game
\emph default
 if its graph satisfies this property.
 However, improper games (whose game graphs contain vertices with no outgoing
 edges) can be turned into proper games by considering each vertex without
 outgoing edges.
 If it is controlled by player 
\begin_inset Formula $x$
\end_inset

, we can change its priority to 
\begin_inset Formula $1-x$
\end_inset

 and add an edge from the vertex back to itself.
 In the modified graph every vertex has an outgoing edge, yet it has the
 same solution and winning strategies as the original graph.
\end_layout

\begin_layout Standard
The second property does not restrict the classes of games that can be solved
 either.
 During a play, the token never leaves the (weakly) connected component
 of the graph that it starts in, so for any unconnected graph, we can trivially
 decompose the graph into weakly connected components, analyze these components
 individually, and combine the results.
\end_layout

\begin_layout Standard
The final property is a true restriction because it makes it impossible
 to analyze infinite graphs.
 This has practical as well as theoretical benefits.
 From a practical point of view, since all of the game data is now finite,
 it allows us to represent graphs explicitly using only finite memory (otherwise
, we would need a symbolic representation).
 From a theoretical point of view, a finite vertex set allows for algorithms
 and proofs that do not generalize to infinite graphs.
 In particular, the winner of any play can be decided, because the order
 of the graph is finite, as has been established in the preceding.
\end_layout

\begin_layout Section
Restrictions on the set of priorities
\end_layout

\begin_layout Standard
When discussing actual implementations of data structures and algorithms,
 it is convenient to assume that the priorities in the game are not just
 integers, but bounded by a value that is as small as possible.
 Fortunately, we can reduce the values of priorities used to a range between
 0 and 
\begin_inset Formula $d$
\end_inset

 (exclusive), where 
\begin_inset Formula $d$
\end_inset

 is the order of the game.
 This is done by remapping priorities for vertices in a process called 
\emph on
priority compression.

\emph default
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite: PGSolver manual? or an earlier paper?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider we have a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 and we wish to apply priority compression.
 To do so, we find the first unused priority (say, 
\begin_inset Formula $p$
\end_inset

) in the game.
 If 
\begin_inset Formula $p=d$
\end_inset

 then all priorities from 
\begin_inset Formula $0$
\end_inset

 through 
\begin_inset Formula $d-1$
\end_inset

 (inclusive) are used and since the order of the game is 
\begin_inset Formula $d$
\end_inset

 this means we are done.
 Otherwise, let 
\series bold

\begin_inset Formula $q$
\end_inset


\series default
 be the least priority greater than 
\begin_inset Formula $p$
\end_inset

 that is used.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $p=0$
\end_inset

 then we can decrement all priorities by 
\begin_inset Formula $q$
\end_inset

 and, if 
\begin_inset Formula $q$
\end_inset

 is odd, we additionally switch the roles of players Even and Odd.
 Formally, we construct a game 
\begin_inset Formula $\Gamma'=(V_{\text{0}}',V_{\text{1}}',E',\phi')$
\end_inset

 where 
\begin_inset Formula $V_{x}'=V_{y}$
\end_inset

 and 
\begin_inset Formula $x=y-p\mod{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
, 
\begin_inset Formula $\phi'(v)=\phi(v)-q$
\end_inset

 and 
\begin_inset Formula $E'=E$
\end_inset

.
\end_layout

\begin_layout Standard
If, however, 
\begin_inset Formula $p>0$
\end_inset

 then we keep 
\begin_inset Formula $V_{0}'=V_{0}$
\end_inset

 and 
\begin_inset Formula $V_{1}'=V_{1}$
\end_inset

.
 However, if 
\begin_inset Formula $p\equiv q\mod{2}$
\end_inset

 then we get rid of the unused priorities and lump the vertices with priority
 
\begin_inset Formula $q$
\end_inset

 in with those with priority 
\begin_inset Formula $p$
\end_inset

.
 After all, 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 have the same parity, and since none of the values in between are used,
 they can be interchanged without affecting the outcome of the game.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Does this need proof?
\end_layout

\end_inset

 More formally, in this case we define 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi'(v)$
\end_inset

 as:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 
\begin_inset Formula \[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q & \mbox{\mbox{if }\ensuremath{\phi(v)>p}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $p-q\equiv0\mod{2}$
\end_inset

 we have preserved parity: 
\begin_inset Formula $\phi'(v)\equiv\phi(v)\mod{2}$
\end_inset

.
 Finaly, if 
\begin_inset Formula $p>0$
\end_inset

 and 
\begin_inset Formula $p\not\equiv q\mod{2}$
\end_inset

 then we can remove the unused priorities, but we do not want to equate
 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 which have different priorities:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q+1 & \mbox{\mbox{if} \ensuremath{\phi(v)<p}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Again, since 
\begin_inset Formula $p-q+1\equiv0\mod{2}$
\end_inset

 this preserved the parity of 
\begin_inset Formula $\phi$
\end_inset

 while removing the unused priorities between 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 We need to repeat the process described here for every gap in the set of
 used priorities (which is at most 
\begin_inset Formula $d$
\end_inset

 times) and the result will always be a set of 
\begin_inset Formula $d$
\end_inset

 used priorities from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $d-1$
\end_inset

 (inclusive).
\end_layout

\begin_layout Standard
Most solving algorithms do not require that priorities are compressed into
 a minimal range, but the maximum occurring priority usually is a component
 in the total amount of time or memory required.
 Therefore, it is useful to preprocess every game to minimize the priority
 set in this way, especially since this can be easily done in time linear
 in the number of vertices, which makes it a relatively inexpensive operation.
\end_layout

\begin_layout Section
Common Terminology
\end_layout

\begin_layout Standard
There are a number of concepts which can be applied to parity games which
 have been described in literature before.
 In particular, Zielonka introduces some useful terminology in a treatise
 on two-player games played on coloured graphs (of which parity games are
 a subset) which will be repeated here.
 He describes attractor sets and traps.
 Additionally, I will describe subgames analogous to (though slightly different
 from) subarenas.
\end_layout

\begin_layout Subsection
Subgames
\end_layout

\begin_layout Standard
A 
\emph on
subgame
\emph default
 of a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 induced by a vertex set 
\begin_inset Formula $U\subseteq V$
\end_inset

 is the game 
\begin_inset Formula $\Gamma|U=(V_{\text{0}}\cap U,V_{\text{1}}\cap U,E\cap\left(U\times U\right),\phi|U)$
\end_inset

 where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi|U$
\end_inset

 denotes 
\begin_inset Formula $\phi$
\end_inset

 with its domain limited to 
\begin_inset Formula $U$
\end_inset

.
 In other words, the game obtained when only considering vertices from 
\begin_inset Formula $U$
\end_inset

 and ignoring the rest.
 
\begin_inset Formula $\Gamma|U$
\end_inset

 is called a 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
proper subgame
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 if every vertex in 
\begin_inset Formula $U$
\end_inset

 has at least one successor also in 
\begin_inset Formula $U$
\end_inset

 (in other words, if 
\begin_inset Formula $\Gamma|U$
\end_inset

 is a proper game as described above).
\end_layout

\begin_layout Subsection
Traps
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $vE$
\end_inset

 be the set of vertices which are successors of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $E$
\end_inset

, or formally 
\begin_inset Formula $vE=\left\{ w|vw\in E\right\} .$
\end_inset

 Analogously, 
\begin_inset Formula $Ew=\{v|vw\in E\}$
\end_inset

.
 A non-empty vertex set 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $U\subseteq V$
\end_inset

 is a trap for player 
\begin_inset Formula $x$
\end_inset

 (or an 
\begin_inset Formula $x$
\end_inset

-trap, for short) when, informally, player 
\begin_inset Formula $x$
\end_inset

 cannot force the token out of 
\begin_inset Formula $U$
\end_inset

.
 Formally, 
\begin_inset Formula $U$
\end_inset

 is an 
\begin_inset Formula $x$
\end_inset

-trap if for all 
\begin_inset Formula $v\in U$
\end_inset

:
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \[
v\in V_{x}\rightarrow vE\setminus U=\emptyset\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \[
v\in V_{1-x}\rightarrow vE\cap U\neq\emptyset\]

\end_inset


\end_layout

\begin_layout Subsection
Attractor sets
\end_layout

\begin_layout Standard
An attractor set for a player 
\begin_inset Formula $x$
\end_inset

 on a vertex set 
\bar under

\begin_inset Formula $U\subseteq V$
\end_inset


\bar default
, denoted 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

, is the set of vertices from which the player 
\begin_inset Formula $x$
\end_inset

 can force the token into one of the vertices in 
\begin_inset Formula $U$
\end_inset

 (including, by definition, vertices in 
\begin_inset Formula $U$
\end_inset

 itself).
 It is a fixed point attractor under expansion using the recursive definition:
\end_layout

\begin_layout Standard
Zielonka gives an iterative definition of an attractor set:
\begin_inset Formula \[
U_{0}=U\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
U_{i+1}=U_{i}\cup\{v\in V_{x}:\; vE\cap U_{i}\neq\emptyset\}\cup\{v\in V_{1-x}:\; vE\setminus U_{i}=\emptyset\}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
Attr^{x}(\Gamma,U)=U_{0}\cup U_{1}\cup\cdots\]

\end_inset


\end_layout

\begin_layout Standard
This is also useful to compute the attractor set iteratively.
 Since it is a fixed point attractor, 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
converges to 
\begin_inset Formula $U_{i}$
\end_inset

 with 
\begin_inset Formula $U_{i}=U_{i+1}$
\end_inset

.
 From a practical point of view, we expand the attractor set until we can
 add no more vertices to it, and then we are done.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Using an appropriate data structure (for example, a hash table) attractor
 sets can be computed in time linear in the number of edges incident to
 vertices in the resulting attractor set.
 With typical sparse graphs, this is linear in the size of the attractor
 set as well.
\end_layout

\begin_layout Subsubsection
Attractor strategies
\end_layout

\begin_layout Standard
An important property of attractor sets, is that if 
\begin_inset Formula $U\subseteq W_{x}$
\end_inset

, then 
\begin_inset Formula $Attr^{x}(\Gamma,U)\subseteq W_{x}$
\end_inset

 too.
 Of course, if we know the optimal strategy for all vertices 
\begin_inset Formula $v\in U$
\end_inset

, then we also want to extend this strategy to 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

.
 Fortunately, this can easily be done: every vertex that appears first in
 
\begin_inset Formula $U_{i+1}$
\end_inset

 (i.e.
 it is a member of 
\begin_inset Formula $U_{i+1}\setminus U_{i}$
\end_inset

) has a successor in 
\begin_inset Formula $U_{i}$
\end_inset

, and when we repeatedly choose such a successor, then we arrive at 
\begin_inset Formula $U_{0}$
\end_inset

 in 
\begin_inset Formula $i$
\end_inset

 steps, at which point the rest of the strategy is known.
 Zielonka proves these properties in more detail.
\end_layout

\begin_layout Subsubsection
Duality between attractor sets and traps
\end_layout

\begin_layout Standard
The second important property of attractor sets, is that the complement
 of an attractor set for player 
\begin_inset Formula $x$
\end_inset

 (formally: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V'=V\setminus Attr^{x}(\Gamma,U)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
) is a trap for 
\begin_inset Formula $x$
\end_inset

.
 Moreover, if 
\begin_inset Formula $\Gamma$
\end_inset

 is a proper game, 
\begin_inset Formula $\Gamma|V'$
\end_inset

 is a proper subgame
\emph on
 
\emph default
of 
\begin_inset Formula $\Gamma$
\end_inset

, since if a vertex 
\begin_inset Formula $v\in V'$
\end_inset

 has no successor 
\begin_inset Formula $w\in V'$
\end_inset

 then all its successors must be in 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 would have, by definition, been in the attractor set, instead of its complement.
\end_layout

\begin_layout Standard
This property is important because it means that if we start with a proper
 game (which is assumed in the following) then we can safely remove attractor
 sets of arbitrary vertex sets and obtain a proper subgame, which is not
 the case if we would remove arbitrary vertex sets.
 This technique can be used to break down a game in parts which are solved
 in order.
\end_layout

\begin_layout Section
Degenerate cases
\end_layout

\begin_layout Standard
In addition to games which do not comply with the restrictions mentioned
 earlier, there are also a few classes of degenerate games that are special
 cases of the general game describe above.
 They are mentioned separately because specific algorithms exist to solve
 them quicker than is possible for the general case.
\end_layout

\begin_layout Standard
These special cases are occasionally provided as input to a solver (for
 example, as the representation of a particularly simple model checking
 problem) but more commonly they arise as subgames to be solved after applying
 a number of reductions or partial solution techniques.
\end_layout

\begin_layout Subsection
Single-parity games
\begin_inset CommandInset label
LatexCommand label
name "sub:Single-priority-games"

\end_inset


\end_layout

\begin_layout Standard
If the priorities of vertices all have the same parity (even or odd) then
 the corresponding player will trivially win from every starting vertex,
 with an arbitrary strategy.
 A special case is the single-priority game, where only a single priority
 is used.
 Note that priority compression will reduce both single-parity and single-priori
ty games to a game in which 0 is the only priority in use, making this type
 of game easy to recognize.
\end_layout

\begin_layout Subsection
Single-player games
\end_layout

\begin_layout Standard
A parity game is a 
\emph on
single-player game for player 
\begin_inset Formula $x$
\end_inset

 
\emph default
when all vertices controlled by player 
\begin_inset Formula $1-x$
\end_inset

 have outdegree equal to 1.
 In such a game, only player 
\begin_inset Formula $x$
\end_inset

 can make choices, and player 
\series bold

\begin_inset Formula $1-x$
\end_inset


\series default
 is forced to always move the token to the single available successor whenever
 it lands on one of his vertices.
\end_layout

\begin_layout Standard
In such a game, player 
\begin_inset Formula $x$
\end_inset

 wins from precisely from the vertices which lie on a cycle of which the
 minimum priority has parity equal to 
\begin_inset Formula $x$
\end_inset

, as well as from all vertices from which such a cycle can be reached.
 After all, his opponent has no choice, so he can never force the token
 out of a cycle or prevent player 
\begin_inset Formula $x$
\end_inset

 from reaching a cycle when there exists a path to it.
 The remaining vertices (if there are any) are won by player 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
In extremely rare cases the game is played on a cycle graph and neither
 player has a choice.
 In that case, strategies are trivial and whichever player has the dominant
 priority on the cycle wins from any vertex in the game.
\end_layout

\begin_layout Subsection
Graphs of multiple components
\end_layout

\begin_layout Standard
Some game graphs are not completely connected, in the sense that there may
 be pairs of vertices where there exists no path from one vertex to the
 other.
 These graphs can be solved more efficiently by solving strongly connected
 components separately and combining the results.
 There are two main approaches to implementing this.
\end_layout

\begin_layout Standard
The first approach is to solving components in reverse topological order.
 Before solving the subgame induced by a component, we add edges to dummy
 vertices (one won by Even and one won by Odd) for any existing edges that
 have a target outside the current component, depending on which winning
 set contains their target.
 Because of the order in which components are solved, these winning sets
 are well-defined for vertices outside but reachable from the current component.
 The main advantage of this approach is that it requires running the decompositi
on algorithm only once, although creating temporary vertices and edges complicat
es the implementation somewhat.
\end_layout

\begin_layout Standard
A slightly more advanced approach was introduced in PGSolver and implemented
 in my solver as well.
 Here, we look only for a single leaf component (a component with no outgoing
 edges) and solve its induced subgame (which is necessarily a proper subgame).
 Then, we extend the winning sets for both players to their attractor sets
 in the main game.
 The main game is then replaced by a subgame induced by the complement of
 the original graph with these attractor sets removed, and the process is
 repeated until a single component remains.
 Because we remove attractor sets of winning sets only, the constructed
 subgames remain proper subgames.
\end_layout

\begin_layout Standard
In the second approach, we must decompose the graph and constructing a (typicall
y large) subgame once for every subcomponent that is found.
 This seems less efficient thatn the first approach, but it has advantages
 as well, mainly stemming from the fact that the attractor sets of winning
 sets may extend far into the main game, removing solved parts of the graph
 which are much larger than the component which was last solved, and creating
 more separate components in the unsolved part of the graph than were present
 initially.
 In cases where the initial game graph consists of a single component, the
 decomposition algorithm is run only once, and no subgame needs to be constructe
d, so the overhead is limited (and comparable to that of the first approach)
 in these cases.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
What other special cases have been identified?
\end_layout

\begin_layout Plain Layout
Browse PGSolver docs/Jeroen's thesis for stuff worth repeating here.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Verification
\end_layout

\begin_layout Standard
In order to be able to ascertain the correctness of the implemented algorithms,
 it is useful to have a means of verifying the solutions produced by these
 algorithms.
 Of course, algorithms are typically published with a correctness proof
 before they are implemented, but mistakes could be introduced during implementa
tion, which makes it worthwhile to implement a verification routine to validate
 the emperical results.
 The verification algorithm depends on the correct solution of single-player
 games, for which a polynomial time algorithm will be presented.
\end_layout

\begin_layout Subsection
Solving single-player games
\end_layout

\begin_layout Standard
Without loss of generality, suppose we want to solve a single-player game
 for player Even.
 Player Even can win from at least some vertices if the graph contains a
 cycle with even dominant priority (for brevity, let's call this an 
\emph on
even cycle
\emph default
).
\end_layout

\begin_layout Standard
To solve the game, we iteratively identify an even cycle 
\begin_inset Formula $c_{1}c_{2}\ldots c_{n}\in V^{+}$
\end_inset

 in the game (
\begin_inset Formula $c_{i}c_{j}\in E$
\end_inset

 if 
\begin_inset Formula $i+1=j\mod{n}$
\end_inset

 and 
\begin_inset Formula $\min\phi(c_{j})=0\mod{2}$
\end_inset

) 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
and then solve the smaller subgame 
\begin_inset Formula $\Gamma|V\setminus Attr^{x}(\Gamma,\{v_{1}\ldots v_{n}\})$
\end_inset

 in the same manner.
 The strategy for player Even is formed by combining 
\begin_inset Formula $\sigma_{0}(c_{i})=c_{j}$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
if 
\begin_inset Formula $i+1=j\mod{n}$
\end_inset

 with the strategy obtained by computing the attractor set and solving the
 subgame.
 When eventually no even cycle remains, then all possible plays in the remaining
 subgame necessarily have odd dominant priority and player Odd wins from
 the remaining vertices with a trivial strategy, since by definition of
 a single-player game Odd has no choice in the game.
\end_layout

\begin_layout Standard
The question now becomes how to find these even cycles.
 If we call a cycle with dominant priority 
\emph on
i
\emph default
 an 
\emph on
i
\emph default
-cycle, then a game contains an 
\emph on
i
\emph default
-cycle if and only if it contains any vertices with priority 
\emph on
i
\emph default
 lying on a cycle after removal of all edges incident with vertices of priority
 less than 
\begin_inset Formula $i$
\end_inset

, because an 
\emph on
i
\emph default
-cycle can only include edges between vertices of priority 
\emph on
i
\emph default
 or higher.
 To find an 
\emph on
i
\emph default
-cycle in a graph with edges between vertices of priorities 
\emph on
i
\emph default
 or higher, we can use the connection between strongly connected components
 of the graph and a cycle in the graph: every cycle must lie in a single
 strongly connected component and if the edge set of a strongly-connected
 component is non-empty, then all vertices in the strongly-connected component
 must lie on a cycle (by the definition of strongly connected components).
\end_layout

\begin_layout Standard
To find an even cycle, then, it suffices to try to find an 
\begin_inset Formula $i$
\end_inset

-cycle all even values of 
\begin_inset Formula $i$
\end_inset

, and for each value construct a graph with edges incident only to vertices
 of priority 
\begin_inset Formula $i$
\end_inset

 or higher, which is then decomposed into strongly connected components.
 If a vertex with priority 
\begin_inset Formula $i$
\end_inset

 exists in a component which contains at least one edge, then a cycle can
 be found with a backtracking search within the component, which will visited
 every edge at most once.
\end_layout

\begin_layout Standard
Because identifying strongly connected components takes at least 
\begin_inset Formula $O(E)$
\end_inset

 time (for example, using Tarjan's algorithm, described in 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1971depth"

\end_inset

) and subgame construction typically takes 
\begin_inset Formula $O(E)$
\end_inset

 time as well, it would not be very efficient to remove attractor sets one
 cycle at a time.
 Instead, after decomposing the graph for priority 
\begin_inset Formula $i$
\end_inset

, we can search for one cycle per component and compute the attractor set
 of all these cycles combined in order to remove all 
\begin_inset Formula $i$
\end_inset

-cycles from the game at once.
 This way, the algorithm requires at most 
\series bold

\begin_inset Formula $O(d)$
\end_inset


\series default
 iterations and in the worst case 
\begin_inset Formula $O(d\left|E\right|)$
\end_inset

 total time.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: compare with PGSolver, if that's different.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Verification of strategies
\end_layout

\begin_layout Standard
Altough it is hard to compute the optimal strategies for the players in
 a parity game, it is much easier to verify that a pair of a winning sets
 and associated strategies are sound.
 To verify winning sets, it would suffice to solve the parity game with
 a known-good algorithm and then verify that it produced the same winning
 sets.
 This isn't possible for strategies, which are generally not unique, so
 even if we obtain an optimal strategy, this does not imply that different
 strategies are invalid.
 Therefore, we need a separate algorithm to verify strategies.
\end_layout

\begin_layout Standard
As we noted before, we are only interested in the strategy for vertices
 that are in the winning set of the player that controls them.
 Assume we are verifying the set 
\begin_inset Formula $W_{x}$
\end_inset

 with optimal strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 for player 
\begin_inset Formula $x$
\end_inset

.
 Define a graph with vertices limited to 
\begin_inset Formula $W_{x}$
\end_inset

 and the set of edges 
\begin_inset Formula $E|\sigma_{x}$
\end_inset

 as follows:
\begin_inset Formula \[
E|\sigma_{x}=\left\{ vw\in E:v\in\left(W_{x}\cap V_{x}\right)\wedge\sigma_{\text{x}}(v)=w\right\} \cup\left\{ vw\in E:v\in\left(W_{x}\cap V_{1-x}\right)\right\} \]

\end_inset


\end_layout

\begin_layout Standard
Less formally, the edge set includes the edges that are consistent with
 
\begin_inset Formula $x$
\end_inset

's strategy, as well as all edges originating at vertices controlled by
 his opponent.
 We must first verify two trivial properties:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $E|\sigma_{x}\subseteq E$
\end_inset

 (otherwise the strategy 
\begin_inset Formula $\sigma_{\text{x}}$
\end_inset

 prescribes a transition that is not available in the original game graph)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $E|\sigma_{x}\subseteq W_{\text{x}}\times W_{x}$
\end_inset

 (otherwise either the player or his opponent can move the token outside
 the winning set)
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Assuming these hold, then 
\begin_inset Formula $\Gamma|\sigma_{\text{x}}=(W_{x}\cap V_{x},W_{x}\cap V_{1-x},E|\sigma_{x},\phi|W_{x})$
\end_inset

 is a proper subgame of 
\begin_inset Formula $\Gamma$
\end_inset

, and precisely those plays in the original game consistent with strategy
 
\begin_inset Formula $\sigma_{x}$
\end_inset

 are possible in the game 
\begin_inset Formula $\Gamma|\sigma_{\text{x}}$
\end_inset

 as well, except that all choice for player 
\begin_inset Formula $x$
\end_inset

 has been removed.
 Since every vertex controlled by 
\begin_inset Formula $x$
\end_inset

 has only one successor, this makes 
\begin_inset Formula $\Gamma|\sigma_{x}$
\end_inset

 a single-player game controlled by player 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
To verify that the original strategy was sound, we can solve this single
 player using the method described earlier, and verify that the winning
 set for player 
\begin_inset Formula $W_{1-x}$
\end_inset

 in the subgame is empty.
 This proves the validity of both the winning set 
\begin_inset Formula $W_{x}$
\end_inset

 and strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
maybe expand a bit on the proof?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time required for the last step is bounded by 
\begin_inset Formula $O(d\left|E\right|)$
\end_inset

 as before, where 
\begin_inset Formula $d$
\end_inset

 is the order of the game.
 Since 
\begin_inset Formula $d\leq\left|V\right|$
\end_inset

 the verification algorithm is indeed polynomial in time.
 It is fast in practice when the game graph is sparse and the number of
 distinct priorities is low, which is often the case.
\end_layout

\begin_layout Chapter
Common algorithms and data structures
\end_layout

\begin_layout Standard
The results that will be presented later on are based on emperical evaluation
 of various parity game solving algorithms on both synthetic and real-world
 cases.
 The results obtained therefore depend not only on the choice of algorithms,
 but also on various implementation details, such as the data structures
 and programming techniques used to implement those algorithms.
\end_layout

\begin_layout Standard
It has been shown that in practice different experimental tools have different
 performance characteristics despite being based on the same theoretical
 algorithms.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite some proof?
\end_layout

\end_inset

 This phenomon occurs because of undocumented differences in the implementation
 of these different tools, sometimes arising from intentional changes to
 those algorithms (preprocessing operations or optimizations for particular
 instances, for example) and more often because the algorithms described
 in literature are usually not described to a sufficient level of detail
 that they can be implemented without being forced to make concrete implementati
on choices.
 For theoretical analysis this is not necessary (and usually, in the interest
 of conciseness, not desired), but for practical results it matters significantl
y how the missing parts are implemented concretely.
\end_layout

\begin_layout Standard
In order to ensure that the results presented here are reproducible, and
 to make the differences in results obtained with different tools easier
 to understand and explain, I will document the choices that I made in the
 implementation of my solving tool to a fair amount of detail.
 In particular, the core data structures and the algorithms will be documented
 precisely.
\end_layout

\begin_layout Standard
Finally, the descriptions provided here and in later chapters are a useful
 key to understanding the source code of my solver tool, since it provides
 a high-level overview of its design.
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
Recall that a parity game consists of a directed graph, a partition of vertices
 into sets owned by the two players, and the assignment of a priority to
 every vertex.
 This data must be represented in some way in a solver.
\end_layout

\begin_layout Standard
When executing a solving algorithm, the parity game data is read, but usually
 not modified.
 Therefore, an implementation that allows efficient read-only access is
 more important than a data structure with high flexibility in regards to
 updates.
 However, many of the simplification and preprocessing algorithms must either
 modify the parity game under consideration or be able to quickly construct
 a modified copy of it.
 This use case must be accommodated as well.
\end_layout

\begin_layout Standard
Finally, since practical instances of parity games tend to be fairly large,
 it is desirable that the parity game representation is as compact as possible,
 to the extend this is possible without compromising access speed.
 This not only reduces the amount of memory needed to solve particularly
 large instances, but also ensures that the solving algorithms benefit maximally
 from cache effects.
\end_layout

\begin_layout Subsection
The game graph structure
\end_layout

\begin_layout Standard
A parity game is played on a directed graph, which consists of a set of
 vertices (
\begin_inset Formula $V$
\end_inset

) and a set of edges (
\begin_inset Formula $E\subseteq V\times V$
\end_inset

).
 Vertices will be identified with integers from 0 through 
\begin_inset Formula $\left|V\right|$
\end_inset

 (exclusive).
 At a minimum, we will store 
\begin_inset Formula $\left|V\right|$
\end_inset

 and 
\begin_inset Formula $\left|E\right|$
\end_inset

, the number of vertices and edges in the graph respectively.
\end_layout

\begin_layout Standard
To represent the graph in its entirety, we then only need to store the edges.
 We could store those as an array of pairs of integers (the source and destinati
on vertices of a directed edge).
 This is reasonably compact (requiring 
\begin_inset Formula $2\left|E\right|$
\end_inset

 integers to be stored).
 However, this representation is impractical if we want to quickly access
 a set of successors (
\begin_inset Formula $vE$
\end_inset

) or predecessors (
\begin_inset Formula $Ev$
\end_inset

) of a vertex, which are common operations in many algorithms.
\end_layout

\begin_layout Standard
Therefore, a different representation is used.
 Suppose we start with the array of edges described above and sort them
 by source vertex first, and destination vertex second.
 Then, all the edges from a vertex 
\begin_inset Formula $v$
\end_inset

 to its successors will occur as a consecutive sequence in the edge array,
 and we can store for each vertex the interval 
\begin_inset Formula $[\mathtt{succBegin[v],\mathtt{succEnd[v]})}$
\end_inset

.
\end_layout

\begin_layout Standard
This representation would require 
\begin_inset Formula $2\left|E\right|+2\left|V\right|$
\end_inset

 integers to be stored, and allows the following operations to be performed
 efficiently:
\end_layout

\begin_layout Enumerate
Enumerate the successors of a vertex (
\begin_inset Formula $vE$
\end_inset

), in order.
\end_layout

\begin_layout Enumerate
Calculate the number of successors of a vertex (
\begin_inset Formula $\left|vE\right|$
\end_inset

), by calculating 
\begin_inset Formula $\mathtt{succEnd[v]}-\mathtt{succBegin[v]}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Determine if 
\begin_inset Formula $vw\in E$
\end_inset

 (using binary search, this could take 
\begin_inset Formula $O\left(log\left(\left|vE\right|+1\right)\right)$
\end_inset

 time).
\end_layout

\begin_layout Standard
Of course, the first operation is the one that is most common.
 Next, we can apply two simplifications.
 First, since the predecessor vertex of all edges with indices between 
\begin_inset Formula $\mathtt{succBegin[v]}$
\end_inset

 and 
\begin_inset Formula $\mathtt{succEnd[v]}$
\end_inset

 are known to be equal to 
\begin_inset Formula $v$
\end_inset

, we don't need to store predecessor vertices at all.
 Additionally, it is easy to see that 
\begin_inset Formula $\mathtt{succEnd[v]=succBegin[v+1]}$
\end_inset

 for all 
\begin_inset Formula $v$
\end_inset

 except the last vertex, so we can store all indices in a single array of
 length 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left|V\right|+1$
\end_inset

, instead of using two arrays.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
This it the final representation that is used, and requires 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\left|E\right|+\left|V\right|+1$
\end_inset

 integers to store the edge data.
 However, this edge representation only allows us to quickly find successors
 of edges.
 For some algorithms, it is useful to be able to find predecessors quickly
 as well.
 For this reason, the graph data structure by default stores the edge set
 in reverse order too, doubling the amount of memory required.
\end_layout

\begin_layout Standard
It should be noted that this dense edge representation does not allow efficient
 insertion or removal of individual edges in the game graph, because each
 such operation requires a large part of the edge array to be moved.
 Fortunately, the preprocessing algorithms that are applied in the solver
 are applied to the graph as a whole, and the cost of individual changes
 can therefore be amortized over the entire graph-wide operation.
\end_layout

\begin_layout Subsection
The parity game structure
\end_layout

\begin_layout Standard
In addition to the game graph, a parity game must store two attributes for
 each vertex:
\end_layout

\begin_layout Enumerate
The controlling player (Even or Odd), and
\end_layout

\begin_layout Enumerate
the associated priority value, 
\begin_inset Formula $\phi(v)$
\end_inset

.
\end_layout

\begin_layout Standard
These two attributes are packed into a two-byte structure, and stored in
 an array of length 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 Note that this limits the maximum priority that can be represented to 255,
 which seems low, but is much larger than occurs in practice (although synthetic
 cases with larger priorities could easily be generated).
\end_layout

\begin_layout Standard
Additionaly, we store in the parity game structure two properties of the
 game:
\end_layout

\begin_layout Enumerate
The priority limit (
\begin_inset Formula $d$
\end_inset

) which is calculated as the maximum priority value used + 1.
 (This is equal to the order of the game assuming all priority values are
 used.)
\end_layout

\begin_layout Enumerate
An array of integers of length 
\begin_inset Formula $d$
\end_inset

 that stores how many vertices occur with each individual priority value.
\end_layout

\begin_layout Standard
This information can be recomputed from the vertex attributes in time 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

, but it is useful in a number of situations, for example, to quickly calculate
 the worst-case execution time of the SPM algorithm or to quickly determine
 whether priority compression is possible.
\end_layout

\begin_layout Subsection
The solution structure
\end_layout

\begin_layout Standard
Every solving algorithm needs to return a solution to the given parity game,
 which consists of a partitioning of the vertex set into winning sets for
 both players, and a strategy for each player which is defined at least
 for vertices in the winning set of that player.
\end_layout

\begin_layout Standard
This characterization shows that there is a strong relation between winning
 sets and strategies of players: when a player controls a vertex which lies
 outside his winning set, he has no meaningful strategy there (as every
 possible move is by definition losing).
 Therefore, we will simply define solutions as arrays which assign to every
 vertex the successor vertex for the controlling player, or the special
 value 
\begin_inset Formula $-1$
\end_inset

 if it is in his opponent's winning set instead:
\begin_inset Formula \[
\mathtt{solution[v]}=\begin{cases}
\sigma_{0}(v) & \mbox{ if }v\in V_{0}\cap W_{0}\\
\sigma_{1}(v) & \mbox{ if }v\in V_{1}\cap W_{1}\\
-1 & \mbox{ if }v\in(V_{0}\cap W_{1})\cup(V_{1}\cap W_{0})\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
From a solution array, winning sets and strategies can be trivially obtained
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
W_{x}=\{v\in V_{x}:\;\mathtt{solution[v]}\neq-1\}\]

\end_inset


\begin_inset Formula \[
\sigma_{x}(v)=\begin{cases}
\mathtt{solution[v]} & \mbox{ if }v\in W_{x}\\
\min(vE) & \mbox{ if \ensuremath{v\notin W_{x}}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Note that the choice of the minimum successor for vertices which are lost
 to the current player is arbitrary; in those cases any successor could
 be chosen.
\end_layout

\begin_layout Subsection
Subgame construction
\end_layout

\begin_layout Standard
Many algorithms require subgames to be constructed.
 Since the data structure described above requires a dense representation
 of vertices, this requires that all data is reconstructed.
 The subgame 
\begin_inset Formula $\Gamma|U$
\end_inset

 is constructed from an array containing the vertex identifiers in 
\begin_inset Formula $U$
\end_inset

 while the ordering of the elements determines the new identifiers of the
 vertices in the subgraph.
\end_layout

\begin_layout Standard
The main cost in constructing a subgame comes from the construction the
 successor and/or predecessor arrays of the subgraph, which is done by iterating
 over all successors (or predecessors, as the case may be) of vertices in
 
\begin_inset Formula $U$
\end_inset

, filtering out vertices which are outside of 
\begin_inset Formula $U$
\end_inset

, and possibly sorting the remapped vertices.
 To filter vertex efficiently, either a hashtable or a boolean array is
 used to represent 
\begin_inset Formula $U$
\end_inset

, depending on the size of 
\begin_inset Formula $U$
\end_inset

 relative to 
\begin_inset Formula $V$
\end_inset

: for small subsets the mapping is sparse and a hashtable is more efficient.
\end_layout

\begin_layout Standard
The exact time complexity depends on the outdegree for vertices in 
\begin_inset Formula $U$
\end_inset

.
 If we assume the graph to be very sparse (i.e.
 the outdegree is 
\begin_inset Formula $O(1)$
\end_inset

) then subgame construction takes 
\begin_inset Formula $O(\left|U\right|)$
\end_inset

 space.
 Even if the graph is not sparse, subgame construction takes time linear
 in the number of edges of the resulting subgraph, as long as the outdegree
 of the subgame is comparable to that of the vertices in the original graph.
\end_layout

\begin_layout Standard
This is the assumption that will be used in this report to analyze the complexit
y of algorithms that rely on subgame construction, which includes Zielonka's
 algorithm, as well as many preprocessing operations.
 Finally, it should be noted that when constructing subgames, the array
 
\begin_inset Formula $U$
\end_inset

 is kept around in order to map the vertex indentifiers in the subgame back
 to the original game, which is necesssary to propagate solution and strategy
 information back to the main game, and for gathering of global statistics
 and debugging information.
\end_layout

\begin_layout Subsection
Attractor set computation
\end_layout

\begin_layout Standard
In my implementation, attractor sets are computed straightforwardly using
 a queue and a set, where both data structures are assumed to have 
\begin_inset Formula $O(1)$
\end_inset

 performance for the relevant operations (for example, a deque and a hash
 table satisfy these requirements).
 The queue is initialized to the attractor set.
 Every iteration, a vertex is extracted from the queue and its predecessors
 are examined.
 Any predecessor which is controlled by the player for whom we are computing
 the attractor set, or which is controlled by his opponent but has no successors
 outside the attractor set, is added to the queue and the attractor set,
 and (optionally) the strategy for the new vertex is updated.
 Because the attractor set computation is analogous to a breadth-first search,
 the strategy reflects the shortest path from vertices in the extended attractor
 set to vertices in the initial set.
 The algorithm is presented in detail as Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Attractor-set-computation"

\end_inset

.
\end_layout

\begin_layout Standard
Computing attractor sets requires both predecessor and successor information
 be stored in the graph, and the resulting algorithm is reasonably efficient
 for sufficiently sparse graphs.
 However, the worst-case complexity is as high as 
\begin_inset Formula $O(ev)$
\end_inset

 where 
\begin_inset Formula $v$
\end_inset

 is the size of the resulting set and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $e$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 is the number of edges incident to vertices in the set.
 This complexity arises from the fact that when a predecessor is controlled
 by the opponent of the player for whom the attractor set is computed, then
 all successors of this vertex must be evaluated to see if an edge to a
 vertex outside the attractor set exists; in a worst-case scenario, all
 vertices currently in the attractor set could be reachable before a successor
 outside it is found.
\end_layout

\begin_layout Standard
The complexity can be reduced to 
\begin_inset Formula $O(e)$
\end_inset

 by keeping track of the last successor evaluated for every vertex outside
 the vertex set, so that we can restart the search there (knowing that the
 preceding successors are already known to lie inside the attractor set),
 which limits the number of times an edge is examined to 
\begin_inset Formula $3e$
\end_inset

.
 In typical sparse graphs, the overhead of maintaining an additional data
 structure may outweigh the benefit of a lower worst-case complexity bound,
 which is why this optimization is currently not implemented.
 However, for sake of computing the complexity of other algorithms, the
 theoretical bound of 
\begin_inset Formula $O(e)$
\end_inset

 is used.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

Set<Vertex> make_attractor_set(
\end_layout

\begin_layout Plain Layout

	ParityGame game, Player player,
\end_layout

\begin_layout Plain Layout

	Set<Vertex> initial, Strategy s )
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Queue<Vertex> todo
\end_layout

\begin_layout Plain Layout

	Set<Vertex> attr
\end_layout

\begin_layout Plain Layout

	for v in initial {
\end_layout

\begin_layout Plain Layout

		attr.insert(v)
\end_layout

\begin_layout Plain Layout

		todo.push_back(v)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	while not todo.empty() {
\end_layout

\begin_layout Plain Layout

		Vertex v = todo.pop_front()
\end_layout

\begin_layout Plain Layout

		for u in game.graph.predecessors(v) {
\end_layout

\begin_layout Plain Layout

			if u in attr {
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			if game.player(u) == player {
\end_layout

\begin_layout Plain Layout

				strategy[u] = v
\end_layout

\begin_layout Plain Layout

			} else if game.graph.successors(u) is subset of attr {
\end_layout

\begin_layout Plain Layout

				strategy[u] = NO_VERTEX
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			attr.insert(u)
\end_layout

\begin_layout Plain Layout

			todo.push_back(u)
\end_layout

\begin_layout Plain Layout

 		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return attr
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Attractor set computation 
\begin_inset CommandInset label
LatexCommand label
name "alg:Attractor-set-computation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Graph decomposition
\end_layout

\begin_layout Standard
To compute strongly connected components, Tarjan's algorithm from 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1971depth"

\end_inset

 is used, which enumerates all strongly connected components in reverse
 topological order (components are found in order such that each component
 has only edges within itself or going into components found before).
 It requires 
\begin_inset Formula $O(\left|E\right|)$
\end_inset

 time and 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 space, even if the algorithm is aborted before all components have been
 found.
\end_layout

\begin_layout Standard
The algorithm as described by Tarjan is based on a depth-first search of
 the graph, labeling vertices as they are visited.
 Depth-first search is typically implemented as a recursive procedure, but
 this is impractical for very large graphs, where high recursion depth may
 exhaust the available stack space.
 Therefore, the implementation uses an iterative approach, with an explicit
 stack data structure which is stored in the heap.
 In addition to removing the limitations on recursion depth, this has the
 additional benefit of being a relative compact representation compared
 to the stack frames that would typically be created in a recursive procedure.
\end_layout

\begin_layout Standard
Components are passed to a callback function as an array of indices of vertices
 in the original graph.
 Such an array can be used to construct a subgame for the component, as
 described above, though it should be noted that the subgame induces by
 a strongly connected component of the game graph is not typically a proper
 subgame itself, unless there are no edges going out of the current component.
\end_layout

\begin_layout Standard
The decomposition algorithm is used to implement solving of individual component
s, removal of owner-controlled cycles and verification of games.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: browse code for stuff I didn't cover yet
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Small Progress Measures
\end_layout

\begin_layout Standard
Small Progress Measures is a relatively simple, iterative algorithm for
 partially solving parity games proposed my Marcin Jurdziński.
 A game is solved only partially in the sense that the winning set and optimal
 strategy for one player is determined.
 To solve a game completely, the algorithm must therefore be run twice,
 but, fortunately, in the second pass the winning set of the first player
 can be omitted from the game graph, which typically reduces the time required
 to solve the remaining part of the game significantly.
\end_layout

\begin_layout Standard
Small Progress Measures (or SPM for short) is attractive because it is relativel
y simple which allows it to be implemented easily and provides ample opportunity
 to parallellize the core algorithm.
 Additionally, the algorithm is among those with the lowest complexity bounds
 known for solving parity games, with a worst-case time complexity of 
\begin_inset Formula $O\left(\left|E\right|\left(\left|V\right|/\left\lfloor \frac{d}{2}\right\rfloor \right)^{\left\lfloor \frac{d}{2}\right\rfloor }\right)$
\end_inset

 and requiring 
\begin_inset Formula $O(\left|V\right|d)$
\end_inset

 space (in addition to space required to store the parity game itself).
\end_layout

\begin_layout Standard
Oliver Friedmann proposed a variation of the algorithm that effectively
 combines the two passes in one, solving both the game and its dual at the
 same time.
 This does not improve on the worst-case time bounds (and, in fact, may
 require around twice as much time and memory compared to the standard algorithm
), but can avoid some of the pitfalls that cause excessive runtimes with
 the standard algorithm, which makes it a useful alternative in practice.
\end_layout

\begin_layout Standard
Small progress measures was previously implemented by Martin Lange and Oliver
 Friedmann in PGSolver (both the regular and two-way algorithm).
 A lock-free concurrent version was implemented by Weber and Van de Pol
 which works on shared-memory systems that do not reorder memory store operation
s.
 A concurrent implementation for the Playstation 3 (taking advantage of
 the capabilities of the multi-core Cell processor) was written by Jorne
 Kandziora and later improved upon by Freark van der Berg.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add references for all of these.
 Note the contribution of my implementation: better heuristics.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Description
\end_layout

\begin_layout Standard
Here I will outline SPM as described by Jurdziński.
 Let's assume we want to solve the game for player even.
 Then, we associate with each vertex a value, which is either a 
\series bold

\begin_inset Formula $d$
\end_inset


\series default
-vector of nonnegative integers or the special value 
\begin_inset Formula $\top$
\end_inset

 (top) indexed from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $d-1$
\end_inset

.
 The 
\series bold

\begin_inset Formula $d$
\end_inset


\series default
-vector is a member of the vector space 
\begin_inset Formula $M=M_{0}\times M_{1}\times\cdots\times M_{d-1}$
\end_inset

 where 
\begin_inset Formula $M_{i}$
\end_inset

 is defined:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
M_{i}=\begin{cases}
\{0\} & \mbox{if \ensuremath{i\equiv0\mod{2}}}\\
\{0..\left|\{v\in V:\phi(v)=i\}-1\right|\} & \mbox{if \ensuremath{i\equiv1\mod{2}}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Elements from the set 
\begin_inset Formula $M^{\top}=M\cup\{\top\}$
\end_inset

 are called Small Progress Measures (the term 
\begin_inset Quotes eld
\end_inset

small
\begin_inset Quotes erd
\end_inset

 is used because they come from a reduced vector space where every even
 element is fixed to zero) and will be denoted with lower-case Greek letters.
 On these values a comparison operator 
\begin_inset Formula $<_{i}$
\end_inset

 is defined that compares two vectors lexicographically up to (and including)
 the element with index 
\begin_inset Formula $i$
\end_inset

.
 
\begin_inset Formula $\top$
\end_inset

 is always considered greater than any vector.
 Formally:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\begin{array}{cl}
\alpha<_{i}\beta\;\Leftrightarrow\alpha\neq\top\wedge\beta=\top & \mbox{if }\ensuremath{\alpha=\top\mbox{ or }\beta=\top}\\
\exists j\leq i:\;\alpha_{j}<\beta_{j}\wedge\left(\forall k<j:\;\alpha_{j}=\beta_{j}\right) & \mbox{otherwise}\end{array}\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
The operator 
\begin_inset Formula $<_{i}$
\end_inset

 establishes a strict weak ordering on the elements of 
\begin_inset Formula $M^{\top}$
\end_inset

.
 The other operators can then be defined accordingly:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha>_{i}\beta\;\Leftrightarrow\;\beta<_{i}\alpha\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha\leq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha>_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha\geq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha<_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha=_{i}\beta\;\Leftrightarrow\left(\alpha\leq_{i}\beta\right)\wedge\left(\alpha\geq_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha\neq_{i}\beta\;\Leftrightarrow\left(\alpha<_{i}\beta\right)\vee\left(\alpha>_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\rho:V\rightarrow M$
\end_inset

 be a function that maps progress measures to vertices.
 We will first define a function 
\begin_inset Formula $Prog(\rho,v,w):(V\rightarrow M)\times E\rightarrow M^{\top}$
\end_inset

 that determines the minimum progress measure for 
\begin_inset Formula $v$
\end_inset

 when 
\begin_inset Formula $vw$
\end_inset

 is included in the strategy for player Even.
 It is defined as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Prog(\rho,v,w)=\begin{cases}
\top & \mbox{if \ensuremath{\rho(w)=\top}, otherwise:}\\
\min_{m\in M^{\top}}m\geq_{\phi(v)}\rho(w) & \mbox{if \ensuremath{\phi(v)\equiv0\mod{2}},}\\
\min_{m\in M^{\top}}m>_{\phi(v)}\rho(w) & \mbox{if }\ensuremath{\phi(v)\equiv1\mod{2}}.\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Next we can define a function 
\begin_inset Formula $Lift(\rho,v)$
\end_inset

 which attempts to increase the progress vector assigned to 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $\rho$
\end_inset

, as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Lift(\rho,v)(u)=\begin{cases}
\rho(u) & \mbox{if \ensuremath{u\neq v}}\\
\max\{\rho(v),\min_{vw\in E}Prog(\rho,v,w)\} & \mbox{if \ensuremath{u=v\wedge v\in V_{0}}}\\
\max\{\rho(v),\max_{vw\in E}Prog(\rho,v,w)\} & \mbox{if }\ensuremath{u=v\wedge v\in V_{1}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
And similarly, globally:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Lift(\rho)=\begin{cases}
Lift(\rho,v) & \mbox{if \ensuremath{\exists v\in V:\; Lift(\rho,v)\neq\rho},}\\
\rho & \mbox{otherwise}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Now if we iterate 
\begin_inset Formula $Lift(\rho)$
\end_inset

 starting from a zero progress measure (
\begin_inset Formula $\rho(v)_{i}=0$
\end_inset

 for all 
\begin_inset Formula $v\in V$
\end_inset

 and 
\begin_inset Formula $i\in\{0..d-1\}$
\end_inset

) we will arrive at a minimum fixed point 
\begin_inset Formula $\rho=Lift(\rho)$
\end_inset

.
 This is our final progress measure function and Jurdziński proves that
 we can use its value as follows to deduce the winning sets and the strategy
 for player Even:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
W_{0}=\{v\in V:\;\rho(v)<\top\}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
W_{1}=\{v\in V:\;\rho(v)=\top\}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\sigma_{0}(v)=w\mbox{ if \ensuremath{v\in W_{0}}and}\rho(v)=_{\phi(v)}\rho(w)\]

\end_inset


\end_layout

\begin_layout Standard
(Note that if in the last definition the choice of 
\begin_inset Formula $w$
\end_inset

 is not unique, we can arbitrarily choose any of the possible successors
 to obtain an optimal strategy.)
\end_layout

\begin_layout Subsection
Lifting Strategies
\end_layout

\begin_layout Standard
In the above description it has not been specified how we will select a
 vertex to be lifted (in the first line of the definition of 
\begin_inset Formula $Lift(\rho)$
\end_inset

) when more than one choice of vertex is available.
 This is because, as part of the correctness proof for the algorithm, Jurdziński
 shows that the order in which vertices are lifted does not matter.
 Regardless of the strategy used, the algorithm will always arrive at the
 unique minimum fixed point, and the worst-case number of applications of
 the 
\begin_inset Formula $Lift$
\end_inset

 function required to arrive at this fixed point, does not depend on the
 choice of vertices to lift.
\end_layout

\begin_layout Standard
However, in practice this strategy for vertex selection appears to have
 a large impact on the running time of the implementation.
 There are two reasons for this:
\end_layout

\begin_layout Enumerate
As mentioned above, in many cases an appropriate vertex selection strategy
 can reduce the number of applications of 
\begin_inset Formula $Lift(p)$
\end_inset

 required to find the minimum fixed point, and since each application takes
 roughly the same time, this generally means faster execution.
\end_layout

\begin_layout Enumerate
In a practical implementation, to find a vertex that can be lifted, one
 has to consider vertices from a possible set of candidates, and calculate
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)(v)$
\end_inset

 in order to determine if 
\begin_inset Formula $Lift(\rho,v)\neq\rho$
\end_inset

.
 If the lifting attempt fails, we have achieved nothing, an inappropriate
 strategy may spend a relatively large amount of time on failed lifting
 attempts.
\end_layout

\begin_layout Standard
We will call the computation of 
\begin_inset Formula $Lift(\rho,v)(v)$
\end_inset

 a 
\emph on
lifting attempt
\emph default
, which can either succeed (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)(v)\ne\rho$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
) or fail 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)(v)=\rho$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
.
 Depending on the implementation, a succesful lifting attempt may be more
 costly than an unsuccesful attempt, but both have non-zero cost, so the
 goal for an efficient implementation will be to minimize both of these
 operations.
\end_layout

\begin_layout Standard
When a lifting attempt at a vertex 
\begin_inset Formula $v$
\end_inset

 does not change its progress measure vector, then we call the vertex (temporari
ly) stable.
 Eventually, all vertices in the graph become stable when the minimum fixed
 point has been reached.
 In general, we want to avoid trying to lift stable vertices as this doesn't
 progress the algorithm, but in many cases we do not know whether a vertex
 is stable or not unless we try to lift it.
 Typically, we cannot avoid at least one unsuccesful lifting attempt for
 each vertex in order to prove all progress measures have stabilized.
\end_layout

\begin_layout Standard
We will assume in the following that the cost of a succesful lifting attempt
 is constant regardless of the vertex being lifted.
 In practice, the cost depends at least on the priority of the vertex and
 how many successors it has 
\begin_inset Note Note
status open

\begin_layout Plain Layout
refer to actual implementation where this is clear
\end_layout

\end_inset

, but since both the maximum priority and the average out-degree is typically
 low, we might ignore this for sake of simplicity.
 Similarly, we will assume that the cost of failed lifting attempts is constant
 as well, and is no greater than that of a succesful lifting attempt, as
 the same successors must be examined, except that no updates are performed.
\end_layout

\begin_layout Standard
Ideally, the SPM algorithm performs succesful lifting attempts only and
 then stops, minimizing the total cost required to arrive at a solution.
 Unfortunately, there is no obvious way to select vertices to achieve this.
 Moreover, after the minimum fixed point has been found, we may have to
 perform additional (failing) lifting attempts just to verify that we have
 indeed found a fixed point.
 Unfortunately, there is no obvious way to select vertices in an optimal
 fashion.
 Therefore, lifting strategies are necessarily heuristical in nature, making
 a best-effort attempt at selecting a sequence of vertices that minimizes
 the cost.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(But can we determine an optimal sequence with hindsight?)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
lifting strategy
\emph default
 is a heuristical algorithm that, depending on the structure of the graph,
 the values of the progress measure vectors and/or the history of vertices
 being lifted, determines which vertex is selected for the next lifting
 attempt.
 Most sensible strategies are 
\emph on
online algorithms
\emph default
 in the sense that they take the success of the previous lifting operation
 into account to determine which vertex to lift next.
 As a result, the strategies are stateful, and although sophisticated lifting
 strategies may cause fewer work to be done in the SPM algorithm itself,
 this comes at the cost of requiring more time and memory spent on keeping
 state for the lifting strategy itself.
 We will present results which quantify this overhead for various possible
 strategies later.
\end_layout

\begin_layout Subsection
Termination conditions
\end_layout

\begin_layout Standard
As has been mentioned, the decision to terminate the algorithm is made by
 the lifting strategy.
 The reason for this is to keep the main algorithm as simple as possible,
 which is useful because the lifting strategy already keeps track of potentially
 unstable vertices.
 A sufficient condition for termination is to verify that there are no 
\emph on
dirty
\emph default
 vertices, where a vertex is considered dirty if:
\end_layout

\begin_layout Enumerate
it was never selected for lifting, or
\end_layout

\begin_layout Enumerate
its last lifting attempt succeeded, or
\end_layout

\begin_layout Enumerate
since its last lifting attempt, one of its successors was succesfully lifted.
\end_layout

\begin_layout Standard
If the lifting strategy is notified whenever a vertex is lifted, it is easy
 to keep track of the set of dirty vertices, but usually lifting strategies
 have enough contextual information to determine when to terminate without
 maintaining additional data.
 This is also the reason this functionality is implemented in the lifting
 strategy rather than the core algorithm, which is oblivious of the implementati
on details of the various lifting strategies.
\end_layout

\begin_layout Subsection
Core Algorithm Implementation
\end_layout

\begin_layout Standard
To implement the Jurdziński's algorithm, we start with an all-zero progress
 measures, and while a vertex can be found that can be lifted, we lift it.
 Jurdziński notes that finding a suitable vertex to lift takes at most 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 time (by considering each vertex in succession).
 In practice we can do better, at least on average, with a suitable lifting
 strategy.
\end_layout

\begin_layout Standard
The small progress measure vectors themselves are stored simply in a contiguous
 array of length 
\begin_inset Formula $\left|V\right|\times\left\lfloor \frac{d}{2}\right\rfloor $
\end_inset

 (where 
\begin_inset Formula $d$
\end_inset

 is one larger than the maximum priority occuring in the game graph), since
 each vector consists of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left\lfloor \frac{d}{2}\right\rfloor $
\end_inset

 components.
\end_layout

\begin_layout Standard
The top-level algorithm can now be describe very succinctly as in Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Small-Progress-Measures"

\end_inset

.
 This algorithm depends entirely on the lifting strategy, both to select
 a vertex to be lifted, and to determine when the solution is completed.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left"
inline false
status open

\begin_layout Plain Layout

solve(LiftingStrategy ls) {
\end_layout

\begin_layout Plain Layout

	while (v = ls.next()) != NO_VERTEX {
\end_layout

\begin_layout Plain Layout

		if lift(vertex) {
\end_layout

\begin_layout Plain Layout

			ls.lifted(vertex)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Small Progress Measures 
\begin_inset CommandInset label
LatexCommand label
name "alg:Small-Progress-Measures"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Lifting to top
\end_layout

\begin_layout Standard
The implemention of 
\begin_inset Formula $\texttt{lift}$
\end_inset

 follows the definition above, but with one important enhancement: whenever
 a vertex with odd priority 
\begin_inset Formula $p$
\end_inset

 is lifted to 
\begin_inset Formula $\top$
\end_inset

, the value of 
\begin_inset Formula $M_{p}$
\end_inset

 is decreased by 1.
 As a result, during solving, 
\begin_inset Formula $M$
\end_inset

 is effectively determined by the cardinalities of only those vertices with
 progress measures less than 
\begin_inset Formula $\top$
\end_inset

.
 Note that this may cause some progress measure vectors to temporarily exceed
 the new vector space 
\begin_inset Formula $M'$
\end_inset

, but this will be resolved when the vertex is lifted.
\end_layout

\begin_layout Standard
To see that decreasing the vector space is permissible, even without fixing
 any vectors that are now out of range, consider that if vertex 
\begin_inset Formula $v$
\end_inset

 with priority 
\begin_inset Formula $p$
\end_inset

 is set to 
\begin_inset Formula $\top$
\end_inset

, then 
\begin_inset Formula $v\in W_{1}$
\end_inset

 and thus 
\begin_inset Formula $Attr^{1}(\left\{ v\right\} )\subseteq W_{1}$
\end_inset

, and we could solve the subgame induced by 
\begin_inset Formula $V\setminus Attr^{1}(\left\{ v\right\} )$
\end_inset

 with vector space 
\begin_inset Formula $M''$
\end_inset

 instead.
 However, since 
\begin_inset Formula $M''_{p}\subseteq M_{p}'$
\end_inset

 and since we compute a minimum fixed point in both cases, the final progress
 measures vectors must be the same for corresponding vertices in both games.
 This guarantees that the final value of all vectors will lie in 
\begin_inset Formula $M''^{\top}$
\end_inset

 in both games, which means any vectors which exceed it in the original
 game cannot be final values, and the corresponding vertices will have to
 be lifted again, at which point they will be brought back in range.
\end_layout

\begin_layout Standard
This enhancement is not described by Jurdziński and not implemented in any
 of the other solvers based on Small Progress Measures, to my knowledge;
 all of these assume 
\begin_inset Formula $M$
\end_inset

 to be constant during solving.
 It was invented specifically to remedy cases where the dual solving approach
 (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Two-way-SPM"

\end_inset

) would perform worse compared to the approach of solving the normal and
 dual game in succession.
 These cases arise because in the latter approach vertices won by Even (in
 the normal game) are removed from the dual game before solving, which reduces
 the complexity of the second problem.
 With the two-way approach no vertices are ever removed, which would cause
 the dual game to have a significantly larger vector space.
\end_layout

\begin_layout Standard
Besides eliminating this disadvantage in the dual-solving approach, the
 enhancement benefits both variations of the algorithm.
\end_layout

\begin_layout Subsection
Graph Preprocessing
\end_layout

\begin_layout Standard
One peculiarity of the Small Progress Measures algorithm is that it may
 spend a lot of time lifting vertices with high priority values which lie
 on a cycle.
 The most typical example of this is a vertex which is controlled by player
 Odd, has a high, odd priority and its only edge is a loop (an edge from
 the vertex back to itself).
 The final progress measure for such a vertex will obviously be 
\begin_inset Formula $\top$
\end_inset

 (since Odd will keep the token at this vertex indefinitely), but its high
 priority ensures that it is only lifted in very small increments.
\end_layout

\begin_layout Standard
Something similar occurs for vertices of odd priority which are controlled
 by Even.
 Although these cannot be initialized to 
\begin_inset Formula $\top$
\end_inset

 (they may still be won by Even) we can and should discard the loop edge,
 to speed up propagation of values from successor vertices through this
 vertex.
\end_layout

\begin_layout Subsubsection
Loop removal
\end_layout

\begin_layout Standard
All known implementations of Small Progress Measures do some form of preprocessi
ng, where such cases are detected and the progress measures of vertices
 won by Odd are set to 
\begin_inset Formula $\top$
\end_inset

 before running the main algorithm.
 Four cases can be distinguished based on the controller and parity of a
 vertex, as summarized in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SPM-preprocessing"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Player
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Priority
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Winner
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loop edge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Other edges
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
undecided
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
undecided
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\top$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Preprocessing of vertices with loops
\begin_inset CommandInset label
LatexCommand label
name "tab:SPM-preprocessing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Note that when a vertex has only one outgoing edge, then it can be considered
 to belong to either player; in this case it's most beneficial to assign
 it to the player corresponding to the parity of its priority.) There are
 different ways to use this information.
 The simplest is to remove some of the vertices and initialize the progress
 measure vector to 
\begin_inset Formula $\top$
\end_inset

 in the fourth case, and solve the rest of the game as usual.
 This is the approach used by the existing solvers.
\end_layout

\begin_layout Standard
It should be noted that in two of the four cases, it is known to which winning
 set the vertex belongs, and the associated strategy is to use the loop
 back to the vertex.
 A simple extension is then to collect sets of these vertices for each player,
 and extend these to their attractor sets, to obtain a larger subset of
 vertices that are completely solved and can be removed from the game entirely.
 The resulting game graph then has no more loops.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: example pictures for the four cases above?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Winner-controlled cycle removal
\end_layout

\begin_layout Standard
In his solver, Freark van der Berg introduced a more sophisticated version
 of the loop removal process described above.
 He searches for cycles of vertices controlled by Odd with odd priority.
 Since he uses a simple depth-limited depth-first-search, he is able to
 find small cycles only.
 Despite this, his benchmark results show that this already provides significant
 benefits over the removal of loops only; at least in some random games.
\end_layout

\begin_layout Standard
His approach can be generalized in several ways.
 First, we would like to find cycles of any size, not just small ones.
 Second, we do not need to limit ourselves to cycles of equal parity: if
 the dominant priority for the cycle matches the controlling player, the
 priorities for the other vertices do not matter.
 To find such cycles, a simple depth-first search no longer suffices.
 Third, as with loop removal, we would like to remove cycles for both players,
 not just for Odd.
 The general process is called 
\emph on
winner controlled cycle removal
\emph default
; i.e.
 removal of all cycles consisting of vertices for which the winner is equal
 to the controlling player.
\end_layout

\begin_layout Standard
To remove all 
\begin_inset Formula $i$
\end_inset

-cycles controlled by player 
\begin_inset Formula $p$
\end_inset

 (where 
\begin_inset Formula $p\equiv i\mod{2})$
\end_inset

 in the graph, an approach similar to that used to verify strategies can
 be applied.
 Construct a subgame induced by the vertices controlled by 
\begin_inset Formula $p$
\end_inset

 (including vertices controlled by 
\begin_inset Formula $1-p$
\end_inset

 with outdegree 1) with priority greater than or equal to 
\begin_inset Formula $i$
\end_inset

.
 Decompose the graph into strongly connected components.
 Vertices with priority 
\begin_inset Formula $i$
\end_inset

 that occur in a connected component with at least one edge (i.e.
 either the component contains two vertices or the vertex has an edge to
 itself) are part of a cycle with dominant priority 
\begin_inset Formula $i$
\end_inset

.
 If we collect one such vertex per component (if one exists) and then compute
 the attractor set for these vertices, we have identified all vertices which
 either lie on an 
\begin_inset Formula $p$
\end_inset

-controlled 
\begin_inset Formula $i$
\end_inset

-cycle or which can be reached from there.
\end_layout

\begin_layout Standard
Strategies for these vertices can be constructed as followes.
 Put the vertices identified as described above in an initial vertex set,
 and then compute the attractor set and associated strategies for these
 vertices in the subgame.
 For the vertices in the initial set, it suffices to select an arbitrary
 successor inside the same component: since it must lie in the attractor
 set (by definition of strongly connected components and the fact that all
 vertices in the subgame are controlled by 
\begin_inset Formula $p$
\end_inset

) play will necessarily lead back to either the 
\begin_inset Formula $i$
\end_inset

-vertex itself (completing a cycle) or to another 
\begin_inset Formula $i$
\end_inset

-vertex that lies on an 
\begin_inset Formula $i$
\end_inset

-cycle.
 Finally, we can compute another attractor set (with strategy) for all vertices
 solved in the subgame, but this time in the global game, to extend the
 winning set as far as possible.
 All of these vertices can be considered solved and removed from the game.
\end_layout

\begin_layout Standard
It may sound inefficient to compute attractor sets twice, but this is required
 in order to create correct strategies.
 Computing only one attractor set (in the global game) does work for purposes
 of computing the winning sets, but it may create cycles containing vertices
 with priority less than 
\begin_inset Formula $i$
\end_inset

, which was to be avoided.
\end_layout

\begin_layout Standard
The process is repeated for every priority in the game.
 Every iteration requires constructing a subgraph with the appropriate vertices,
 decomposing it into strongly connected components, computing the attractor
 set in the subgame, then again in the original game, and finally computing
 a subgame with the remaining vertices.
 Using appropriate data structures, each of these operations takes at most
 time linear in the number of the edges in the graph, for a total runtime
 complexity of 
\begin_inset Formula $O(dE)$
\end_inset

.
 Although this is considerably more than simple preprocessing on vertices
 with loops only, the potential benefits are larger too.
\end_layout

\begin_layout Subsubsection
Priority propagation
\end_layout

\begin_layout Standard
Finally, a simple preprocessing step that can be applied in order to speed
 up solving with Small Progress Measures (and possibly other algorithms
 as well), is a process called 
\emph on
priority propagation
\emph default
 (a term suggested in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

 though the concept already appears in 
\begin_inset CommandInset citation
LatexCommand cite
key "antonik2009polynomial"

\end_inset

): we can replace the priority assigned to a vertex with the largest priority
 among its successors, if the latter is less than the former, without affecting
 winning sets or optimal strategies in the game, and similarly for the predecess
ors of a vertex.
 (Friedmann & Lange distinguish the two cases by calling them 
\emph on
backwards
\emph default
 and 
\emph on
forwards propagation
\emph default
 respectively, though there seems to be little reason to apply one process
 but not the other.)
\end_layout

\begin_layout Standard
This can be seen to be correct by considering that if a play passes through
 a vertex infinitely often, it must also pass through at least one of its
 successors infinitely often.
 When the vertex priority is greater than all of its successors', then it
 cannot be the dominant priority of the play, so it is safe to decrement
 it.
 The same argument applies to predecessors, of course.
\end_layout

\begin_layout Standard
The rationale for applying this transformation is that it tends to shift
 the distribution of priorities towards lower values (since lower values
 can replace higher values, but not the other way around).
 This tends to reduce the size of the vector space for progress measures,
 and thereby potentially decreases the runtime of the Small Progress Measures
 algorithm.
\end_layout

\begin_layout Standard
In practice the gains of priority propagation seem to be small at best,
 as has also been noted by Keiren in 
\begin_inset CommandInset citation
LatexCommand cite
key "keiren2009"

\end_inset

.
 Friedmann & Lange report that 
\begin_inset Quotes eld
\end_inset

emperically, the use of priority propagation turns out to be harmful
\begin_inset Quotes erd
\end_inset

, though their emperical data is not presented.
\end_layout

\begin_layout Subsection
Distributed implementation
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Partition graph, process independently, propagate changes at overlapping
 vertices.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Linear Lifting Strategy
\end_layout

\begin_layout Standard
Arguably the most basic lifting strategy is a strategy that simply picks
 vertices in order of increasing indices, repeating the process as necessary,
 until all vertices in the graph have failed to be lifted in succession.
 Its advantages are that it is simple to implement, requires almost no additiona
l memory, and takes very little time.
 However, the main disadvantage is that it ends up spending a lot of time
 attempting (and failing) to lift vertices in stable parts of the game graph.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Linear-Lifting-Strategy"

\end_inset

 gives pseudo-code for a simple implementation of this algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

num_failed = 0
\end_layout

\begin_layout Plain Layout

next_vertex = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lifted(Vertex v) {
\end_layout

\begin_layout Plain Layout

	num_failed = 0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vertex next() {
\end_layout

\begin_layout Plain Layout

	if num_failed >= V {
\end_layout

\begin_layout Plain Layout

		return NO_VERTEX
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		num_failed = num_failed + 1
\end_layout

\begin_layout Plain Layout

		next_vertex = (next_vertex + 1) mod V
\end_layout

\begin_layout Plain Layout

		return next_vertex
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Linear Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Linear-Lifting-Strategy"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Weber and Van de Pol call this strategy s
\emph on
wiping
\emph default
 instead and it is one of the main strategies implemented in their multi-core
 solver.
\end_layout

\begin_layout Standard
One variation of the strategy is to iterate vertices from back to front.
 This can be beneficial in cases where the graph has been constructed in
 a forward fashion, so that a vertex tends to have a higher index than its
 predecessors.
 Since changes in the graph propagate from vertices to their predecessors,
 iterating in reverse may cause many more vertices to be lifted, the pathologica
l example being a graph which is a simple cycle, with edges 
\begin_inset Formula $E=\{(v,w):\; w\equiv v+1\mod{\left|V\right|}$
\end_inset

.
 Iterating in forward direction might cause only a single succesful lift
 on every pass, while the reverse allows all vertices to be lifted.
\end_layout

\begin_layout Standard
If we expect the edges of the graph to be predominantly oriented one way
 or the other, but we do not know which way in advance, another variation
 would be to alternate the direction of iteration on every pass, avoiding
 the bad case mentioned above.
 Even then we can construct cases which cause a lot of failed lifts, but
 these may arise less frequently in practice.
\end_layout

\begin_layout Standard
In addition to these variations, it is possible to try to reorder vertices
 in the graph at the start, so that the dominant edge direction is optimal
 for the linear lifting strategy.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
mention this as a preprocessing step for SPM
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Predecessor Lifting Strategy
\end_layout

\begin_layout Standard
A more sophisticated lifting strategy takes into account the fact that a
 known-stable vertex can only become unstable after the progress measure
 vector of one of its successors has been updated.
 After all, the value for one vertex depends only on the values for its
 successors.
 The predecessor lifting strategy uses a set datastructure to store potentially
 unstable vertices, which is initialized to all vertices in the graph.
 A vertex is arbitrarily removed from this set to be lifted, and if this
 succeeds, its predecessors are inserted back into the set (if they were
 not yet present).
 All vertices not in the set are necessarily stable, so when the set becomes
 empty, lifting is complete.
\end_layout

\begin_layout Standard
The advantage of this strategy is that it prevents a lot of unnecessary
 lifting that may occur with the linear lifting strategy.
 In fact, the ratio of unsuccesful to succesful lifts is strictly limited
 by the maximum indegree of a vertex in the graph.
 Again, pathological cases can be constructed where this strategy performs
 badly.
 For example, when the game graph is complete (i.e.
 
\begin_inset Formula $E=V\times V$
\end_inset

) all vertices remain in the set until the game is completely solved.
 Fortunately, in practice parity game graphs tend to be sparse, making this
 an unlikely scenario.
\end_layout

\begin_layout Standard
The main disadvantage of the lifting strategy is that it requires maintaining
 the set of unstable vertices, which requires 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 extra memory.
 In my solver, I choose to implement this set with a linear array of boolean
 variables to indicate whether a vertex is in the set, and another array
 which acts as a circular queue of vertices.
 This implementation has the advantage of allowing constant time insertion
 and deletion of vertices in the queue, though the time required to update
 the queue is still linear in the number of predecessors of the last vertex
 lifted.
\end_layout

\begin_layout Standard
Weber and Van de Pol call this the 
\emph on
work list approach
\emph default
, but reject it in their multi-core solver making two objections:
\end_layout

\begin_layout Enumerate
It requires predecessors of vertices to be stored in addition to successors,
 which requires additional memory.
\end_layout

\begin_layout Enumerate
The overhead involved maintaining the set may be too large.
\end_layout

\begin_layout Standard
However, in my experience graphs do not take a prohibitively large amount
 of memory, and the non-blocking primitives required to implement the set
 in a lock-free manner are readily available, and may well have been easier
 to implement than the focus list approach described below.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
So this probably means I should try to implement it instead.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In PGSolver, which is limited to single-threaded operation only, the predecessor
 lifting strategy is the only lifting strategy implemented.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

queued = Vector<bool>(V)
\end_layout

\begin_layout Plain Layout

queue = Queue<Vertex>()
\end_layout

\begin_layout Plain Layout

for 0 <= v < V {
\end_layout

\begin_layout Plain Layout

	queued[v] = true
\end_layout

\begin_layout Plain Layout

	queue.push(v)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lifted(Vertex v) {
\end_layout

\begin_layout Plain Layout

	for w in predecessors(v) {
\end_layout

\begin_layout Plain Layout

		if !queued[w] {
\end_layout

\begin_layout Plain Layout

			queued[w] = true
\end_layout

\begin_layout Plain Layout

			queue.push(w)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vertex next() {
\end_layout

\begin_layout Plain Layout

	if queue.empty() {
\end_layout

\begin_layout Plain Layout

		return NO_VERTEX
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		v = queue.pop()
\end_layout

\begin_layout Plain Layout

		queued[v] = false
\end_layout

\begin_layout Plain Layout

		return v
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Predecessor Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Predecessor-Lifting-Strategy"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The pseudo-code for the predecessor lifting strategy is given in Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Predecessor-Lifting-Strategy"

\end_inset

 which shows that the main datastructure used is a queue.
 Crucial to the implementation is that every vertex is queued at most once,
 which prevents attempted lifting of vertices which are not dirty, and additiona
lly allows the queue to be implemented as a fixed-length array.
 Aan invariant is that at any point precisely those vertices are queued
 which are considered dirty (as described earlier); 
\begin_inset Formula $\texttt{next()}$
\end_inset

 simply returns a dirty vertex until the queue becomes empty, at which point
 all vertices are necessarily stable.
\end_layout

\begin_layout Standard
There is some freedom of implementation when deciding which vertex from
 the set of potentially unstable vertices to lift next.
 The maximum measure lifting strategy (described later) uses the current
 progress measures vectors to select a vertex.
 My implementation uses no external information, but can be configured to
 extract vertices from the queue in a first in, first out (FIFO) or last
 in, last out (LIFO) manner, in which case the queue works like a stack.
 Additionally, the vertices can initially be inserted in forward or in reverse
 order, for similar reasons as the linear lifting strategy can change directions.
 This gives a total of four different variations, which perform differently
 depending on the test case.
 Extracting vertices in LIFO order may have the benefit of providing better
 cache locality, even when it doesn't reduce the number of lifts.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
but I have no practical results that show this clearly
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Focus List Approach
\end_layout

\begin_layout Standard
The 
\emph on
focus list approach
\emph default
 is a strategy designed by Weber and van de Pol in order to avoid the disadvanta
ges of the linear lifting strategy (mainly that it performs a lot of unnecessary
 failed lifting attempts) without introducing complicated data structures.
 Solving occurs by alternation of two phases of operation.
\end_layout

\begin_layout Standard
First, the algorithm iterates linearly over the vertices of the graph, putting
 vertices which are succesfully lifted on a fixed-size work list.
 When the work list is full, the second phase begins: vertices on the work
 list are assigned an initial credit value and are selected for lifting
 again.
 When lifting a vertex succeeds, its credit is incremented linearly (adding
 a constant); if it fails, it is decreased exponentially (dividing by a
 constant).
 A vertex whose credit drops below a certain threshold is removed from the
 work list.
 When the work list is empty or a predetermined amount of lifting attempts
 have been performed, the work list is cleared and the first phase is resumed.
\end_layout

\begin_layout Standard
The idea behind the work list is that it captures unstable parts of the
 graph.
 When processing the work list, either lifting attempts will have a high
 success rate, or the list will be cleared quickly, allowing new vertices
 to be selected.
 Limiting the number of attempts at this time ensures that if little progress
 is made in one part of the game (i.e.
 despite high lifting success rate, vertices do not stabilize) work will
 soon continue on some other part of the game.
\end_layout

\begin_layout Standard
Since Weber and van de Pol are the only ones to implement this strategy,
 there is little emperical evidence available about its performance, though
 it seems to perform much better than linear lifting in some cases, and
 not much worse in most other cases, which suggests it meets its design
 goals.
 Compared to the predecessor lifting strategy, it has the advantage of being
 able to postpone difficult parts of the game, which may help in some hard
 cases.
\end_layout

\begin_layout Standard
The main downside of the strategy is that it depends on various constants
 (work list size, initial credit, credit increment, credit divisor) to work
 well.
 In Weber's implementation these are emperically derived while testing on
 random games, but it is unclear if and how these values should change for
 other types of games.
\end_layout

\begin_layout Standard
The implementation of the focus list lifting strategy is described in Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Focus-List-Lifting"

\end_inset

.
 For clarity, the algorithm is presented as if the strategy calls the 
\begin_inset Formula $\texttt{lift()}$
\end_inset

 method directly, instead of being called from the core algorithm; this
 is the inverse of how the strategy is implemented in reality.
 (The interaction between the core algorithm and the lifting strategy would
 best be implemented as a pair of coroutines, but unfortunately few programming
 languages support coroutines properly.)
\end_layout

\begin_layout Standard
Some of the parameters in this algorithm are fixed: the initial credit (here:
 2) assigned to vertices on the focus list; the linear increment when lifting
 succeeds (again, 2); and the exponential decay when it doesn't (here: 
\begin_inset Formula $\frac{1}{2}$
\end_inset

).
 With these parameters, which were taken from Weber & van de Pol's implementatio
n, a vertex is selected for lifting at least three times, but will stay
 on the focus list longer if lifting succeeds occassionally (more precesily,
 it needs to be succesfully lifted at least once every three attempts to
 stay on the list).
 The remaining two parameters are 
\begin_inset Formula $\texttt{max\_size}$
\end_inset

 and 
\begin_inset Formula $\texttt{max\_attempts}$
\end_inset

; the maximum size of the focus list and the maximum number of lifting attempts
 performed in phase 2 before switching back to phase 1.
 These parameters can vary, but are chosen as 
\begin_inset Formula $\frac{\left|V\right|}{10}$
\end_inset

 and 
\begin_inset Formula $\left|V\right|$
\end_inset

 (respectively) by default.
\end_layout

\begin_layout Standard
In terms of overhead, the focus list implements a circular buffer with an
 array of vertex/cost pairs.
 The size of this array is equal to 
\begin_inset Formula $\texttt{max\_size}$
\end_inset

 and this is the main factor in the memory used by the strategy.
 Otherwise, the focus list lifting strategy has little overhead.
 In particular, the runtime overhead is smaller than with the predecessor
 lifting strategy.
 When the focus list is small, the algorithm additionally benefits from
 being able to keep the active parts of the game in cache memory.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

phase = 1
\end_layout

\begin_layout Plain Layout

num_attempts = 0
\end_layout

\begin_layout Plain Layout

num_failed = 0
\end_layout

\begin_layout Plain Layout

next_vertex = 0
\end_layout

\begin_layout Plain Layout

focus_list = Queue<Pair<Vertex, Int> >
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while true {
\end_layout

\begin_layout Plain Layout

	num_attempts = num_attempts + 1
\end_layout

\begin_layout Plain Layout

	if (phase == 1) {
\end_layout

\begin_layout Plain Layout

		if lift(next_vertex) {
\end_layout

\begin_layout Plain Layout

			num_failed = 0
\end_layout

\begin_layout Plain Layout

			focus_list.push(<next_vertex, 2>)
\end_layout

\begin_layout Plain Layout

		} else {
\end_layout

\begin_layout Plain Layout

			num_failed = num_failed + 1
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		next_vertex = (next_vertex + 1) mod V
\end_layout

\begin_layout Plain Layout

		if num_failed == V {
\end_layout

\begin_layout Plain Layout

			break
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if num_attempts == V || focus_list.size() == max_size {
\end_layout

\begin_layout Plain Layout

			/* N.B.
 focus_list is non-empty because
\end_layout

\begin_layout Plain Layout

			        num_failed < num_attempts */
\end_layout

\begin_layout Plain Layout

			phase = 2
\end_layout

\begin_layout Plain Layout

			num_attempts = 0
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	} else {  /* phase == 2 */
\end_layout

\begin_layout Plain Layout

		v, credit = focus_list.pop()
\end_layout

\begin_layout Plain Layout

		if lift(v) {
\end_layout

\begin_layout Plain Layout

			focus_list.push(<v, credit + 2>)
\end_layout

\begin_layout Plain Layout

		} else if (credit > 0) {
\end_layout

\begin_layout Plain Layout

			focus_list.push(<v, credit / 2>)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if focus_list.empty() || num_attempts == max_attempts {
\end_layout

\begin_layout Plain Layout

			focus_list.clear()
\end_layout

\begin_layout Plain Layout

			phase = 1
\end_layout

\begin_layout Plain Layout

			num_attempts = 0
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Focus List Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Focus-List-Lifting"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Maximum-Measure Propagation
\end_layout

\begin_layout Standard
The maximum-measure propagation strategy is a variant of the predecessor
 lifting strategy that at each iteration attempts to lift a vertex with
 a successor that has a maximal progress measure vector assigned to it.
 The rationale behind this strategy is the observation that since we increase
 the progress measure vector for at most one vertex every iteration, and
 since the final progress measure for this vertex does not depend on the
 order of lifting, then in order to perform as few (succesful) lifts as
 possible, it makes sense to try to lift vertices with the largest increments
 possible.
\end_layout

\begin_layout Standard
Pathological examples can be constructed in which this order of lifting
 provides obvious benefit.
 Specifically, whenever a vertex is known to be won by player Odd (when
 it is assigned 
\begin_inset Formula $\top$
\end_inset

) all vertices in its attractor set will be set to top too, before any other
 vertices are lifted, since 
\begin_inset Formula $\top$
\end_inset

 is the maximal value in the graph.
 With the normal predecessor lifting strategy, these vertices might have
 been lifted multiple times before inevitably finally reaching top value.
\end_layout

\begin_layout Standard
In practice, maximum-measure propagation is not always strictly better than
 the general simple predecessor lifting strategy described above, as will
 be shown later.
 However, in many cases it does cause fewer (succesful as well as total)
 lifting attempts.
 Its main disadvantage lies in the considerable amount of overhead in the
 implementation of the strategy itself.
 In order to keep track of vertices with high progress measures, it is necessary
 to implement some sort of priority queue structure.
 Additionally, it must be possible to move queued vertices in the queue
 when the value for their successor changes.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

queued = Vector<bool>(V)
\end_layout

\begin_layout Plain Layout

queue = BinaryHeap<Vertex>()
\end_layout

\begin_layout Plain Layout

for 0 <= v < V {
\end_layout

\begin_layout Plain Layout

	queued[v] = true
\end_layout

\begin_layout Plain Layout

	queue.push(v)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lifted(Vertex v) {
\end_layout

\begin_layout Plain Layout

	queued_predecessors = false
\end_layout

\begin_layout Plain Layout

	for u in predecessors(v) {
\end_layout

\begin_layout Plain Layout

		if !is_top(spm[u]) {
\end_layout

\begin_layout Plain Layout

			queued[u] = true
\end_layout

\begin_layout Plain Layout

			queued_predecessors = true
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	if queued_predecessors {
\end_layout

\begin_layout Plain Layout

		queue.push(v)
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		queue.pop(v)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vertex next() {
\end_layout

\begin_layout Plain Layout

	while not queue.empty() {
\end_layout

\begin_layout Plain Layout

		v = queue.top()
\end_layout

\begin_layout Plain Layout

		for u in predecessors(v) {
\end_layout

\begin_layout Plain Layout

			if queued[u] {
\end_layout

\begin_layout Plain Layout

				queued[u] = false
\end_layout

\begin_layout Plain Layout

				return u
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		queue.pop(v)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return NO_VERTEX
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Maximum Measure Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Maximum-Measure-Lifting"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An outline of the implementation is given in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Maximum-Measure-Lifting"

\end_inset

.
 The successors of queued vertices (not the vertices themselves) are kept
 in a complete binary heap structure, ordered by their progress measure
 vectors, so that the vertex with the largest progress measure vector is
 at the top of the heap.
 The heap is stored in a vertex array of size 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 In order to be able to move vertices up in the heap whenever they are lifted,
 another array of size 
\begin_inset Formula $\left|V\right|$
\end_inset

 keeps track of the position of vertices in the heap.
 (Since progress measure vectors are only ever increased, never decreased,
 moving down is not necessary).
 Finally, for each predecessor in the heap the 
\begin_inset Formula $\texttt{queued}$
\end_inset

 array keeps track of whether it is queued.
 Whenever a vertex is succesfully lifted, all of its predecessors that have
 not yet been assigned top value are marked as queued.
 If there are any, then the vertex itself is inserted into the heap or moved
 up from its current position if it is already present.
 If there are none, then the successor vertex is removed (at this point,
 the vertex was on top of the heap).
 It should be noted that the 
\begin_inset Formula $\texttt{push()}$
\end_inset

 operation either inserts the vertex into the queue (if it did not exists)
 or raises it (if it did exist, but its progress measure vector has changed)
 but does not insert a vertex twice.
 Similarly, 
\begin_inset Formula $\texttt{pop()}$
\end_inset

only removes the vertex if it exists.
\end_layout

\begin_layout Standard
One might ask why it is necessary to store successors rather than the vertices
 themselves in the heap.
 The reason is that we want to keep vertices ordered not by their own progress
 measure vector, but by the maximum of their successors.
 If we would store vertices directly, then when one vertex is lifted, this
 could cause multiple of its predecessors in the heap to violate the ordering
 in the heap.
 This is hard to fix efficiently.
 However, if we store the successor only, then after each lifting, at most
 one vertex (the one just lifted) can violate the heap property and this
 can be resolved easily by moving the vertex up in the heap if necessary.
\end_layout

\begin_layout Standard
Now, to select the next vertex to be lifted, the highest vertex in the heap
 is consulted, and if any of its predecessors are still marked as queued,
 it is returned.
 If there are no predecessors to be lifted, the vertex is removed from the
 heap, and we repeat the process.
 When the heap is empty, no more vertices are queued and the solution is
 complete.
 Note that for each vertex, on average, we insert one vertex in the heap,
 remove one vertex on the heap, and look up a number of vertices equal to
 half of the in-degree of vertices in the graph.
 Insertion and removal in a binary heap takes at most 
\begin_inset Formula $O(\log\left|V\right|)$
\end_inset

 time.
 Since we assume the game graph to be sparse, this is also the average overhead
 per 
\emph on
succesful
\emph default
 lift for this strategy.
 Although this overhead is still small, it is considerably more than the
 
\begin_inset Formula $O(1)$
\end_inset

 overhead of data structures described previously.
 Like the predecessor lifting strategy, the memory overhead is limited to
 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

, though with a larger constant factor.
\end_layout

\begin_layout Standard
As with the predecessor lifting strategies, the 
\begin_inset Formula $\texttt{queued}$
\end_inset

 array corresponds with the set of dirty vertices.
 Since a vertex is only marked as queued when one of its successors is added
 to the heap, and a vertex is not removed from the heap until none of its
 predecessors are marked as queued, it follows that if the heap is empty,
 the dirty set is as well, and in this case the global algorithm terminates.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- Worst cases, if different from predecessor lifting?
\end_layout

\begin_layout Plain Layout
- Note that biggest-steps algorithm is possible too! (How?)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Two-way SPM 
\begin_inset CommandInset label
LatexCommand label
name "sub:Two-way-SPM"

\end_inset


\end_layout

\begin_layout Standard
A noteworthy variant of the Small Progress Measures algorithm was implemented
 by Oliver Friedmann in PGSolver.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add citation or mention that this variant is unpublished.
\end_layout

\end_inset

 In this case, the algorithm is not run for one player at a time, but for
 both players at once.
 In Friedmann's implementation this means that a single vertex is selected,
 and it is lifted both in the normal game and its dual, and if either lift
 succeeds, the predecessor vertices are queued.
 Effectively, the queue is shared between the two games.
 Conceivably, the two games could be processed independently, even in parallel
 on separate machines.
\end_layout

\begin_layout Standard
Periodically (in the current implementation after every 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifting attempts) information about winning vertices is exchanged between
 the games, by conservatively identifying vertices in one game that are
 won by the player for which we are computing the strategy, and setting
 the progress measures of these vertices to 
\begin_inset Formula $\top$
\end_inset

 in the corresponding dual game being solved for its opponent.
 These vertices are identified as follows.
\end_layout

\begin_layout Standard
Without loss of generality, assume we are computing the strategy for player
 Even.
 Then, we add a mark to every vertex for which any of the following conditions
 apply:
\end_layout

\begin_layout Enumerate
Its progress measure is 
\begin_inset Formula $\top$
\end_inset


\end_layout

\begin_layout Enumerate
The vertex is controlled by Even and either:
\end_layout

\begin_deeper
\begin_layout Enumerate
all of its successors are marked; or
\end_layout

\begin_layout Enumerate
its progress measure is less than (or equal to, if the vertex priority is
 odd) all of its unmarked successors
\end_layout

\end_deeper
\begin_layout Enumerate
The vertex is controlled by Odd and either:
\end_layout

\begin_deeper
\begin_layout Enumerate
one of its successors is marked; or
\end_layout

\begin_layout Enumerate
its progress measure is less than (or equal to, if the vertex priority is
 odd) one of its successors
\end_layout

\end_deeper
\begin_layout Standard
Here, 
\begin_inset Quotes eld
\end_inset

less
\begin_inset Quotes erd
\end_inset

 means less with respect to the priority of the current vertex.
 Note that these conditions are consistent with the usual criteria when
 vertices can be lifted, where the marked vertices are considered to be
 set to top.
 The interpretation of the marks is that marked vertices may be won by Odd,
 and unmarked vertices are known to be won by Even.
 The unmarked vertices therefore are a subset of the winning set of Even,
 and the corresponding vertices in the dual game solved for Odd can be set
 
\begin_inset Formula $\top$
\end_inset

.
 The same process can, of course, be applied for Odd in the dual game to
 get vertices which should be set to 
\begin_inset Formula $\top$
\end_inset

 in the main game.
\end_layout

\begin_layout Standard
To compute a maximal set of marked vertices, a similar approach as in the
 main SPM algorithm is used: all vertices are queued, checked against the
 properties mentioned above, and whenever a mark is add to a vertex, its
 predecessors must be re-examined, so they are queued again.
 The difference with the main SPM algorithm is that a mark can be added
 only once, which bounds the total processing time to the number of edges
 in the graph.
\end_layout

\begin_layout Standard
If we assume that we tend to examine vertices with average outdegree then
 the main algorithm examines about 
\begin_inset Formula $\left|E\right|$
\end_inset

 vertices before updating the progress measures for both players, which
 ensures the time required to solve a game increases at worst by a constant
 factor (about two or three, presumably).
 Additionally, the algorithm requires up to twice as much memory, because
 progress measures for both players must be kept.
\end_layout

\begin_layout Subsubsection
Advantages & Disadvantages
\end_layout

\begin_layout Standard
In practice, a game and its dual are often not of the same difficulty.
 In that case, it makes sense to try to solve them both, in order to discover
 the solution to the easiest one, and then use the information gained to
 construct a subgame with the remaining unsolved vertices in the dual game,
 which is then usually much easier to solve.
 The extra amount of work done in this case is at most equal to the amount
 of work done for the easiest game, but with the benefit that we do not
 have to know or guess in advance which of two players is easier to solve
 for.
 The worst case occurs when a game and its dual are of comparable difficulty;
 in that case up to twice as much work may be done when solving in parallel
 rather than sequentially.
\end_layout

\begin_layout Standard
Friedmann's two-sided approach has as the benefit that this approach is
 not applied just on the game level, but also on parts of the games, which
 is beneficial in cases where games contain different parts which are hard
 to solve for different players.
 In those cases, the two-sided approach can result in both sides being solved
 in less time than would be possible starting from either side.
\end_layout

\begin_layout Standard
Unfortunately, the implementation in PGSolver is flawed.
 It foregoes construction of the subgame entirely, even after one of the
 sides is completely solved.
 When a subgame is constructed this reduces the size of the progress measure
 vector space, which can significantly reduce the solving time for a game.
 Therefore, PGSolver suffers from regressions where some games require orders
 of magnitudes more lifting attempts to be performed compared to the original
 approach, rather than being bound by a factor two as expected.
 A simple solution would be to reset the unsolved game to the appropriate
 subgame after its easier dual is solved, but then some of the work done
 is lost.
 I have implemented a different way to address this issue, as will be described
 later.
\end_layout

\begin_layout Standard
Finally, a limitation of the implementation in PGSolver is that it always
 attempts to lift the same vertex in both the normal and dual game.
 There does not seem to be a particular reason to restrict lifting attempts
 in this way.
 On the contrary, it seems plausible that the sets of liftable vertices
 in the normal and dual game will diverge, so it seems more natural to apply
 separate lifting strategies to both games, especially since there seems
 to be little to be gained by synchronizing the vertices selected for lifting,
 except some memory savings (from maintaining one lifting strategy instance
 instead of two) and some cache benefits (when progress measure vectors
 for two games are stored interleaved as is the case in PGSolver).
\end_layout

\begin_layout Subsubsection
Implementation
\end_layout

\begin_layout Standard
My solver tool implements Friedmann's variation of Small Progress Measures
 with three changes which are intended to mitigate the disadvantages outlined
 above.
\end_layout

\begin_layout Enumerate
Whenever a vertex is lifted to 
\begin_inset Formula $\top$
\end_inset

, the vector space bounds are adjusted as if the vertex had been removed
 from the game.
 This means for example that if we are solving for Even and a vertex with
 priority 1 is lifted to 
\begin_inset Formula $\top$
\end_inset

, then the first dimension of the vector space is reduced by one.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
mention that this means existing vectors may temporarily contain values
 that exceed bounds!
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Separate lifting strategies are created for the two games, to increase the
 probability of succesful lifting.
\end_layout

\begin_layout Enumerate
Instead of attempting 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifts in both games and then exchanging information between the two games,
 my implementation attempts 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifts in one game, propagates information to the dual game, and then switches
 to that game.
 This is possible because lifting strategies for the two games are independent,
 and ensures that information is exchanged earlier (after every 
\begin_inset Formula $\left|V\right|$
\end_inset

 rather than 
\begin_inset Formula $2\left|V\right|$
\end_inset

 lifting attempts).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
#1 probably needs a proof that it does not change the correctness of the
 algorithm? (also note that #1 helps also for the normal algorithm)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- cite parallel implementation by Michael
\end_layout

\begin_layout Plain Layout
- cite parallel implementaiton on PS3 [mention/cite Jorne Kandziora, Freark
 van den Berg]
\end_layout

\begin_layout Plain Layout
- note that solving time for the two players is usually highly asymmetric,
 which is why the dual method works well, and why it makes sense to try
 to pick the easiest player to solve for first, as the second run will be
 on a smaller graph and then run much faster.
 (this doesn't seem to be true so much anymore, since I implemented reducing
 the bounds when lifting to top)
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Zielonka's Recursive Algorithm
\end_layout

\begin_layout Standard
An entirely different approach to solving parity games arises from a constructiv
e proof of the existince of memoryless strategies by Wiesław Zielonka in
 
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset

.
 It is presented solely as a proof, not as an efficient algorithm, but it
 has been shown (e.g.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

and in 
\begin_inset CommandInset citation
LatexCommand cite
key "keiren2009"

\end_inset

) to work well as an actual solver too.
\end_layout

\begin_layout Standard
The algorithm is based on a proof by induction on the number of different
 priorities: when there is a single priority, the game is trivially solved
 (this is the basis for the induction).
 Then, assuming that we can solve any game with 
\begin_inset Formula $d$
\end_inset

 priorities, we can solve any game with 
\begin_inset Formula $d+1$
\end_inset

 priorities as follows.
\end_layout

\begin_layout Standard
Without loss of generality (using priority compression if necessary) suppose
 we start with a game 
\begin_inset Formula $\Gamma$
\end_inset

 in wich some vertices have priority 0.
 Then, we can compute the attractor set of these vertices for player Even
 (
\begin_inset Formula $U=Attr^{0}(\Gamma,\{v:\,\phi(v)=0\}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 and its complement 
\begin_inset Formula $V'$
\end_inset

 (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V'=V\setminus U)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 and call the induced subgame
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\Gamma'$
\end_inset

 (
\begin_inset Formula $\Gamma'=\Gamma|V'$
\end_inset

).
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
Since there are no vertices with priority 
\begin_inset Formula $0$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

'
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 left, it has at most 
\begin_inset Formula $d$
\end_inset

 different priorities and
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 we can invoke the induction hypothesis to solve 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\Gamma'$
\end_inset

, yielding winning sets 
\begin_inset Formula $W'_{0}$
\end_inset

 and 
\begin_inset Formula $W'_{1}$
\end_inset

 and associated strategies.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
At this point, we know that 
\begin_inset Formula $W'_{1}\subseteq W_{1}$
\end_inset

 because 
\begin_inset Formula $V'$
\end_inset

 is a trap for Even in 
\begin_inset Formula $\Gamma$
\end_inset

 and therefore any strategy which works for Odd in 
\begin_inset Formula $\Gamma'$
\end_inset

 is winning in 
\begin_inset Formula $\Gamma$
\end_inset

 too.
 The same does not apply to 
\begin_inset Formula $W_{0}$
\end_inset

, because it is possible that Odd can escape from 
\begin_inset Formula $W_{0}$
\end_inset

 into 
\begin_inset Formula $U$
\end_inset

 as 
\begin_inset Formula $V'$
\end_inset

 is not a trap for Odd.
 Let 
\begin_inset Formula $U'=Attr^{1}(\Gamma,W'_{1})$
\end_inset

 then since 
\begin_inset Formula $V\setminus U'$
\end_inset

 is a trap for Odd, we can solve the subgame 
\begin_inset Formula $\Gamma|(V\setminus U')$
\end_inset

 independently to determine the remainder of the winning sets.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: picture!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We thus repeat the process to solve increasingly smaller subgames, until
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
either 
\begin_inset Formula $U=\emptyset$
\end_inset

 (i.e.
 no vertices with priority 0 remain and we we can invoke the induction hypothesi
s to solve it) or 
\begin_inset Formula $U'=\emptyset$
\end_inset

 (i.e.
 all remaining vertices are won by Even).
 Winning strategies can be constructed along the way by combing the strategies
 obtained recursively with those found by computing attractor sets.
\end_layout

\begin_layout Standard
From the above, it is clear that to solve a game with 
\begin_inset Formula $d$
\end_inset

 priorities, we must recursively call the solver at most 
\begin_inset Formula $V$
\end_inset

 times for a worst-case runtime of 
\begin_inset Formula $O(V^{d})$
\end_inset

.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann-recursive-lower-bound"

\end_inset

, Friedmann presents a class of games requiring exponential time to solve,
 with 
\begin_inset Formula $\Omega(fib(V))$
\end_inset

 as a lower bound (where 
\begin_inset Formula $fib(i)$
\end_inset

 returns the 
\begin_inset Formula $i$
\end_inset

-th Fibonacci number).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO:
\end_layout

\begin_layout Plain Layout
- note that McNaughton proposed something similar (when/where?)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The actual algorithm implementation varies a little from the proof structure
 for practical reasons.
 For one thing, the implementation is restricted to finite graphs.
 The inductive proof lends itself to being implemented recursively, but
 a straightforward recursive formulation is undesirable here, because deep
 recursion on a large game may overflow the runtime stack.
 Instead, the implementation is iterative and recurses only when computing
 subgames with fewer priorities, bounding the maximum recursion depth by
 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
Additionally, instead of solving one priority at a time, we will speed up
 the solving process by always looking for the next inversion of parity
 in the game.
 Let an inversion of parity be a priority 
\begin_inset Formula $p$
\end_inset

 such that there is a priority 
\begin_inset Formula $n<p$
\end_inset

 with 
\begin_inset Formula $n\not\equiv p\mod{2}$
\end_inset

 and there are some vertices with priority 
\begin_inset Formula $n$
\end_inset

, some vertices with priority 
\begin_inset Formula $p$
\end_inset

, but no vertices with priority 
\begin_inset Formula $o$
\end_inset

 for any 
\begin_inset Formula $n<o<p$
\end_inset

.
 The number of inversions of parity in the initial game is a limit on the
 recursion depth, but typically (after priority compression) this is equal
 to 
\begin_inset Formula $d$
\end_inset

.
 However, for smaller subgames, the number of inversions may be much lower,
 as not all priority values are necessarily used.
 Specifically, if there are no inversions of parity, then all priorities
 assigned to vertices have the same parity, and the corresponding player
 trivially wins the entire game.
\end_layout

\begin_layout Standard
Otherwise, all vertices with priority less than 
\begin_inset Formula $p$
\end_inset

 (or, equivalently, less than or equal to 
\begin_inset Formula $n$
\end_inset

) can be compressed into a single value.
 In the implementation, this is done implicitly by adding all of these vertices
 to the minimum-priority attractor set (though the game itself is unchanged).
\end_layout

\begin_layout Standard
The recursive algorithm is presented in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Zielonka's-Recursive-Algorithm"

\end_inset

.
 Recall that Strategy is maps vertices to successor vertices (where the
 value 
\begin_inset Formula $\texttt{NO\_VERTEX}$
\end_inset

 is used to indicate that a vertex is not in the controller's winning set).
 This requires that subgame construction preserves vertex indices, at least
 conceptually.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

solve(ParityGame game, Strategy strategy)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Priority p = least_inversion(game)
\end_layout

\begin_layout Plain Layout

	while p < game.d {
\end_layout

\begin_layout Plain Layout

		Set<Vertex> min_prio = { v in game.graph.V
\end_layout

\begin_layout Plain Layout

			where game.priority(v) < p }
\end_layout

\begin_layout Plain Layout

		Set<Vertex> min_prio_attr =
\end_layout

\begin_layout Plain Layout

			make_attractor_set(min_prio, (p-1) mod 2, strategy)
\end_layout

\begin_layout Plain Layout

		Set<Vertex> unsolved =
\end_layout

\begin_layout Plain Layout

			game.graph.get_complement(min_prio_attr)
\end_layout

\begin_layout Plain Layout

		if |unsolved| == 0 { break }
\end_layout

\begin_layout Plain Layout

		ParityGame subgame = game.make_subgame(unsolved)
\end_layout

\begin_layout Plain Layout

		solve(subgame, strategy)
\end_layout

\begin_layout Plain Layout

		Set<Vertex> lost = { v in subgame.graph.V
\end_layout

\begin_layout Plain Layout

			where strategy.winner(v) == p mod 2 }
\end_layout

\begin_layout Plain Layout

		if |lost| == 0 { break }
\end_layout

\begin_layout Plain Layout

		Set<Vertex> lost_attr = 
\end_layout

\begin_layout Plain Layout

			make_attractor_set(lost, p mod 2, strategy)
\end_layout

\begin_layout Plain Layout

		Set<Vertex> remaining =
\end_layout

\begin_layout Plain Layout

			game.graph.get_complement(lost_attr)
\end_layout

\begin_layout Plain Layout

		game = game.make_subgame(remaining)
\end_layout

\begin_layout Plain Layout

		p = least_inversion(game)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for v in game.graph.V {
\end_layout

\begin_layout Plain Layout

		if game.priority(v) < p {
\end_layout

\begin_layout Plain Layout

			if game.player(v) == game.priority(v) mod 2 {
\end_layout

\begin_layout Plain Layout

				strategy[v] = any successor of v
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				strategy[v] = NO_VERTEX
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zielonka's Recursive Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Zielonka's-Recursive-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The solver function itself takes an initial parity game and a strategy array;
 the initial contents of the array are irrelevant, but after completion,
 the strategy will be filled in with the optimal strategy for both players,
 but only for the vertices in the initial game graph.
 Note that the strategy is passed by reference: all invocations of 
\begin_inset Formula $\texttt{solve}$
\end_inset

 share the same array, and entries in the array are updated at different
 invocations, and sometimes overwritten.
 It remains to be shown that the when 
\begin_inset Formula $\texttt{solve}$
\end_inset

 terminates, a complete strategy for both players has been computed.
\end_layout

\begin_layout Standard
The execution of the main algorithm depends on several, simpler helper functions
:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{least\_inversion}$
\end_inset

 returns the least inversion in the game, as described above, by analyzing
 the cardinality of priorities in use.
 If there is no inversion, the game degree 
\begin_inset Formula $\texttt{d}$
\end_inset

 is returned instead.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{make\_attractor\_set}$
\end_inset

 takes a vertex set and extends it to its attractor set with respect to
 the given player, as described earlier.
 For all vertices that are added to the set (but not those in initial set)
 the accompanying strategy is also assigned, so that play according to the
 strategy leads to the vertices in the initial set.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{get\_complement}$
\end_inset

 returns the complement of a given vertex set, with respect to the vertex
 set of a graph.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{make\_subgame}$
\end_inset

 constructs the subgame induced by the given vertex set.
 Since in Zielonka's algorithm subgames are constructed from the complement
 of an attractor set, this always results in a proper game.
 (For purposes of the algorithm outlined above, it is assumed that vertex
 identifiers are preserved, so that assignments to the global strategy array
 are consistent with the global game.)
\end_layout

\begin_layout Standard
From a high-level point of view, the algorithm operates by first assuming
 that all vertices in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\texttt{min\_prio\_attr}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 are won by the corresponding player and then recursively solving the rest
 of the game.
 If the rest of the game is won by the same player, the procedure is complete;
 otherwise, the opponent has a non-empty winning set, and can win from any
 vertices in its attractor set as well.
 This attractor set is removed from the game, and the procedure is repeated
 with the remainder, until it becomes empty or entirely won by one player.
\end_layout

\begin_layout Subsection
Strategy computation
\end_layout

\begin_layout Standard
The strategy for vertices in 
\begin_inset Formula $\texttt{min\_prio\_attr}\setminus\texttt{min\_prio}$
\end_inset

 is assigned during attractor set computation.
 The strategy for vertices in its complement are assigned by the recursive
 invocation of 
\begin_inset Formula $\texttt{solve}$
\end_inset

.
 The strategy for vertices in the attractor set of vertices lost to the
 opponent are overwritten by the next attractor set computation; this part
 of the strategy is then final, and the vertices in this set are removed
 from the graph.
\end_layout

\begin_layout Standard
The while-loop exits in three cases: when the game has no more inversions,
 when the attractor set of the minimum priority vertices covers the entire
 game graph, or when the vertices outside this attractor set are all won
 by the player corresponding to the minimum priority vertices.
 In all of these cases, the remaining game has no inversions (i.e.
 it is a single-parity game).
 At this point, the only vertices for which the strategy has not been assigned,
 are those with priority less than 
\begin_inset Formula $\texttt{p}$
\end_inset

.
 For those, it suffices to pick an arbitrary successor in the remaining
 part of the game (which is done in the for-loop at the end) to complete
 the strategy.
\end_layout

\begin_layout Subsection
Termination
\end_layout

\begin_layout Standard
In this algorithm every recursive invocation removes at least one inversion
 from the game (when 
\begin_inset Formula $\texttt{solve}$
\end_inset

 is called recursively, all vertices with priority less than 
\begin_inset Formula $\texttt{p}$
\end_inset

 are removed, so 
\begin_inset Formula $\texttt{p}$
\end_inset

 is not an inversion in the subgame) so the number of inversions in the
 initial game is an upper bound on the recursion depth.
 Further more, every complete iteration of the while loop removes at least
 two vertices from the game (one in 
\begin_inset Formula $\texttt{lost}$
\end_inset

 and another in its attractor set, overlapping 
\begin_inset Formula $\texttt{min\_prio\_attr}$
\end_inset

) until the game is empty or completely solved, so the maximum number of
 iterations in the while loop is 
\begin_inset Formula $\frac{\left|V\right|}{2}$
\end_inset

.
 Combined, these observations guarantee the algorithm terminates.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- real worst case is probably smaller than 
\begin_inset Formula $\left(\frac{\left|V\right|}{2}\right)^{d}$
\end_inset

; need to figure out how small, and if possible construct a worst-case example.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parallelization
\end_layout

\begin_layout Standard
Zielonka's recursive algorithm is entirely deterministic, in the sense that
 the subgames that must be computed to arrive at an answer are fixed, and
 they can only be computed in a fixed order.
 This is very different from Small Progress Meaures, where individual lifting
 operations can be performed in any order, and can even be performed independent
ly in parallel, without affecting the final outcome of the algorithm.
\end_layout

\begin_layout Standard
This property of Zielonka's algorithm can be seen clearly in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Zielonka's-Recursive-Algorithm"

\end_inset

: every statement in the while-loop depends directly on the result obtained
 in the immediately preceding statement.
 As a result, it is impossible to reorder any statements, let alone evaluate
 different statements in parallel, which suggests that the algorithm cannot
 be parallelized at this level; at least, not without reformulating the
 algorithm.
\end_layout

\begin_layout Standard
Fortunately, parallelizing the algorithm at the top level is not the only
 possible approach.
 Although the algorithm is highly determinstic in its execution, the operations
 that are performed are relatively high-level and computationally expensive.
 Again, in this regard the algorithm differs from Small Progress Measures,
 where the basic operation (a lifting attempt) is so simple that it makes
 little sense to try and parallelize it, for the synchronization overhead
 would likely negate the speedup gained by parallelization.
\end_layout

\begin_layout Subsubsection
Distributed computation
\end_layout

\begin_layout Standard
My approach to parallelizing Zielonka's algorithm is therefore based on
 attempting to parallize the basic high-level operations on which the algorithm'
s execution is based: 
\begin_inset Formula $\texttt{make\_attractor\_set}$
\end_inset

, 
\begin_inset Formula $\texttt{get\_complement}$
\end_inset

, 
\begin_inset Formula $\texttt{make\_subgame}$
\end_inset

 and the construction of vertex sets in the while-loop, and the construction
 of a final strategy in the for-loop at the end.
 To this end, the initial game graph is partitioned over all available processes
 by assigning every process a distinct part of the vertex set.
 Every process will execute the main algorithm independently, and compute
 the part of the strategy that applies to its local vertex set.
\end_layout

\begin_layout Standard
In the following, it is assumed that processes execute symmetrically (all
 execute the same program) and independently (requiring no synchronization
 between instructions) but that communication is possible between any pair
 of processes by way of message passing.
 This is a fairly common distributed computing scenario, that requires a
 fast local network between otherwise independent computers.
\end_layout

\begin_layout Standard
Besides distributing the computation over several processes, the data structures
 are distributed as well.
 Every process stores the following information locally:
\end_layout

\begin_layout Itemize
The part of the global vertex set assigned to this process; this will be
 called the 
\emph on
internal vertex set
\emph default
.
\end_layout

\begin_layout Itemize
The part of the global strategy corresponding with the internal vertex set.
\end_layout

\begin_layout Itemize
A subgame of the global game graph that contains at least the internal vertex
 set.
\end_layout

\begin_layout Standard
Since no global data needs to be stored at individual processes, the amount
 of memory required per process for a given game decreases as the number
 of assigned processes increases.
 This approach therefore allows the size of games that can be solved to
 be scaled up with the number of processes.
\end_layout

\begin_layout Standard
With a fixed graph partition, most of the basic operations can be parallelized
 trivially.
 For example, when constructing the minimum priority vertex set, every process
 only considers the vertices in its assigned partition, and constructs a
 local set accordingly.
 The local sets computed by the individual processes form a partition of
 the set computed by the global algorithm.
 Set complements, subgames and final strategies can be constructed this
 way as well, requiring no synchronization between processes.
 The only tricky operation, and the only operation that requires communication
 between processes, is the computation of attractor sets.
 After all, containment of a vertex in an attractor set depends on whether
 none, one or all of its successors are already in the set, but these successors
 may not be part of the local vertex set.
\end_layout

\begin_layout Standard
In order to allow processes to communicate information about attractor sets
 in an efficient manner, it is useful to include in the local game graph
 not only vertices and edges in the internal vertex set, but also all adjacent
 vertices and the corresponding edges.
 This allows processes to share information with all other interested processes,
 without having to resort to broadcasting all locally computed data, which
 may well generate so much communication overhead to negate any possible
 benefits from parallelization.
\end_layout

\begin_layout Subsection
Distributed attractor set computation
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO:
\end_layout

\begin_layout Plain Layout
describe two approaches: synchronized and unsynchronized.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Empirical Evaluation
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

, Friedmann & Lange report on an emperical evaluation of their parity game
 solver on a variety of problems.
 They report the results for three major algorithms: Jurdziński's small
 progress measures algorithm, Zielonka's recursive algorithm and Jurdziński
 & Vöge's strategy improvement algorithm.
 Their solver is written in OCaml and does not support concurrency.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Copy description of games from log (Sunday 19 December)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Data set
\end_layout

\begin_layout Section
Execution
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Probably split into sequential/parallel results; depends a bit on what we
 have and what is new.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Chapter
Conclusion
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quickly summarize results and explain how they relate to the research question;
 describe how my research improved the state of the art (which was the research
 goal).
 Hopefully, we can get some useful conclusion like "I've found a lifting
 strategy that works well" and "I found an efficient way to solve a parity
 game concurrently" (this can be quantified pretty well since we have a
 serial algorithm to compare with).
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Future work
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe any untested hypotheses (things I thought about but don't have
 any results on).
 Describe possible ways to extend/improve the research.
 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
TODO LIST
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- replace 
\begin_inset Quotes eld
\end_inset

degree
\begin_inset Quotes erd
\end_inset

 (of a parity game) by 
\begin_inset Quotes eld
\end_inset

index
\begin_inset Quotes erd
\end_inset

, which is the term used by Piterman and by Lange
\end_layout

\begin_layout Plain Layout
- identify and label lemma's so I can refer to them more easily
\end_layout

\begin_layout Plain Layout
- distinguish more clearly between previous work and stuff I came up with
\end_layout

\begin_layout Plain Layout
- replace x by a different player variable? (Zielonka uses 
\begin_inset Formula $\sigma$
\end_inset

 for players, but Jurdziński uses it for strategies instead)
\begin_inset Newline newline
\end_inset

- have I described everything I came up with?
\end_layout

\begin_layout Plain Layout
- need many more references!
\end_layout

\begin_layout Plain Layout
- should I say `minimum' or `minimal' fixed point?
\end_layout

\begin_layout Plain Layout
The following comes from an old version of the thesis; probably need to
 work this in somehow:
\end_layout

\begin_layout Plain Layout
- Explain how parity games relate to binary equation systems, mu-calculus.
 This basically motivates why research into parity games is of practical
 interest.
 Explain that improving practical performance is of interest even if computation
al complexity doesn't improve.
 (This is critical for motivating research into lifting heuristics and parallel
 algorithms.)
\end_layout

\begin_layout Plain Layout
- Relation to other model checking approaches: Why would do model checking
 by solving parity games? What are the alternatives and what's wrong with
 them?
\end_layout

\begin_layout Plain Layout
- Need a 
\begin_inset Quotes eld
\end_inset

research question
\begin_inset Quotes erd
\end_inset

-like section that contains the research question from my proposal.
\end_layout

\begin_layout Plain Layout
- Describe globally what I'm going to do to improve the state of the art:
 Mainly two parts: (0.
 efficient implementation of existing algorithms => not really interesting
 on an academic level) 1.
 find better heuristics for small progress measures (detailed evaluation
 of SPM would be novel?) 2.
 find good way to parallelize small progress measures (this would be somewhat
 novel, although a lockfree implementation exists)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
