#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage {a4wide}
\usepackage {longtable}
\usepackage {tabu}
\usepackage {pgfplots}
\usepackage {multicol}
\usepackage {chngpage}
\newcommand*\ExpandableInput[1]{\@@input#1 }
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter beramono
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 80

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_author "Maks Verver"
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Title goes here
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
My final project deals with 
\emph on
parity games
\emph default
.
 Let me start by disappointing the readers to which the word 
\emph on
game 
\emph default
implies a fun activity: parity games are actually a mathematical formalism
 involving games that literally go on forever and are not much fun to play
 by hand.
 Fortunately, however, they 
\emph on
are
\emph default
 an interesting subject to study.
\end_layout

\begin_layout Standard
One reason to study parity games is the observation that, despite considerable
 research interest, the computational complexity of parity games is not
 yet known.
 Perhaps as a result, previous research tended to focus on theoretic aspects
 related to parity games, somewhat neglecting practical considerations.
\end_layout

\begin_layout Standard
This is a pity, since parity games have practical applications too, most
 notably as a vehicle for formal verification (by reduction from model checking
 and bisimulation problems).
 Formal verification tools are important since engineers use them to create
 reliable hardware and software components.
 Parity game algorithms have the potential to improve these tools considerably
 — that is, if they can be made to work well in practice.
\end_layout

\begin_layout Standard
Perhaps surprisingly, there is comparatively little research that focuses
 on parity games as a practical tool rather than a mathematical formalism.
 Few implementations of parity game algorithms exist, and the strengths
 and weaknesses of these tools are often poorly understood.
\end_layout

\begin_layout Standard
The goal of my final project was to develop a framework for experimentation
 with parity games, in order to better understand the performance of a variety
 of parity game algorithms, and to push the boundaries of the range of parity
 game problems that can be solved in practice.
 Consequently, my project mixes theory  with Along the way I discovered
 several techniques to improve the standard algorithms; these improvements
 are documented in this report.
\end_layout

\begin_layout Standard
Although I met several hurdles while executing the project, I believe the
 final result is quite good.
 The tool I developed is orders of magnitude more efficient than the competitors
 (though few exist) which demonstrates a practical contribution to the state
 of the art.
 Indeed, the observation that such large performance gains are possible
 at all supports the notion that further research on practical perfomance
 is useful.
\end_layout

\begin_layout Standard
Finally, it is my hope that my contributions not only prove beneficial to
 practitioners today, but will also increase the confidence in parity games
 as a useful formalism for other, higher-level problems, as well as inspire
 new developments in high-performance parity game solvers.
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
A 
\emph on
parity game
\emph default
 is a game played by two players, called Even and Odd, on a directed graph.
 Each vertex in the graph is associated with (
\emph on
owned
\emph default
 or 
\emph on
controlled
\emph default
 by) one of the two players.
 Furthermore, to each vertex a 
\emph on
priority
\emph default
 is assigned, which is a non-negative integer.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename illustrations/introduction-example.svg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
A small example of a parity game
\begin_inset CommandInset label
LatexCommand label
name "fig:introduction-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are different conventions for the player's names.
 They may be called Even and Odd, or denoted by symbols ◇ and ◻, which is
 particularly useful when visualizing games, as can be seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:introduction-example"

\end_inset

: the shape of the vertices corresponds with the players that control them.
 For the description of algorithms and data structures, especially when
 computations are involved, it is more convenient to use integers 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

.
 For example, if we consider a player 
\begin_inset Formula $x$
\end_inset

, his opponent is 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
Formally, a parity game can be described as a quadruple 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

, where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V=V_{0}\cup V_{1}$
\end_inset

 and 
\begin_inset Formula $V_{0}\cap V_{1}=\emptyset$
\end_inset

 (in other words: 
\begin_inset Formula $V_{\text{0}}$
\end_inset

 and 
\begin_inset Formula $V_{\text{1}}$
\end_inset

 partition the set of graph vertices 
\begin_inset Formula $V$
\end_inset

 into those controlled by
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 Even and Odd respectively).
 
\begin_inset Formula $E\subseteq V\times V$
\end_inset

 is the set of directed edges in the game graph.
 This set may contain loops (edges which lead from a vertex back to itself).
 
\begin_inset Formula $\phi:V\rightarrow\mathbb{N}_{0}$
\end_inset

 is the priority function that assigns a priority to every vertex in the
 graph.
 The number of distinct priority values assigned to vertices in the game,
 is called the 
\emph on
index of the game
\emph default
, wich is equal to the cardinality of the range of 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
Parity games can be played on finite as well as infinite graphs, although
 I will consider finite graphs exclusively.
 The index of the game is always assumed to be finite.
\end_layout

\begin_layout Subsection
Game Play and Winning Conditions
\end_layout

\begin_layout Standard
A parity game is played by placing a token on some initial vertex.
 The player controlling that vertex moves the token along an edge to an
 adjacent vertex, which may belong to either player, who then makes the
 next move.
 When the token lands on a vertex without any outgoing edges, the game ends.
 However, it is more common for a game to continue indefinitely, causing
 an infinite sequence of moves.
 The sequence of moves on the graph is called a 
\emph on
play
\emph default
 and it can be described as the sequence of vertices visited by the token.
 Formally, a sequence 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\pi=v_{1}v_{2}\ldots v_{n}$
\end_inset

 is a (finite) play if and only if 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\forall i<n,\ v_{i}v_{i+1}\in E$
\end_inset

 and 
\begin_inset Formula $v_{n}$
\end_inset

 has no outgoing edges.
 Similarly, an infinite sequence 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is an (infinite) play if and only if 
\begin_inset Formula $\forall i\in\mathbb{N},\; v_{i}v_{i+1}\in E$
\end_inset

.
 A prefix of a play (ending on some vertex with outgoing edges) is called
 a 
\emph on
partial play
\emph default
.
\end_layout

\begin_layout Standard
For finite plays, the player who is first unable to move is called the loser,
 and his opponent the winner.
 In a finite play, the loser is therefore simply the controller of the final
 vertex in the play.
\end_layout

\begin_layout Standard
For infinite plays, a more complicated notion of winning is used.
 Let the 
\emph on
dominant priority
\emph default
 
\begin_inset Formula $P(\pi)$
\end_inset

 for a play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 be the smallest value that occurs infinitely often in the sequence 
\begin_inset Formula $\phi(v_{1})\phi(v_{2})\ldots$
\end_inset

 or formally:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P(\pi)=\min\left\{ p\in\mathbb{N}_{0}:\ \forall i\ \exists j>i:\ \phi(v_{j})=p\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
A play is won by player Even if the dominant priority for the play is even,
 and won by Odd otherwise (hence their names).
 Since the set of priorities is finite, the dominant priority is well-defined
 for any play, and thus every play has a winner.
\end_layout

\begin_layout Standard
It should be noted that there is no consensus in literature on how priorities
 should be ordered.
 Throughout this report I will use the convention of lower priority values
 taking precedence over higher values, thus 
\begin_inset Formula $0$
\end_inset

 being the 
\begin_inset Quotes eld
\end_inset

highest
\begin_inset Quotes erd
\end_inset

 priority, which is consistent with the definition given above.
\end_layout

\begin_layout Subsection
Strategies and Solutions
\end_layout

\begin_layout Standard
A strategy for player 
\begin_inset Formula $x$
\end_inset

 assigns a move to each position in which 
\begin_inset Formula $x$
\end_inset

 is to move.
 Formally, the strategy is a function 
\begin_inset Formula $\dot{\sigma}_{x}:V^{*}\times V_{x}\rightarrow V$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 such that if 
\begin_inset Formula $v_{1}\ldots v_{n}$
\end_inset

 is a partial play, then 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=v_{n+1}$
\end_inset

 and 
\begin_inset Formula $v_{1}\ldots v_{n+1}$
\end_inset

 is a (partial) play too.
 A play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is called consistent with a strategy 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
for player 
\begin_inset Formula $x$
\end_inset

 if 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{i})=v_{i+1}$
\end_inset

 for all 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $v_{i}\in V_{x}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
.
\end_layout

\begin_layout Standard
A strategy 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called 
\emph on
winning
\emph default
 for player 
\begin_inset Formula $x$
\end_inset

 at starting vertex 
\begin_inset Formula $v_{1}$
\end_inset

 if all plays 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 consistent with 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 are won by player 
\begin_inset Formula $x$
\end_inset

.
 Parity games of finite index have the important property that they are
 fully 
\emph on
determined
\emph default
, i.e.
 for every starting vertex either player Even or player Odd has a winning
 strategy.
 Thus, for these games, we can partition the vertex set 
\begin_inset Formula $V$
\end_inset

 of the game graph into two sets of vertices 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

 which can be won by player Even and Odd respectively.
 When the index is infinite, we can still identify disjoint sets 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

, but they may not be a true partition.
\end_layout

\begin_layout Standard
In many practical applications, determination of winning sets is enough
 to constitute a solution.
 For example, when using parity games as a vehicle for model checking, the
 question whether a formal property holds corresponds with the question
 whether a particular vertex in a game graph is won by player Even.
 In this case it suffices to determine the winner for this particular vertex
 only, without computing associated strategies, and even without fully determini
ng winning sets.
\end_layout

\begin_layout Standard
A limitation of calculating winning sets without associated strategies is
 that even if we assume the output to be correct, the winning sets alone
 do not provide any insight into 
\emph on
why
\emph default
 a particular vertex is won by a particular player.
 Strategies are useful to understand the outcome of the games.
 In the application of model checking, strategies can be used to show why
 a certain property holds, or generate counter-examples if it doesn't.
 Additionally, if we have not just a winning set, but also associated strategies
, we can check the correctness of a proposed solution without having to
 solve the game from scratch.
\end_layout

\begin_layout Standard
Therefore, 
\emph on
solving a game
\emph default
 in the most general sense means to identify optimal strategies for both
 players in addition to their winning sets.
 Note that even in finite games, strategies (unlike winning sets) do not
 complement each other, so given an optimal strategy for one player, we
 cannot (easily) deduce an optimal strategy for his opponent.
\end_layout

\begin_layout Subsection
Optimal Strategies and Finite Memory
\end_layout

\begin_layout Standard
A strategy 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called an 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
optimal strategy
\emph default
 when it is winning for player 
\begin_inset Formula $x$
\end_inset

 starting from any vertex 
\begin_inset Formula $v\in W_{x}$
\end_inset

.
\end_layout

\begin_layout Standard
Strategies as described above are called 
\emph on
infinite-memory strategies
\emph default
, because they can take the entire move history into account to determine
 the next move.
 In contrast, 
\emph on
memoryless strategies
\emph default
 are strategies which depend only on the current position of the token,
 i.e.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=\dot{\sigma}_{x}(w_{1}\ldots w_{n})$
\end_inset

 whenever 
\begin_inset Formula $v_{n}=w_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
We will define memoryless strategies as functions 
\begin_inset Formula $\sigma_{x}:V_{x}\rightarrow V$
\end_inset

 such that if
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\sigma_{x}(v)=w$
\end_inset

 then 
\begin_inset Formula $vw\in E$
\end_inset

.
 A memoryless strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 is then consistent with a play 
\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset

 if 
\begin_inset Formula $\sigma_{x}(v_{i})=v_{i+1}$
\end_inset

 for all 
\begin_inset Formula $v_{i}\in V_{x}$
\end_inset

.
 We can restrict the domain of 
\begin_inset Formula $\sigma_{\text{x}}$
\end_inset

 to 
\begin_inset Formula $V_{\text{x}}\cap W_{x}$
\end_inset

 since for vertices in 
\begin_inset Formula $V_{x}$
\end_inset

 but not in 
\begin_inset Formula $W_{\text{x}}$
\end_inset

, player 
\begin_inset Formula $x$
\end_inset

 has no winning move, and therefore any adjacent vertex can be selected
 without affecting the optimality of the strategy.
 Even if we leave out these vertices for which the controlling player has
 no winning move, optimal strategies are not (necessarily) uniquely defined,
 unlike winning sets.
\end_layout

\begin_layout Standard
Sometimes we want to refer to the combined strategies of both players, 
\begin_inset Formula $\sigma$
\end_inset

, defined as:
\begin_inset Formula 
\[
\sigma(v)=\begin{cases}
\sigma_{0}(v) & \mbox{if }v\in V_{0}\\
\sigma_{1}(v) & \mbox{if }v\in V_{1}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
It turns out that for all games of finite index optimal memoryless strategies
 exist.
 Research on finite-order games typically focuses on finding memoryless
 strategies for both players, which can be described succinctly by simply
 listing an optimal move for every vertex.
\end_layout

\begin_layout Standard
This report is about finding optimal strategies for finite parity games,
 and therefore the term 
\emph on
strategy
\emph default
 without further qualification will be used to mean 
\emph on
optimal memoryless strategy
\emph default
, and the 
\emph on
solution
\emph default
 to a parity game is a triple 
\begin_inset Formula $W_{0},W_{1},\sigma$
\end_inset

 describing the winning sets and optimal strategy for both players.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename illustrations/introduction-example-solved.svg
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The example game solved
\begin_inset CommandInset label
LatexCommand label
name "fig:introduction-example-solved"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:introduction-example-solved"

\end_inset

 the solution for the example game presented earlier is shown.
 Vertices are partioned into winning sets for both players.
 Edges that cannot be part of winning strategies are dashed.
 In this particular case, any of the solid edges can be chosen to yield
 an optimal strategy.
\end_layout

\begin_layout Section
Computational Complexity
\end_layout

\begin_layout Standard
Given a polynomial-time algorithm to verify the optimality of a pair of
 winning strategies (one such algorithm will be presented later on), the
 general problem of determining winning sets as well as strategies can be
 solved by nondeterministically guessing the winner and an optimal move
 for each vertex, which puts the problem in NP (the set of problems decidable
 by a non-deterministic Turing machine and verifiable by a deterministic
 Turing machine in polynomial time) and co-NP (by symmetry of the problem:
 absence of a winning strategy for one player can be proven by showing a
 winning strategy for the other player).
 The strategies are certificates to the solution.
\end_layout

\begin_layout Standard
NP and co-NP are generally believed to be distinct, and since the existence
 of NP-hard problems in co-NP would imply NP = co-NP, it seems unlikely
 that the problem is NP-hard.
 This makes it plausible that there should be a polynomial-time algorithm
 to solve parity games, but despite considerable research interest, none
 have been found.
\end_layout

\begin_layout Standard
If there exists a polynomial-time algorithm that determines winning sets
 only (without associated strategies) then full solutions can be constructed
 in polynomial time too.
 This restricted problem has been shown to be in UP 
\begin_inset Formula $\cap$
\end_inset

 co-UP 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski1998deciding"

\end_inset

 where UP is the subset of NP containing those problems that are decidable
 by an 
\emph on
unambiguous
\emph default
 nondeterministic Turing machine.
 Since P 
\begin_inset Formula $\subseteq$
\end_inset

 UP 
\begin_inset Formula $\subseteq$
\end_inset

 NP this is a stronger result, although it is not known whether P 
\begin_inset Formula $\subset$
\end_inset

 UP or UP 
\begin_inset Formula $\subset$
\end_inset

 NP (or both, or neither).
\end_layout

\begin_layout Standard
The best currently known algorithms are either exponential in game index
 
\begin_inset Formula $d$
\end_inset

 (for example, Jurdziński's Small Progress Measures algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset

 has an upper bound of 
\begin_inset Formula $O\left(d\left|E\right|\left(\frac{\left|V\right|}{\left\lfloor d/2\right\rfloor }\right)^{\left\lfloor d/2\right\rfloor }\right)$
\end_inset

 ) while others are instead subexponential in the size of the game graph
 (for example, Jurdziński, Paterson and Zwick give an 
\begin_inset Formula $\left|V\right|^{O(\sqrt{\left|V\right|})}$
\end_inset

 algorithm in 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2006deterministic"

\end_inset

).
\end_layout

\begin_layout Standard
Often 
\begin_inset Formula $d$
\end_inset

 is small and therefore the first category of algorithms provides better
 worst-case time complexity bounds.
 However, in practice many instances can be solved much faster than the
 best available bound would suggest, and as a result these bounds cannot
 be used to predict which algorithms work best in practice.
\end_layout

\begin_layout Section
Application To Model Checking
\end_layout

\begin_layout Standard
The most notable practical application of parity games is their suitability
 as a component in model checking systems, which attempt to verify whether
 a model of a system (typically expressed in some high-level formal language)
 satisfies a certain specification (typically captured in a temporal logic
 formula).
\end_layout

\begin_layout Standard
Model checking tools must balance two concerns: on the one hand, the specificati
on language available to the user should be as expressive as possible, while
 on the other hand, the internal representation of the resulting model checking
 problem should be kept simple enough so that it can be solved quickly using
 provably-correct algorithms.
\end_layout

\begin_layout Standard
Parity games fit these constraints well because they can be used to express
 whether a property specified in the modal 
\begin_inset Formula $\mu$
\end_inset

-calculus holds on a labelled transition system (LTS) 
\begin_inset CommandInset citation
LatexCommand cite
key "emerson1991tree"

\end_inset

.
 Since many high-level specification languages can be converted into labelled
 transition systems, and formulas expressed in commonly used temporal logics
 (including LTL, CTL and CTL*) can be translated to the modal 
\begin_inset Formula $\mu$
\end_inset

-calculus
\begin_inset CommandInset citation
LatexCommand cite
key "emerson1997model"

\end_inset

, efficient algorithms for solving parity games could provide the basis
 of a comprehensive approach to model checking.
\end_layout

\begin_layout Standard
Not only are parity games sufficiently powerful to express these problems,
 but conversion from the model checking problem to parity games yields reasonabl
y compact games, where the number of vertices equals the product of the
 number of states in the LTS and the number of subexpressions in the 
\begin_inset Formula $\mu$
\end_inset

-calculus formula, and the number of priorities corresponds with the alternation
 depth of fixed-point operators in the formula (for example, see 
\begin_inset CommandInset citation
LatexCommand cite
key "obdrzalek2006algorithmic"

\end_inset

 for one explicit construction method).
 Finally, these games can be constructed in linear time, and thus model
 checking via parity games would be a very practical approach, assuming
 the resulting parity games can be solved quickly.
\end_layout

\begin_layout Section
Related work 
\begin_inset CommandInset label
LatexCommand label
name "sec:Related-work"

\end_inset


\end_layout

\begin_layout Standard
The work related to mine falls into three broad categories: theoretical
 work on parity game algorithms, practical work on formulating problems
 as parity games, and implementations of parity game algorithms.
 I will summarize the developments most relevant to my project in this section.
\end_layout

\begin_layout Subsection
Automata theory and parity game algorithms 
\begin_inset CommandInset label
LatexCommand label
name "sub:Automata-and-PG-algorithms"

\end_inset


\end_layout

\begin_layout Standard
A considerable amount of literature is available on parity games specifically
 and more generally on perfect-information games played on (possibly infinite)
 graphs and trees, as well as their relationship to computing automata and
 their application to model checking.
 The majority of this work is theoretical in nature.
\end_layout

\begin_layout Standard
An important property of parity games is the fact that the winner can be
 determined for every vertex using memoryless strategies.
 A proof of determinacy of Borel games, of which parity games are a specializati
on, was first formulated by Donald A.
 Martin 
\begin_inset CommandInset citation
LatexCommand cite
key "martin1975borel"

\end_inset

.
 For Borel games with a Rabin winning condition, of which the parity condition
 is a special case, Klarlund proved that memoryless strategies exist 
\begin_inset CommandInset citation
LatexCommand cite
key "klarlund1994progress"

\end_inset

.
 Both of these results are more general than needed for parity games; Zielonka
 gives two direct proofs for the memoryless determinacy of parity games
 specifically 
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset

.
\end_layout

\begin_layout Standard
Some of the terminology introduced to discuss more general classes of games
 (like Muller games, which cannot generally be solved with memoryless strategies
) is also useful for discussing parity games, and these will be repeated
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Common-Terminology"

\end_inset

.
\end_layout

\begin_layout Standard
For parity games specifically, many solving algorithms have been proposed,
 including:
\end_layout

\begin_layout Itemize
A recursive algorithm based on a constructive proof of determinacy, first
 described by McNaughton 
\begin_inset CommandInset citation
LatexCommand cite
key "mcnaughton1993infinite"

\end_inset

 and reformulated for parity games by Zielonka 
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset


\end_layout

\begin_layout Itemize
Fixed-point iteration using Small Progress Measures by Jurdziński 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset


\end_layout

\begin_layout Itemize
Strategy improvement by Vöge and Jurdziński 
\begin_inset CommandInset citation
LatexCommand cite
key "voege2000discrete"

\end_inset


\end_layout

\begin_layout Itemize
A randomized subexponential algorithm by Björklund, Sandberg and Vorobyov
 
\begin_inset CommandInset citation
LatexCommand cite
key "bjorklund2003discrete"

\end_inset


\end_layout

\begin_layout Itemize
A deterministic subexponential algorithm by Jurdziński, Paterson and Zwick
 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2006deterministic"

\end_inset


\end_layout

\begin_layout Itemize
A combination of McNaughton's and Jurdziński's algorithms that proceeds
 in “big steps” by Schewe 
\begin_inset CommandInset citation
LatexCommand cite
key "schewe2007solving"

\end_inset


\end_layout

\begin_layout Itemize
Optimal strategy improvement by Schewe 
\begin_inset CommandInset citation
LatexCommand cite
key "schewe2008strategy-improvement"

\end_inset


\end_layout

\begin_layout Standard
Additionally, various indirect approaches to solving parity games by reduction
 to other formulations such as SAT (
\begin_inset CommandInset citation
LatexCommand cite
key "lange2005sat"

\end_inset

) and Boolean equation systems have been proposed.
\end_layout

\begin_layout Standard
This gives plenty of algorithms to choose from, though there is no agreement
 on which algorithms work best in practice.
 Schewe favours approaches based on strategy improvement, stating these
 are: 
\emph on

\begin_inset Quotes eld
\end_inset

[..] fast simplex style algorithms that perform well in practice.
 While their complexity is wide open, they are often considered the best
 choice for solving large scale games.
\emph default

\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "schewe2008strategy-improvement"

\end_inset


\end_layout

\begin_layout Standard
However, Friedmann and Lange have performed an emperical evaluation of various
 algorithms, and conclude that 
\emph on

\begin_inset Quotes eld
\end_inset

the small progress measures algorithm as well as the strategy improvement
 turn out to be generally slower than the recursive algorithm
\emph default

\begin_inset Quotes erd
\end_inset

 and conclude that 
\emph on

\begin_inset Quotes eld
\end_inset

Zielonka’s recursive algorithm is the best parity game solver in practice
\emph default

\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

.
\end_layout

\begin_layout Standard
Of these algorithms, Jurdziński's Small Progress Measures, Schewe's 
\begin_inset Quotes eld
\end_inset

big steps
\begin_inset Quotes erd
\end_inset

 variant, and the subexponential algorithms are intendend mainly to establish
 ever tighter upper bounds on the general problem.
 The approaches based on strategy improvement are intended to yield best
 results in practice.
 The relatively simple approach due to McNaughton/Zielonka often works well
 too.
 Its worst-case performance has been analyzed by Gazda and Willemse (
\begin_inset CommandInset citation
LatexCommand cite
key "gazda2013zielonka"

\end_inset

) who conclude that Zielonka's algorithm can solve weak games (games in
 which priorities are nondecreasing along all edges) in polynomial time,
 but may require exponential time even on other, very simple, classes of
 games (dull games and solitaire games).
 The slowdown on these cases can be mitigated by interleaving Zielonka's
 algorithm with decomposition of the game graph into strongly-connected
 components although this does not lower the worst-case complexity in general.
\end_layout

\begin_layout Subsection
Model checking tools
\end_layout

\begin_layout Standard
At least two formal verification systems exist that can transform model
 checking problems into parity games:
\end_layout

\begin_layout Enumerate
The mCRL2 toolkit 
\begin_inset CommandInset citation
LatexCommand cite
key "groote2008mcrl2"

\end_inset

 composes models and formulae into parametrized Boolean equation systems
 (PBES) 
\begin_inset CommandInset citation
LatexCommand cite
key "groote2005parameterised"

\end_inset

, can linearize these into Boolean equation systems (BES), and either solve
 those directly (with a tool called 
\family typewriter
pbes2bool
\family default
) or translate them into parity games instead.
 Various transformations on the level of PBES or BES are also possible.
\end_layout

\begin_layout Enumerate
The LTSmin toolkit 
\begin_inset CommandInset citation
LatexCommand cite
key "blom2010ltsmin"

\end_inset

 supports a different approach: it transforms a PBES into a parametrized
 parity game (PPG) and then generates the parity game directly 
\begin_inset CommandInset citation
LatexCommand cite
key "kant2012pbes2pg"

\end_inset

.
 This approach was motivated by the observation that linearization of the
 PBES was often the slowest step in the solution process, and that optimization
 of this conversion can drastically reduce both time and memory required.
\end_layout

\begin_layout Standard
In both of these toolkits, the parametrized forms tend to be fairly small,
 while the linearized forms (and therefore the final parity game) may be
 quite large.
 Model checking using a parity game solver as a backend is viable only if
 the resulting parity games can reasonably fit into memory.
 This is a limitation shared with many other approaches to model checking
 (in particular those relying on explicit state space exploration).
\end_layout

\begin_layout Subsection
Simulation reductions
\end_layout

\begin_layout Standard
Recent work has focused on polynomial-time reductions on the game graph,
 based on the principle that any reduction of the graph that preserves winners
 is at least permissible, and will often simsolving the game.
 In principle every parity game can be reduced to just two vertices, one
 won by each of the players, but computing such a reduction would be equivalent
 to solving the parity game and therefore this is not feasible in polynomial
 time.
 However, finer equivalence relations which preserve winners are certainly
 computable, and may help to reduce the size and complexity of the problem
 before passing it to an (exponential time) generic solver.
\end_layout

\begin_layout Standard
All of these reductions depend on a high degree of redundancy in the input
 game to be effective; such redundancy typically arises in games that are
 automatically generated from higher level problems, but not necessarily
 in e.g.
 randomly generated games.
\end_layout

\begin_layout Subsubsection
Delayed simulation
\end_layout

\begin_layout Standard
Fritz and Wilke (
\begin_inset CommandInset citation
LatexCommand cite
key "fritz2005simulation,fritz2006simulation"

\end_inset

) investigated both 
\emph on
direct
\emph default
 and 
\emph on
delayed simulation
\emph default
 in parity automata (of which parity games are a special case).
 Since direct simulation equivalence is too restrictive to provide significant
 benefits, they introduce the weaker notion of delayed simulation instead:
 traces do not need to show equivalent priorities in all positions, as long
 as a priority visited in one automaton is eventually (after a finite number
 of steps) matched by the same (or better) priority in the other.
 A low priority encountered in one automaton thus creates an obligation
 that must eventually (but not necessarily immediately) be fulfilled in
 the other one.
\end_layout

\begin_layout Standard
This relation does not preserve the language recognized by the automaton
 and thus a somewhat more limited relation, called 
\emph on
biased
\emph default
 delayed simulation, is introduced, which can be used to partition vertices
 into equivalence classes and construct a valid quotient that preserves
 the winners of all vertices.
\end_layout

\begin_layout Standard
In theory, biased delayed simulation works well; for example, all games
 in the class introduced by Jurdziński in 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset

 can be reduced to their two-vertex minimal representation; the best possible
 result.
 However, in general, the costs seem to outweigh the benefits, as Fritz
 reports that: “experiments with an implementation indicate that solving
 a given parity game using Jurdziński’s lifting algorithm directly is faster
 than first simplifying the parity game using our approach and then solving
 it using Jurdziński’s algorithm”.
 Although he does not specify which test cases were used to reach this conclusio
n (there may be practical cases which do benefit from the reduction, aside
 from Jurdziński's special cases) the fact that computing the delayed simulation
 equivalence relation is relatively expensive for a polynomial-time preprocessin
g step (requiring 
\begin_inset Formula $O(\left|V\right|^{3}·\left|E\right|·d^{2})$
\end_inset

 time in the worst case) probably limits the utility of their approach in
 practice.
\end_layout

\begin_layout Subsubsection
Stuttering equivalence
\end_layout

\begin_layout Standard
Cranen, Keiren and Willemse instead introduce the notion of 
\emph on
stuttering equivalence
\emph default
 (
\begin_inset CommandInset citation
LatexCommand cite
key "cranen2011stuttering"

\end_inset

) which is neither strictly stronger nor weaker than biased delayed simulation
 reduction.
 It is somewhat limited in that it only groups together vertices with equal
 owners and priorities.
 However, the stuttering equivalence relation can be calculated quickly
 (in only 
\begin_inset Formula $O(\left|V\right|·\left|E\right|)$
\end_inset

 time) and allows quotients of games to be constructed without further complicat
ions.
 The authors report that, in contrast to Fritz and Wilke's results, applying
 stuttering equivalence reduction before solving often provides a net benefit
 in practice, and usually performs better than strong bisimulation reduction.
\end_layout

\begin_layout Standard
Stuttering equivalence is further refined into 
\emph on
governed stuttering bisimulation
\emph default
 (
\begin_inset CommandInset citation
LatexCommand cite
key "cranen2012cure"

\end_inset

) which allows vertices with different controlling players to be grouped
 together too.
 In theory this should yield further reduction of the game graph, though
 at a higher computational cost (since the relation requires 
\begin_inset Formula $O(\left|V\right|^{2}·\left|E\right|)$
\end_inset

 time to calculate).
 An emperical evaluation suggests that the two reductions offer comparable
 performance in practice.
\end_layout

\begin_layout Subsubsection
Bisimulation on Boolean Equation Systems
\end_layout

\begin_layout Standard
Another approach is taken by Keiren and Willemse (
\begin_inset CommandInset citation
LatexCommand cite
key "keiren2011bisimulation"

\end_inset

) on Boolean equation systems, which are a formalisim very similar to parity
 games (i.e.
 parity games can be considered a restricted form of Boolean equation systems)
 and are used as an intermediate representation in the mCRL2 toolkit.
 Despite the fact that Boolean equation systems and parity games can be
 converted to each other in linear time, in practice generating parity games
 from Boolean equation systems takes a significant amount of time, which
 makes reductions on Boolean equation systems attractive because they could
 remove this bottleneck from the solution process.
\end_layout

\begin_layout Standard
Keiren and Willemse introduce the notion of 
\emph on
idempotence preserving bisimulation
\emph default
, which has no direct analogue on parity games, but falls between strong
 bisimulation and branching bisimulation in terms of refinement.
 The cost of calculating the bisimulation relation is low, requiring 
\begin_inset Formula $O(\left|E\right|\cdot\log\left|V\right|)$
\end_inset

 time.
 An empirical evaluation shows that solving with idempotence preserving
 bisimulation reduction is slower than with strong bisimulation reduction,
 even though in some cases idempotence preserving bisimulation creates smaller
 quotients.
 However, both reductions provide great benefits over solving the game directly.
 The choice of algorithms used to solve the final parity games (Jurdziński's
 Small Progress Measures and Schewe's “big step” variant) could have exaggerated
 the results somewhat.
\end_layout

\begin_layout Subsection
Parity game solvers
\end_layout

\begin_layout Standard
Although many algorithms have been proposed in literature (as discussed
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Automata-and-PG-algorithms"

\end_inset

) few implementations are mentioned, and there is little discussion of practical
 considerations (speed in practice, memory use, parallelizability, distributabil
ity, et cetera).
 This is suprising: considering the utility of parity game solvers as part
 of a model checking toolchain, and the notorious gap between theoretical
 time complexity and solving time required in practical instances, one would
 imagine there to be more research interest in determining which algorithms
 work well in practice.
\end_layout

\begin_layout Standard
The main exception is PGSolver (
\emph on
“a collection of tools for generating, manipulating and - most of all -
 solving parity games”
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "pgsolver"

\end_inset

) which implements a large number of algorithms described in literature,
 as well as a number of preprocessing operations to simplify instances before
 passing them on to a solver backend.
 This tool is actively maintained, and forms the basis of Friedmann and
 Lange's empirical evaluation 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

.
\end_layout

\begin_layout Standard
Jeroen Keiren also used PGSolver to evaluate the suitability of parity game
 algorithms to solve the Boolean equation systems generated by the mCRL2
 toolkit.
\begin_inset CommandInset citation
LatexCommand cite
key "keiren2009"

\end_inset

 Although PGSolver is a powerful tool, it also has some limitations: it's
 a strictly sequential solver that doesn't support parallel or distributed
 solving, and since it is implemented in OCaml, it relies on automatic memory
 management, which may not be very efficient (especially when solving large
 problems).
\end_layout

\begin_layout Standard
Van de Pol and Weber developed a multi-core implementation of Small Progress
 Measures 
\begin_inset CommandInset citation
LatexCommand cite
key "vandepol2008multicore"

\end_inset

 (the first parallel implementation of a parity game algorithm).
 However, their tool is unmaintained and because of the limited scope of
 their experiments, not very suitable for general use.
\end_layout

\begin_layout Standard
In summary, it appears that PGSolver is the only comprehensive tool easily
 available to users that have a parity game problem to solve.
\end_layout

\begin_layout Section
My Contributions
\end_layout

\begin_layout Standard
From the above it should be clear that there is a gap between theory and
 practice with respect to the use of parity games as a vehicle for formal
 verification.
 On the practical side there is a desire to efficiently solve model checking
 problems that arise in practice.
 Tool support to express these problems as parity games already exists.
 On the theoretical side there is no dearth of proposed algorithms for solving
 parity games, but there is only one tool that actually implements these
 algorithms: PGSolver.
\end_layout

\begin_layout Standard
It should come as no surprise that my contributions lie in this area.
 They consist of a variety of ideas to improve upon the design and implementatio
n of parity game solvers, empirical evaluation of these ideas, and, as a
 by-product, an efficient parity game solving tool which improves upon the
 state of the art in several ways:
\end_layout

\begin_layout Itemize
For mCRL2, my tool provides an alternative to 
\family typewriter
pbes2bool
\family default
 (the default solver for PBES) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
any examples of where my tool is faster / uses less memory?
\end_layout

\end_inset

.
 My solver has already been integrated into mCRL2 as an experimental tool
 called 
\family typewriter
pbespgsolve
\family default
 which can be used today.
\end_layout

\begin_layout Itemize
Compared to PGSolver, my tool features fewer different solver algorithms,
 but better preprocessing routines and heuristics.
 My tool typically uses less time and space to solve testcases, sometimes
 dramatically so.
\end_layout

\begin_layout Standard
I want to stress that improving upon PGSolver was not a goal of the project
 in itself.
 However, having independent implementations of some of the critical algorithms
 (in different programming languages and using different data structures)
 is very useful to put empirical data such as reported by Friedmann and
 Lange in perspective, because it helps quantify to which extent results
 depend on the performance of the algorithms themselves and how much they
 are influenced by implementation techniques.
\end_layout

\begin_layout Standard
My solver also includes a few innovations that are documented in this report:
\end_layout

\begin_layout Itemize
A new preprocessing technique which removes cycles controlled by a single
 player from the game (described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Winner-controlled-cycle-removal"

\end_inset

)
\end_layout

\begin_layout Itemize
An efficient strategy verification algorithm, independent of solving algorithms
 (described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Verification"

\end_inset

)
\end_layout

\begin_layout Itemize
Improved heuristics for the small progress measures algorithm (described
 in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Maximum-Measure-Propagation"

\end_inset

)
\end_layout

\begin_layout Itemize
Two optimizations of the small progress measures algorithm (described in
 subsections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Eliminating-failed-lifting"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimization-after-lifting"

\end_inset

)
\end_layout

\begin_layout Standard
Finally, my report includes an empirical evaluation of these algorithms
 and techniques in order to give more insight in which techniques are most
 useful when solving parity games in practice (in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Empirical-Evaluation"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The rest of the report should be structured around describing/proving these
 contributions.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Building blocks for parity game solvers
\end_layout

\begin_layout Standard
Before discussing algorithms used to solve parity games, it is useful to
 establish some common terminology related to parity game theory.
 Most of this terminology comes from literature, but since the terms used
 and their meaning varies considerably, it is necessary to define the concepts
 and terms that will be used in the rest of this report.
\end_layout

\begin_layout Standard
First, a number of restrictions on the game structure will be made to simplify
 the definition and discussion of the algorithms and datastructures that
 follow.
 Second, a number of useful properties of parity games will be presented;
 none of these are new, but they will be defined in a manner consistent
 with the preceding definitions.
 Third, a number of notable special cases of parity games will be discussed;
 these deserve to be mentioned but are otherwise outside the scope of this
 report, which focuses on general cases.
\end_layout

\begin_layout Standard
Finally, a polynomial-time algorithm for the verification of parity game
 algorithms will be presented, which is used to guarantee the correctness
 of the reported results.
\end_layout

\begin_layout Section
Restrictions on the graph
\end_layout

\begin_layout Standard
For convenience, I will assume that every vertex has at least one outgoing
 edge.
 This property makes finite plays impossible, which simplifies the analysis
 of many algorithms.
 We will call a game a 
\emph on
proper game
\emph default
 if its graph satisfies this property.
 However, improper games can be turned into proper games by considering
 each vertex without outgoing edges: if it is controlled by player 
\begin_inset Formula $x$
\end_inset

, we can change its priority to 
\begin_inset Formula $1-x$
\end_inset

 and add an edge from the vertex back to itself.
 In the modified graph every vertex has an outgoing edge, yet it has the
 same solution and winning strategies as the original graph.
\end_layout

\begin_layout Standard
Additionally, I will assume the game graph is finite.
 This has practical as well as theoretical benefits.
 From a practical point of view, since all of the game data is now finite,
 it allows us to represent graphs explicitly using only finite memory (otherwise
, a symbolic representation would be required).
 From a theoretical point of view, a finite vertex set allows for algorithms
 and proofs that do not generalize to infinite graphs.
\end_layout

\begin_layout Section
Restrictions on the set of priorities
\end_layout

\begin_layout Standard
When discussing actual implementations of data structures and algorithms,
 it is convenient to assume that the priorities in the game are not just
 integers, but bounded by a value that is as small as possible.
 Fortunately, we can reduce the values of priorities used to a range between
 0 and 
\begin_inset Formula $d$
\end_inset

 (exclusive), where 
\begin_inset Formula $d$
\end_inset

 is the index of the game.
 This is done by remapping priorities for vertices in a process called 
\emph on
priority compression.
\end_layout

\begin_layout Standard
Consider we have a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 and we wish to apply priority compression.
 To do so, we find the first unused priority (say, 
\begin_inset Formula $p$
\end_inset

) in the game.
 If 
\begin_inset Formula $p=d$
\end_inset

 then all priorities from 
\begin_inset Formula $0$
\end_inset

 through 
\begin_inset Formula $d-1$
\end_inset

 (inclusive) are used and we are done.
 Otherwise, let 
\series bold

\begin_inset Formula $q$
\end_inset


\series default
 be the least priority greater than 
\begin_inset Formula $p$
\end_inset

 that is used.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $p=0$
\end_inset

 then we can decrement all priorities by 
\begin_inset Formula $q$
\end_inset

 and, if 
\begin_inset Formula $q$
\end_inset

 is odd, we additionally switch the roles of players Even and Odd.
 Formally, we construct a game 
\begin_inset Formula $\Gamma'=(V_{\text{0}}',V_{\text{1}}',E,\phi')$
\end_inset

 where 
\begin_inset Formula $V_{x}'=V_{y}$
\end_inset

 and 
\begin_inset Formula $x=y-p\mod{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
, 
\begin_inset Formula $\phi'(v)=\phi(v)-q$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $p>0$
\end_inset

 then we keep 
\begin_inset Formula $V_{0}'=V_{0}$
\end_inset

 and 
\begin_inset Formula $V_{1}'=V_{1}$
\end_inset

.
 However, if 
\begin_inset Formula $p\equiv q\mod{2}$
\end_inset

 then we get rid of the unused priorities and lump the vertices with priority
 
\begin_inset Formula $q$
\end_inset

 in with those with priority 
\begin_inset Formula $p$
\end_inset

.
 After all, 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 have the same parity, and since none of the values in between are used,
 they can be interchanged without affecting the outcome of the game.
 More formally, in this case we define 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi'(v)$
\end_inset

 as:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 
\begin_inset Formula 
\[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q & \mbox{\mbox{if }\ensuremath{\phi(v)>p}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $p-q\equiv0\mod{2}$
\end_inset

 this preserves parity: 
\begin_inset Formula $\phi'(v)\equiv\phi(v)\mod{2}$
\end_inset

.
 Finaly, if 
\begin_inset Formula $p>0$
\end_inset

 and 
\begin_inset Formula $p\not\equiv q\mod{2}$
\end_inset

 then we can remove the unused priorities, but we do not want to equate
 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 which have different priorities:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q+1 & \mbox{\mbox{if} \ensuremath{\phi(v)>p}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Again, since 
\begin_inset Formula $p-q+1\equiv0\mod{2}$
\end_inset

 this preserves the parity of 
\begin_inset Formula $\phi$
\end_inset

 while removing the unused priorities between 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 Repeating this process to eliminate all the gaps results in a game which
 uses priorities form 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $d-1$
\end_inset

 (inclusive).
\end_layout

\begin_layout Standard
Most solving algorithms do not require that priorities are compressed into
 a minimal range, but since the amount of time and space required is often
 a function of the maximum priority that occurs in the game, it is useful
 to preprocess every game to minimize the priority set in this way, especially
 since this is can be easily done in 
\begin_inset Formula $O(V)$
\end_inset

 time.
\end_layout

\begin_layout Section
Common Terminology 
\begin_inset CommandInset label
LatexCommand label
name "sec:Common-Terminology"

\end_inset


\end_layout

\begin_layout Standard
There are a number of concepts which can be applied to parity games which
 have been described in literature before.
 In particular, Zielonka introduces some useful terminology in a treatise
 on two-player games played on coloured graphs (of which parity games are
 a subset) which will be repeated here.
 He describes attractor sets and traps.
 Additionally, I will describe subgames analogous to (though slightly different
 from) subarenas.
\end_layout

\begin_layout Subsection
Subgames
\end_layout

\begin_layout Standard
A 
\emph on
subgame
\emph default
 of a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 induced by a vertex set 
\begin_inset Formula $U\subseteq V$
\end_inset

 is the game 
\begin_inset Formula $\Gamma|U=(V_{0}\cap U,V_{1}\cap U,E\cap\left(U\times U\right),\phi|U)$
\end_inset

 where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi|U$
\end_inset

 denotes 
\begin_inset Formula $\phi$
\end_inset

 with its domain limited to 
\begin_inset Formula $U$
\end_inset

.
 In other words, the game obtained when only considering vertices from 
\begin_inset Formula $U$
\end_inset

 and ignoring the rest.
 
\begin_inset Formula $\Gamma|U$
\end_inset

 is called a 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
proper subgame
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 if it is a proper game as described above.
\end_layout

\begin_layout Subsection
Traps
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $vE$
\end_inset

 be the set of vertices which are successors of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $E$
\end_inset

, or formally 
\begin_inset Formula $vE=\{w\in V:\ vw\in E\}.$
\end_inset

 Analogously, 
\begin_inset Formula $Ew=\{v\in V:\ vw\in E\}$
\end_inset

.
 A non-empty vertex set 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $U\subseteq V$
\end_inset

 is a trap for player 
\begin_inset Formula $x$
\end_inset

 (or an 
\begin_inset Formula $x$
\end_inset

-trap, for short) when, informally, player 
\begin_inset Formula $x$
\end_inset

 cannot force the token out of 
\begin_inset Formula $U$
\end_inset

.
 Formally, 
\begin_inset Formula $U$
\end_inset

 is an 
\begin_inset Formula $x$
\end_inset

-trap if for all 
\begin_inset Formula $v\in U$
\end_inset

:
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula 
\[
v\in V_{x}\rightarrow vE\setminus U=\emptyset
\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula 
\[
v\in V_{1-x}\rightarrow vE\cap U\neq\emptyset
\]

\end_inset


\end_layout

\begin_layout Standard
In literature, 
\begin_inset Formula $x$
\end_inset

-traps are sometimes called 
\emph on
dominions
\emph default
 for player 
\begin_inset Formula $1-x$
\end_inset

 instead.
\end_layout

\begin_layout Subsection
Attractor sets
\begin_inset CommandInset label
LatexCommand label
name "sub:Attractor-sets"

\end_inset


\end_layout

\begin_layout Standard
An attractor set for a player 
\begin_inset Formula $x$
\end_inset

 on a vertex set 
\bar under

\begin_inset Formula $U\subseteq V$
\end_inset


\bar default
, denoted 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

, is the set of vertices from which the player 
\begin_inset Formula $x$
\end_inset

 can force the token into one of the vertices in 
\begin_inset Formula $U$
\end_inset

 (including, by definition, vertices in 
\begin_inset Formula $U$
\end_inset

 itself).
 Zielonka gives an iterative definition of an attractor set:
\begin_inset Formula 
\[
U_{0}=U
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
U_{i+1}=U_{i}\cup\{v\in V_{x}:\; vE\cap U_{i}\neq\emptyset\}\cup\{v\in V_{1-x}:\; vE\setminus U_{i}=\emptyset\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Attr^{x}(\Gamma,U)=U_{0}\cup U_{1}\cup\cdots
\]

\end_inset


\end_layout

\begin_layout Standard
Since the graph is finite eventually 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
converges to some 
\begin_inset Formula $U_{i}\subseteq V$
\end_inset

 when 
\begin_inset Formula $U_{i}=U_{i+1}$
\end_inset

 and we can find that point by iteratively computing the sets up to this
 point.
 In practice a slightly different approach is used, as will be described
 in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Attractor-set-computation"

\end_inset

.
\end_layout

\begin_layout Standard
In literature, attractor sets are sometimes called 
\emph on
force sets
\emph default
 instead.
\end_layout

\begin_layout Subsubsection
Attractor strategies
\end_layout

\begin_layout Standard
An important property of attractor sets is that if 
\begin_inset Formula $U\subseteq W_{x}$
\end_inset

, then 
\begin_inset Formula $Attr^{x}(\Gamma,U)\subseteq W_{x}$
\end_inset

 too.
 Of course, if we know the optimal strategy for all vertices 
\begin_inset Formula $v\in U$
\end_inset

, then we also want to extend this strategy to 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

.
 Fortunately, this can easily be done: every vertex that first appears in
 
\begin_inset Formula $U_{i+1}$
\end_inset

 (i.e.
 it is a member of 
\begin_inset Formula $U_{i+1}\setminus U_{i}$
\end_inset

) has a successor in 
\begin_inset Formula $U_{i}$
\end_inset

, and when we repeatedly choose such a successor, then we arrive at 
\begin_inset Formula $U_{0}$
\end_inset

 in 
\begin_inset Formula $i$
\end_inset

 steps, at which point the rest of the strategy is known.
 Therefore, attractor set computation of a winning region with known strategy
 yields a stategy for the entire attractor set too.
\end_layout

\begin_layout Subsubsection
Duality between attractor sets and traps
\end_layout

\begin_layout Standard
The second important property of attractor sets is that the complement 
\begin_inset Formula $V'$
\end_inset

 of an attractor set for player 
\begin_inset Formula $x$
\end_inset

 (formally: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V'=V\setminus Attr^{x}(\Gamma,U)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
) is a trap for 
\begin_inset Formula $x$
\end_inset

.
 Moreover, if 
\begin_inset Formula $\Gamma$
\end_inset

 is a proper game, 
\begin_inset Formula $\Gamma|V'$
\end_inset

 is a proper subgame
\emph on
 
\emph default
of 
\begin_inset Formula $\Gamma$
\end_inset

, since if a vertex 
\begin_inset Formula $v\in V'$
\end_inset

 has no successor 
\begin_inset Formula $w\in V'$
\end_inset

 then all its successors must be in 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 would have, by definition, been in the attractor set, instead of its complement.
\end_layout

\begin_layout Standard
This property is important because it means that if we start with a proper
 game then we can safely remove attractor sets of arbitrary vertex sets
 to obtain proper subgames, which is not the case if we would remove arbitrary
 vertex sets.
 This technique can be used to break down a game in parts which are solved
 separately.
\end_layout

\begin_layout Section
Degenerate cases
\end_layout

\begin_layout Standard
In addition to games which do not comply with the restrictions mentioned
 earlier, there are also a few classes of degenerate games that are special
 cases of the general game describe above.
 They are mentioned separately because specific algorithms exist to solve
 them more quickly.
\end_layout

\begin_layout Standard
These special cases are occasionally provided as input to a solver (for
 example, as the representation of a particularly simple model checking
 problem) but more commonly they arise as subgames to be solved after preprocess
ing the game or after partial solving.
\end_layout

\begin_layout Subsection
Single-parity games
\begin_inset CommandInset label
LatexCommand label
name "sub:Single-priority-games"

\end_inset


\end_layout

\begin_layout Standard
If the priorities of vertices all have the same parity (even or odd) then
 the corresponding player will trivially win from every starting vertex,
 with an arbitrary strategy.
 A special case is the single-priority game, where only a single priority
 is used.
 Priority compression can be used to convert the former case to the latter.
\end_layout

\begin_layout Subsection
Single-player games
\end_layout

\begin_layout Standard
A parity game is a 
\emph on
single-player game for player 
\begin_inset Formula $x$
\end_inset

 
\emph default
when all vertices controlled by player 
\begin_inset Formula $1-x$
\end_inset

 have outdegree equal to 1.
 In such a game, only player 
\begin_inset Formula $x$
\end_inset

 can make choices, and player 
\series bold

\begin_inset Formula $1-x$
\end_inset


\series default
 is forced to always move the token to the single available successor whenever
 it lands on one of his vertices.
\end_layout

\begin_layout Standard
In such a game, player 
\begin_inset Formula $x$
\end_inset

 wins precisely from the vertices which lie on a cycle of which the minimum
 priority has parity equal to 
\begin_inset Formula $x$
\end_inset

, as well as from all vertices from which such a cycle can be reached.
 After all, his opponent has no choice, so he can never force the token
 out of a cycle or prevent player 
\begin_inset Formula $x$
\end_inset

 from reaching a cycle when there exists a path to it.
 The remaining vertices (if there are any) are won by player 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
In extremely rare cases the game is played on a graph consisting of cycles
 only and then neither player has a choice.
 In that case, strategies are trivial and the winner of each cycle corresponds
 to the parity of the least priority occuring on the cycle.
\end_layout

\begin_layout Subsection
Graphs of multiple components
\end_layout

\begin_layout Standard
Some game graphs are not completely connected, in the sense that there may
 be pairs of vertices where there exists no path from one vertex to the
 other.
 These games can be solved more efficiently by identifying strongly connected
 components, solving each component separately, and then combining the results.
\end_layout

\begin_layout Standard
An easy way to implement this is to solve components in reverse topological
 order.
 When a component has edges pointing to vertices outside the current component,
 these can be replaced by edges to dummy vertices (one won by Even and one
 won by Odd) and then the subgame induced by the component can be solved.
 (Solving the components bottom-up guarantees the winner for vertices outside
 of but reachable from the current component is well-defined.) This approach
 is simple and has the advantage that the decomposition algorithm is run
 only once, so its overhead is strictly limited to 
\begin_inset Formula $O(E)$
\end_inset

 time.
 However, it may miss some opportunities for decomposition.
\end_layout

\begin_layout Standard
A somewhat more sophisticated approach is to extend the winning regions
 identified after solving a component into their attractor sets in the main
 game.
 Then, when considering a component which contains some previously-solved
 vertices, we can construct a subgame without those vertices and recursively
 invoke the decomposition algorithm, which may be able to break down the
 graph into even smaller components.
\end_layout

\begin_layout Standard
The second method relies on the observation that removing attractor sets
 of winning regions from a game results in a proper subgame, so no dummy
 vertices are required, and has the advantage of being able to cheaply solve
 additional vertices through attractor set computation (thus never invoking
 the general solver for those vertices) and possibly creating smaller subgames
 to solve (when removal of attractor sets splits up a large component).
\end_layout

\begin_layout Standard
The latter method is implemented in PGSolver and my solver as well.
 It seems to work well in practice, though there is a risk: since the decomposit
ion algorithm is invoked recursively, it is possible to waste a lot of time
 decomposing graphs rather than solving games.
 To prevent this, my solver imposes a limit on the recursion depth (by default:
 maximum 10 recursive invocations); when the maximum recursion depth is
 reached, subgames are passed directly to the general solver, without attempting
 to decompose the game graph further.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
add an illustration of method 2?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
add degenerate case? (see: tools/generate-scc-hard-game.py)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Verification 
\begin_inset CommandInset label
LatexCommand label
name "sec:Verification"

\end_inset


\end_layout

\begin_layout Standard
To ascertain the correctness of the implemented algorithms, it is useful
 to have a means of verifying the solutions produced by these algorithms.
 Of course, algorithms are typically published with a correctness proof
 before they are implemented, but mistakes could be introduced during implementa
tion, which makes it worthwhile to implement a verification routine to validate
 the results independent of any solution algorithms.
\end_layout

\begin_layout Standard
Note that solutions produced by different algorithms cannot generally be
 compared: although winning sets are unique (and thus can be compared) strategie
s are generally not, so when two algorithms produce two different pairs
 of strategies, that does not imply either is wrong.
\end_layout

\begin_layout Standard
The verification algorithm described below depends on the efficient solution
 of single-player games, for which a polynomial time algorithm will be presented
 first.
\end_layout

\begin_layout Subsection
Solving single-player games
\end_layout

\begin_layout Standard
Without loss of generality, suppose we want to solve a single-player game
 for player Even.
 Player Even can win from at least some vertices if the graph contains a
 cycle with even dominant priority (for brevity, let's call this an 
\emph on
even cycle
\emph default
).
\end_layout

\begin_layout Standard
To solve the game, we iteratively identify an even cycle 
\begin_inset Formula $c_{1}c_{2}\ldots c_{n}\in V^{+}$
\end_inset

 in the game (
\begin_inset Formula $c_{i}c_{j}\in E$
\end_inset

 if 
\begin_inset Formula $i+1=j\mod{n}$
\end_inset

 and 
\begin_inset Formula $\min\phi(c_{j})=0\mod{2}$
\end_inset

) 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
and then solve the smaller subgame 
\begin_inset Formula $\Gamma|V\setminus Attr^{x}(\Gamma,\{c_{1},c_{2}\ldots,c_{n}\})$
\end_inset

 in the same manner.
 The strategy for player Even is formed by combining 
\begin_inset Formula $\sigma_{0}(c_{i})=c_{j}$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
if 
\begin_inset Formula $i+1=j\mod{n}$
\end_inset

 with the strategy obtained by computing the attractor set and solving the
 subgame.
 When eventually no even cycle remains, then all possible plays in the remaining
 subgame necessarily have odd dominant priority and player Odd wins from
 the remaining vertices with a trivial strategy, since by definition of
 a single-player game Odd has no choice in the game.
\end_layout

\begin_layout Standard
The question now becomes how to find these even cycles.
 If we call a cycle with dominant priority 
\emph on
i
\emph default
 an 
\emph on
i
\emph default
-cycle, then a game contains an 
\emph on
i
\emph default
-cycle if and only if it contains some vertices with priority 
\emph on
i
\emph default
 lying on a cycle after removal of all edges incident with vertices of priority
 less than 
\emph on
i
\emph default
, because an 
\emph on
i
\emph default
-cycle can only include edges between vertices of priority 
\emph on
i
\emph default
 or greater.
 To find an 
\emph on
i
\emph default
-cycle in a graph with edges between vertices of priorities 
\emph on
i
\emph default
 or greater, we can use the connection between strongly connected components
 of the graph and cycles in the graph: every cycle must lie in a single
 strongly connected component and if the edge set of a strongly-connected
 component is non-empty, then all vertices in the strongly-connected component
 must lie on a cycle (by the definition of strongly connected components).
\end_layout

\begin_layout Standard
To find an even cycle, then, it suffices to search for 
\begin_inset Formula $i$
\end_inset

-cycles for all even values of 
\begin_inset Formula $i$
\end_inset

 and for each value construct a graph with edges incident only to vertices
 of priority 
\begin_inset Formula $i$
\end_inset

 or greater, which is then decomposed into strongly connected components.
 If a vertex with priority 
\begin_inset Formula $i$
\end_inset

 exists in a component which contains at least one edge, then a cycle can
 be found with a backtracking search within the component, which will visit
 every edge in the component at most once.
\end_layout

\begin_layout Standard
Because identifying strongly connected components takes 
\begin_inset Formula $O(E)$
\end_inset

 time (for example, using Tarjan's algorithm, described in 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1971depth"

\end_inset

) and subgame construction typically takes 
\begin_inset Formula $O(E)$
\end_inset

 time as well, it would not be very efficient to remove attractor sets one
 cycle at a time.
 Instead, after decomposing the graph for priority 
\begin_inset Formula $i$
\end_inset

, we can search for one cycle per component and compute the attractor set
 of all these cycles combined to remove all 
\begin_inset Formula $i$
\end_inset

-cycles from the game at once.
 This way, the algorithm requires at most 
\series bold

\begin_inset Formula $O(d)$
\end_inset


\series default
 iterations and in the worst case 
\begin_inset Formula $O(d\left|E\right|)$
\end_inset

 total time.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
How does 
\family typewriter
solve_single_player_scc
\family default
 work in PGSolver?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Verification algorithm
\end_layout

\begin_layout Standard
We are only interested in the strategy for vertices that are in the winning
 set of the player that controls them.
 Assume we are verifying the set 
\begin_inset Formula $W_{x}$
\end_inset

 with optimal strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 for player 
\begin_inset Formula $x$
\end_inset

.
 Define a graph with vertices limited to 
\begin_inset Formula $W_{x}$
\end_inset

 and the set of edges 
\begin_inset Formula $E|\sigma_{x}$
\end_inset

 as follows:
\begin_inset Formula 
\[
E|\sigma_{x}=\left\{ vw\in E:v\in\left(W_{x}\cap V_{x}\right)\wedge\sigma_{x}(v)=w\right\} \cup\left\{ vw\in E:v\in\left(W_{x}\cap V_{1-x}\right)\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Less formally, the edge set includes the edges that are consistent with
 
\begin_inset Formula $x$
\end_inset

's strategy, as well as all edges originating at vertices controlled by
 his opponent.
 We must first check that 
\begin_inset Formula $E|\sigma_{x}\subseteq W_{x}\times W_{x}$
\end_inset

 (otherwise, either player 
\begin_inset Formula $x$
\end_inset

 or his opponent would move the token outside 
\begin_inset Formula $W_{x}$
\end_inset

 in which case it cannot be the right winning set).
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Assuming this property holds, then 
\begin_inset Formula $\Gamma|\sigma_{x}=(W_{x}\cap V_{x},W_{x}\cap V_{1-x},E|\sigma_{x},\phi|W_{x})$
\end_inset

 is a proper subgame of 
\begin_inset Formula $\Gamma$
\end_inset

, and precisely those plays in the original game consistent with strategy
 
\begin_inset Formula $\sigma_{x}$
\end_inset

 are possible in the game 
\begin_inset Formula $\Gamma|\sigma_{\text{x}}$
\end_inset

 as well, except that all choice for player 
\begin_inset Formula $x$
\end_inset

 has been removed, which makes 
\begin_inset Formula $\Gamma|\sigma_{x}$
\end_inset

 a single-player game controlled by player 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
To verify that the original strategy was sound, we can solve this single
 player game using the method described earlier, and verify that the winning
 set for player 
\begin_inset Formula $W_{1-x}$
\end_inset

 in the subgame is empty.
 This proves that the strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 is valid in 
\begin_inset Formula $W_{x}$
\end_inset

 though it does not yet prove that 
\begin_inset Formula $W_{x}$
\end_inset

 is maximal.
 To show that, we must verify that 
\begin_inset Formula $W_{x-1}=V\setminus W_{x}$
\end_inset

 is a winning set for the opponent 
\begin_inset Formula $x-1$
\end_inset

.
\end_layout

\begin_layout Standard
Complete verification of winning sets and strategies therefore requires
 solving two single-player games, each of which takes 
\begin_inset Formula $O(d\left|E\right|)$
\end_inset

 time (as described above).
 Since 
\begin_inset Formula $d\leq\left|V\right|$
\end_inset

 the verification algorithm runs in polynomial time and is fast in practice
 when the game graph is sparse and the number of distinct priorities is
 low, as is often the case.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
PGSolver does the same thing, but without explicit complexity bounds on
 
\family typewriter
solve_single_player_scc
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Common algorithms and data structures
\end_layout

\begin_layout Standard
The results that will be presented later on are based on emperical evaluation
 of various parity game solving algorithms on both synthetic and real-world
 cases.
 The results obtained therefore depend not only on the choice of algorithms,
 but also on various implementation details, such as the data structures
 and programming techniques used to implement those algorithms.
\end_layout

\begin_layout Standard
It has been shown that in practice different experimental tools have different
 performance characteristics despite being based on the same theoretical
 algorithms.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite some proof?
\end_layout

\end_inset

 This phenomon occurs because of undocumented differences in the implementation
 of these different tools, sometimes arising from intentional changes to
 those algorithms (preprocessing operations or optimizations for particular
 instances, for example) and more often because the algorithms described
 in literature are usually not described to a sufficient level of detail
 that they can be implemented without being forced to make concrete implementati
on choices.
 For theoretical analysis this is not necessary (and usually, in the interest
 of conciseness, not desired), but for practical results it matters significantl
y how the missing parts are implemented concretely.
\end_layout

\begin_layout Standard
To ensure that the results presented here are reproducible, and to make
 the differences in results obtained with different tools easier to understand
 and explain, I will document the choices that I made in the implementation
 of my solving tool to a fair amount of detail.
 In particular, the core data structures and the algorithms will be documented
 precisely.
\end_layout

\begin_layout Standard
Finally, the descriptions provided here and in later chapters are a useful
 key to understanding the source code of my solver tool, since it provides
 a high-level overview of its design.
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
Recall that a parity game consists of a directed graph, a partition of vertices
 into sets owned by the two players, and the assignment of a priority to
 every vertex.
 This data must be represented in some way in a solver.
\end_layout

\begin_layout Standard
When executing a solving algorithm, the parity game data is read, but usually
 not modified.
 Therefore, an implementation that allows efficient read-only access is
 more important than a data structure with high flexibility in regards to
 updates.
 However, many of the simplification and preprocessing algorithms must either
 modify the parity game under consideration or be able to quickly construct
 a modified copy of it.
 This use case must be accommodated as well.
\end_layout

\begin_layout Standard
Finally, since practical instances of parity games tend to be fairly large,
 it is desirable that the parity game representation is as compact as possible,
 to the extend this is possible without compromising access speed.
 This not only reduces the amount of memory needed to solve particularly
 large instances, but also ensures that the solving algorithms benefit maximally
 from cache effects.
\end_layout

\begin_layout Subsection
The game graph structure
\end_layout

\begin_layout Standard
A parity game is played on a directed graph, which consists of a set of
 vertices (
\begin_inset Formula $V$
\end_inset

) and a set of edges (
\begin_inset Formula $E\subseteq V\times V$
\end_inset

).
 Vertices will be identified with integers from 0 through 
\begin_inset Formula $\left|V\right|$
\end_inset

 (exclusive).
 At a minimum, we will store 
\begin_inset Formula $\left|V\right|$
\end_inset

 and 
\begin_inset Formula $\left|E\right|$
\end_inset

, the number of vertices and edges in the graph respectively.
\end_layout

\begin_layout Standard
To represent the graph in its entirety, we then only need to store the edges.
 We could store those as an array of pairs of integers (the source and destinati
on vertices of a directed edge).
 This is reasonably compact (requiring 
\begin_inset Formula $2\left|E\right|$
\end_inset

 integers to be stored).
 However, this representation is impractical if we want to quickly access
 a set of successors (
\begin_inset Formula $vE$
\end_inset

) or predecessors (
\begin_inset Formula $Ev$
\end_inset

) of a vertex, which are common operations in many algorithms.
\end_layout

\begin_layout Standard
Therefore, a different representation is used.
 Suppose we start with the array of edges described above and sort them
 by source vertex first, and destination vertex second.
 Then, all the edges from a vertex 
\begin_inset Formula $v$
\end_inset

 to its successors will occur as a consecutive sequence in the edge array,
 and we can store for each vertex the interval 
\begin_inset Formula $[\mathtt{succBegin[v],\mathtt{succEnd[v]})}$
\end_inset

.
\end_layout

\begin_layout Standard
This representation would require 
\begin_inset Formula $2\left|E\right|+2\left|V\right|$
\end_inset

 integers to be stored, and allows the following operations to be performed
 efficiently:
\end_layout

\begin_layout Enumerate
Enumerate the successors of a vertex (
\begin_inset Formula $vE$
\end_inset

), in order.
\end_layout

\begin_layout Enumerate
Calculate the number of successors of a vertex (
\begin_inset Formula $\left|vE\right|$
\end_inset

), by calculating 
\begin_inset Formula $\mathtt{succEnd[v]}-\mathtt{succBegin[v]}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Determine if 
\begin_inset Formula $vw\in E$
\end_inset

 (using binary search, this could take 
\begin_inset Formula $O\left(log\left(\left|vE\right|+1\right)\right)$
\end_inset

 time).
\end_layout

\begin_layout Standard
Of course, the first operation is the one that is most common.
 Next, we can apply two simplifications.
 First, since the predecessor vertex of all edges with indices between 
\begin_inset Formula $\mathtt{succBegin[v]}$
\end_inset

 and 
\begin_inset Formula $\mathtt{succEnd[v]}$
\end_inset

 are known to be equal to 
\begin_inset Formula $v$
\end_inset

, we don't need to store predecessor vertices at all.
 Additionally, it is easy to see that 
\begin_inset Formula $\mathtt{succEnd[v]=succBegin[v+1]}$
\end_inset

 for all 
\begin_inset Formula $v$
\end_inset

 except the last vertex, so we can store all indices in a single array of
 length 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left|V\right|+1$
\end_inset

, instead of using two arrays.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
This it the final representation that is used, and requires 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\left|E\right|+\left|V\right|+1$
\end_inset

 integers to store the edge data.
 However, this edge representation only allows us to quickly find successors
 of edges.
 For some algorithms, it is useful to be able to find predecessors quickly
 as well.
 For this reason, the graph data structure by default stores the edge set
 in reverse order too, doubling the amount of memory required.
\end_layout

\begin_layout Standard
It should be noted that this dense edge representation does not allow efficient
 insertion or removal of individual edges in the game graph, because each
 such operation requires a large part of the edge array to be moved.
 Fortunately, the preprocessing algorithms that are applied in the solver
 are applied to the graph as a whole, and the cost of individual changes
 can therefore be amortized over the entire graph-wide operation.
\end_layout

\begin_layout Subsection
The parity game structure
\end_layout

\begin_layout Standard
In addition to the game graph, a parity game must store two attributes for
 each vertex:
\end_layout

\begin_layout Enumerate
The controlling player (Even or Odd), and
\end_layout

\begin_layout Enumerate
the associated priority value, 
\begin_inset Formula $\phi(v)$
\end_inset

.
\end_layout

\begin_layout Standard
These two attributes are packed into a two-byte structure, and stored in
 an array of length 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 Note that this limits the maximum priority that can be represented to 255,
 which seems low, but is much larger than occurs in practice (although synthetic
 cases with larger priorities could easily be generated).
\end_layout

\begin_layout Standard
Additionaly, we store in the parity game structure two properties of the
 game:
\end_layout

\begin_layout Enumerate
The priority limit (
\begin_inset Formula $d$
\end_inset

) which is calculated as the maximum priority value used + 1.
 (This is equal to the index of the game assuming all priority values are
 used.)
\end_layout

\begin_layout Enumerate
An array of integers of length 
\begin_inset Formula $d$
\end_inset

 that stores how many vertices occur with each individual priority value.
\end_layout

\begin_layout Standard
This information can be recomputed from the vertex attributes in time 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

, but it is useful in a number of situations, for example, to quickly calculate
 the worst-case execution time of the SPM algorithm or to quickly determine
 whether priority compression is possible.
\end_layout

\begin_layout Subsection
The solution structure
\end_layout

\begin_layout Standard
Every solving algorithm needs to return a solution to the given parity game,
 which consists of a partitioning of the vertex set into winning sets for
 both players, and a strategy for each player which is defined at least
 for vertices in the winning set of that player.
\end_layout

\begin_layout Standard
This characterization shows that there is a strong relation between winning
 sets and strategies of players: when a player controls a vertex which lies
 outside his winning set, he has no meaningful strategy there (as every
 possible move is by definition losing).
 Therefore, we will simply define solutions as arrays which assign to every
 vertex the successor vertex for the controlling player, or the special
 value 
\begin_inset Formula $-1$
\end_inset

 if it is in his opponent's winning set instead:
\begin_inset Formula 
\[
\mathtt{solution[v]}=\begin{cases}
\sigma_{0}(v) & \mbox{ if }v\in V_{0}\cap W_{0}\\
\sigma_{1}(v) & \mbox{ if }v\in V_{1}\cap W_{1}\\
-1 & \mbox{ if }v\in(V_{0}\cap W_{1})\cup(V_{1}\cap W_{0})
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
From a solution array, winning sets and strategies can be trivially obtained
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W_{x}=\{v\in V_{x}:\;\mathtt{solution[v]}\neq-1\}
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{x}(v)=\begin{cases}
\mathtt{solution[v]} & \mbox{ if }v\in W_{x}\\
\min(vE) & \mbox{ if \ensuremath{v\notin W_{x}}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Note that the choice of the minimum successor for vertices which are lost
 to the current player is arbitrary; in those cases any successor could
 be chosen.
\end_layout

\begin_layout Subsection
Subgame construction
\end_layout

\begin_layout Standard
Many algorithms require subgames to be constructed.
 Since the data structure described above requires a dense representation
 of vertices, this requires that all data is reconstructed.
 The subgame 
\begin_inset Formula $\Gamma|U$
\end_inset

 is constructed from an array containing the vertex identifiers in 
\begin_inset Formula $U$
\end_inset

 while the ordering of the elements determines the new identifiers of the
 vertices in the subgraph.
\end_layout

\begin_layout Standard
The main cost in constructing a subgame comes from the construction the
 successor and/or predecessor arrays of the subgraph, which is done by iterating
 over all successors (or predecessors, as the case may be) of vertices in
 
\begin_inset Formula $U$
\end_inset

, filtering out vertices which are outside of 
\begin_inset Formula $U$
\end_inset

.
 If the ordering of vertices in 
\begin_inset Formula $U$
\end_inset

 differs from 
\bar under

\begin_inset Formula $V$
\end_inset


\bar default
 then vertex lists need to be resorted too, but usually this is not necessary;
 for most purposes 
\begin_inset Formula $U$
\end_inset

 can be constructed as a subsequence of 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Standard
To filter vertices efficiently, either a hashtable or a boolean array is
 used to represent 
\begin_inset Formula $U$
\end_inset

, depending on the size of 
\begin_inset Formula $U$
\end_inset

 relative to 
\begin_inset Formula $V$
\end_inset

: for small subsets the mapping is sparse and a hashtable is more efficient.
 The exact time complexity depends on the outdegree for vertices in 
\begin_inset Formula $U$
\end_inset

.
 If we assume the graph to be sparse (i.e.
 the outdegree is 
\begin_inset Formula $O(1)$
\end_inset

) then subgame construction takes 
\begin_inset Formula $O(\left|U\right|)$
\end_inset

 space.
 Even if the graph is not sparse, subgame construction takes time linear
 in the number of edges of the resulting subgraph, as long as the outdegree
 of the subgame is comparable to that of the vertices in the original graph.
\end_layout

\begin_layout Standard
This is the assumption that will be used in this report to analyze the complexit
y of algorithms that rely on subgame construction, which includes Zielonka's
 algorithm, as well as many preprocessing operations.
 Finally, it should be noted that when constructing subgames, the array
 
\begin_inset Formula $U$
\end_inset

 is kept around to be able to map the vertex indentifiers in the subgame
 back to the original game, which is necesssary to propagate solution and
 strategy information back to the main game, and to gather global statistics
 and debugging information.
\end_layout

\begin_layout Subsection
Attractor set computation 
\begin_inset CommandInset label
LatexCommand label
name "sub:Attractor-set-computation"

\end_inset


\end_layout

\begin_layout Standard
Attractor sets can be calculated straightforwardly using a queue and a set,
 where both data structures are assumed to have 
\begin_inset Formula $O(1)$
\end_inset

 performance for the relevant operations (for example, a deque and a hash
 table satisfy these requirements).
 The queue is initialized to the attractor set.
 Every iteration, a vertex is extracted from the queue and its predecessors
 are examined.
 Any predecessor which is controlled by the player for whom we are computing
 the attractor set, or which is controlled by his opponent but has no successors
 outside the attractor set, is added to the queue and the attractor set,
 and (optionally) the strategy for the new vertex is updated.
 Because the attractor set computation is analogous to a breadth-first search,
 the strategy reflects the shortest path from vertices in the extended attractor
 set to vertices in the initial set.
 The algorithm is presented in detail as Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Attractor-set-computation"

\end_inset

.
\end_layout

\begin_layout Standard
Computing attractor sets this way requires both predecessor and successor
 information to be stored in the graph, and the resulting algorithm is reasonabl
y efficient for sufficiently sparse graphs.
 However, the worst-case complexity is as high as 
\begin_inset Formula $O(\left|E\right|\left|V\right|)$
\end_inset

.
 This complexity arises from the fact that when a predecessor is controlled
 by the opponent of the player for whom the attractor set is computed, then
 all successors of this vertex must be evaluated to see if an edge to a
 vertex outside the attractor set exists; in a worst-case scenario, all
 vertices currently in the attractor set could be reachable before a successor
 outside it is found.
\end_layout

\begin_layout Standard
Lets call the successors of a vertex which lie outside the attractor set
 its 
\emph on
liberties
\emph default
.
 We can store the number of liberties for each vertex in a simple array
 of integers, which is initialized to the outdegree of each vertex, and
 updated whenever a vertex is found to be in the attractor set (by decrementing
 the count for each of its predecessors).
 This eliminates the need to examine successors at all, as Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Attractor-set-computation-2"

\end_inset

 shows, and reduces the time complexity to 
\begin_inset Formula $O(\left|E\right|)$
\end_inset

.
\end_layout

\begin_layout Standard
Note that for the second algorithm, the 
\begin_inset Formula $O(\left|E\right|)$
\end_inset

 bound is tight, while time required for the first algorithm correlates
 with the size of the attractor set calculated, and consequently the first
 implementation can outperform the second in practice.
 However, the second algorithm has the additional benefit of not requiring
 successor information to be stored in the graph.
 For algorithms which rely heavily on subgame construction, this can result
 in an additional performance improvement.
\end_layout

\begin_layout Standard
(Note: the worst-case time complexity of the first algorithm can also be
 reduced to 
\begin_inset Formula $O(\left|E\right|)$
\end_inset

 by tracking the first successor outside the attractor set for each opponent-con
trolled vertex.
 However, this does not remove the dependence on successor edges.)
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

Set<Vertex> make_attractor_set(
\end_layout

\begin_layout Plain Layout

	ParityGame game, Player player,
\end_layout

\begin_layout Plain Layout

	Set<Vertex> initial, Strategy s )
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Queue<Vertex> todo
\end_layout

\begin_layout Plain Layout

	Set<Vertex> attr
\end_layout

\begin_layout Plain Layout

	for v in initial {
\end_layout

\begin_layout Plain Layout

		attr.insert(v)
\end_layout

\begin_layout Plain Layout

		todo.push_back(v)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	while not todo.empty() {
\end_layout

\begin_layout Plain Layout

		Vertex v = todo.pop_front()
\end_layout

\begin_layout Plain Layout

		for u in game.graph.predecessors(v) {
\end_layout

\begin_layout Plain Layout

			if u in attr {
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			if game.player(u) == player {
\end_layout

\begin_layout Plain Layout

				strategy[u] = v
\end_layout

\begin_layout Plain Layout

			} else if game.graph.successors(u) is subset of attr {
\end_layout

\begin_layout Plain Layout

				strategy[u] = NO_VERTEX
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			attr.insert(u)
\end_layout

\begin_layout Plain Layout

			todo.push_back(u)
\end_layout

\begin_layout Plain Layout

 		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return attr
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Attractor set computation 
\begin_inset CommandInset label
LatexCommand label
name "alg:Attractor-set-computation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

Set<Vertex> make_attractor_set(
\end_layout

\begin_layout Plain Layout

	ParityGame game, Player player,
\end_layout

\begin_layout Plain Layout

	Set<Vertex> initial, Strategy s )
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Vector<Integer> liberties = { 0, 0, 0 ..
 }
\end_layout

\begin_layout Plain Layout

	for v in game.graph.V {
\end_layout

\begin_layout Plain Layout

		for u in game.graph.predecessors(v) {
\end_layout

\begin_layout Plain Layout

			liberties[u]++
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	Queue<Vertex> todo
\end_layout

\begin_layout Plain Layout

	Set<Vertex> attr
\end_layout

\begin_layout Plain Layout

	for v in initial {
\end_layout

\begin_layout Plain Layout

		attr.insert(v)
\end_layout

\begin_layout Plain Layout

		todo.push_back(v)
\end_layout

\begin_layout Plain Layout

		liberties[v] = 0
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	while not todo.empty() {
\end_layout

\begin_layout Plain Layout

		Vertex v = todo.pop_front()
\end_layout

\begin_layout Plain Layout

		for u in game.graph.predecessors(v) {
\end_layout

\begin_layout Plain Layout

			if liberties[u] == 0 {
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			if game.player(u) == player {
\end_layout

\begin_layout Plain Layout

				strategy[u] = v
\end_layout

\begin_layout Plain Layout

				liberties[u] = 0
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				liberties[u]--
\end_layout

\begin_layout Plain Layout

				if liberties[u] == 0 {
\end_layout

\begin_layout Plain Layout

					strategy[u] = NO_VERTEX
\end_layout

\begin_layout Plain Layout

				} else {
\end_layout

\begin_layout Plain Layout

					continue
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			attr.insert(u)
\end_layout

\begin_layout Plain Layout

			todo.push_back(u)
\end_layout

\begin_layout Plain Layout

 		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return attr
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Attractor set computation 
\begin_inset CommandInset label
LatexCommand label
name "alg:Attractor-set-computation-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Graph decomposition
\end_layout

\begin_layout Standard
To compute strongly connected components, Tarjan's algorithm from 
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1971depth"

\end_inset

 is used, which enumerates all strongly connected components in reverse
 topological order, which means that when a component is found all edges
 lead to vertices within the component, or into one of the components found
 before.
 The algorithm requires 
\begin_inset Formula $O(\left|E\right|)$
\end_inset

 time and 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 space (even if the algorithm is aborted before all components have been
 found).
\end_layout

\begin_layout Standard
The algorithm as described by Tarjan is based on a depth-first search of
 the graph, labeling vertices as they are visited.
 Depth-first search is typically implemented as a recursive procedure, but
 this is impractical for very large graphs, where high recursion depth may
 exhaust the available stack space.
 Therefore, the implementation uses an iterative approach, with an explicit
 stack data structure which is stored in the heap.
 In addition to removing the limitations on recursion depth, this reduces
 memory use substantially, because the on-heap state representation (consisting
 of a vertex and edge index) is much more compact than a full stack frame
 would be.
\end_layout

\begin_layout Standard
Components are passed to a callback function as an array of indices of vertices
 in the original graph.
 Such an array can be used to construct a subgame for the component, as
 described above, though it should be noted that the subgame induced by
 a strongly connected component of the game graph is not typically a proper
 subgame itself, unless there are no edges going out of the current component.
\end_layout

\begin_layout Standard
The decomposition algorithm is used to implement solving of individual component
s, removal of owner-controlled cycles and verification of games.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: browse code for stuff I didn't cover yet
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Small Progress Measures
\end_layout

\begin_layout Standard
Small Progress Measures is a relatively simple, iterative algorithm for
 partially solving parity games proposed by Marcin Jurdziński.
 A game is solved only partially in the sense that the winning set and optimal
 strategy for one player is determined.
 To solve a game completely, the algorithm must therefore be run twice,
 but, fortunately, in the second pass the winning set of the first player
 can be omitted from the game graph, which typically reduces the time required
 to solve the remaining part of the game significantly.
\end_layout

\begin_layout Standard
Small Progress Measures (or SPM for short) is attractive because it is a
 relatively simple which allows it to be implemented easily and provides
 ample opportunity to speed up the core algorithm (for example, through
 parallelization).
 Additionally, the algorithm has one of the lowest worst-case complexity
 bounds known for solving parity games (excluding Schewe's big step approach,
 which invokes SPM recursively) requiring at most 
\begin_inset Formula $O\left(\left|E\right|\left(\left|V\right|/\left\lfloor \frac{d}{2}\right\rfloor \right)^{\left\lfloor \frac{d}{2}\right\rfloor }\right)$
\end_inset

 time and 
\begin_inset Formula $O(\left|V\right|d)$
\end_inset

 space (in addition to the space required to store the parity game itself)
 although unfortunately those are also lower bounds on the worst case.
\end_layout

\begin_layout Standard
Oliver Friedmann implemented a variation of the algorithm in PGSolver that
 effectively combines the two passes in one, solving both the game and its
 dual at the same time.
 This does not improve on the worst-case time bounds (and, in fact, may
 require around twice as much time and memory compared to the standard algorithm
), but can avoid some of the pitfalls that cause excessive runtimes with
 the standard algorithm, which makes it a useful alternative in practice.
 Since this variation has not been published before, it will be described
 in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Two-sided-SPM"

\end_inset

.
\end_layout

\begin_layout Standard
A lock-free concurrent version was implemented by Van de Pol and Weber which
 works on shared-memory systems that do not reorder memory operations.
 A concurrent implementation for the Playstation 3 (taking advantage of
 the capabilities of the multi-core Cell processor) was written by Jorne
 Kandziora 
\begin_inset CommandInset citation
LatexCommand cite
key "kandziora2009ps3"

\end_inset

 and later improved upon by Freark van der Berg.
 
\begin_inset CommandInset citation
LatexCommand cite
key "vanderberg2010ps3"

\end_inset


\end_layout

\begin_layout Standard
My contributions relevant to Small Progress Measures include:
\end_layout

\begin_layout Itemize
An improvement of the basic algorithm that eliminates failed lifting attempts,
 described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Eliminating-failed-lifting"

\end_inset


\end_layout

\begin_layout Itemize
An optimization that reduces the codomain for progress measures whenever
 a vertex is lifted to 
\begin_inset Formula $\top$
\end_inset

, described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimization-after-lifting"

\end_inset


\end_layout

\begin_layout Itemize
The development of a novel lifting heuristic that reduces the number of
 lifting attempts required in many cases, described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Maximum-Measure-Propagation"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
parallel and distributed implementations?
\end_layout

\begin_layout Plain Layout
3.
 the combination of different optimizations into a single tool (which no
 other tool did)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Description 
\begin_inset CommandInset label
LatexCommand label
name "sec:SPM-Description"

\end_inset


\end_layout

\begin_layout Standard
In this section the Smal Progress Measures algorithm will be described as
 outlined by Jurdziński 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset

, using the same function names and similar definitionsfor consistency,
 but without the accompanying correctness proof.
\end_layout

\begin_layout Standard
Let's assume, without loss of generality, that we want to solve a parity
 game for player Even.
 First, a progress measure is defined as a function 
\begin_inset Formula $\rho:V\rightarrow(\mathbb{N}_{0}^{\omega}\cup\top)$
\end_inset

; a function which assigns to each vertex either a vector of nonnegative
 integers, or the special value 
\begin_inset Formula $\top$
\end_inset

 (top).
 (Lower-case Greek letters will be used to denote elements of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbb{N}_{0}^{\omega}\cup\top$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.)
\end_layout

\begin_layout Standard
On these values a comparison operator 
\begin_inset Formula $<_{i}$
\end_inset

 is defined that compares two vectors lexicographically up to (and including)
 the element with index 
\begin_inset Formula $i$
\end_inset

, with the special value 
\begin_inset Formula $\top$
\end_inset

 being considered greater than any other value.
 Formally:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{cl}
\alpha<_{i}\beta\;\Leftrightarrow\alpha\neq\top\wedge\beta=\top & \mbox{if }\ensuremath{\alpha=\top\mbox{ or }\beta=\top}\\
\exists j\leq i:\;\alpha_{j}<\beta_{j}\wedge\left(\forall k<j:\;\alpha_{j}=\beta_{j}\right) & \mbox{otherwise}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
The operator 
\begin_inset Formula $<_{i}$
\end_inset

 establishes a strict weak ordering.
 The other operators can then be defined accordingly:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha>_{i}\beta\;\Leftrightarrow\;\beta<_{i}\alpha
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha\leq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha>_{i}\beta\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha\geq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha<_{i}\beta\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha=_{i}\beta\;\Leftrightarrow\left(\alpha\leq_{i}\beta\right)\wedge\left(\alpha\geq_{i}\beta\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha\neq_{i}\beta\;\Leftrightarrow\left(\alpha<_{i}\beta\right)\vee\left(\alpha>_{i}\beta\right)
\]

\end_inset


\end_layout

\begin_layout Standard
For a finite parity game, the range of the priority function has a finite
 maximum too; without loss of generality, we can assume this range is strictly
 bounded by the game index 
\begin_inset Formula $d$
\end_inset

 (where 
\begin_inset Formula $d$
\end_inset

 is the number of priorities in the game).
 A progress measure is called 
\emph on
small
\emph default
 if its range is limited to the finite set 
\begin_inset Formula $M^{\top}=M\cup\top$
\end_inset

, where 
\begin_inset Formula $M=M_{0}\times M_{1}\times\cdots\times M_{d-1}$
\end_inset

 and 
\begin_inset Formula $M_{i}$
\end_inset

 is defined as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
M_{i}=\begin{cases}
\{0\} & \mbox{if \ensuremath{i\equiv0\mod{2}}}\\
\{0..\left|\phi^{-1}(i)\right|\} & \mbox{if \ensuremath{i\equiv1\mod{2}}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
The eventual goal of the algorithm is to calculate a particular progress
 measure which maps vertices won by Odd to 
\begin_inset Formula $\top$
\end_inset

 and vertices won by Even to non-
\begin_inset Formula $\top$
\end_inset

 values.
 (Jurdziński proves that such a progress measure exists.) A few helper functions
 are needed to specify how such a progress measure is calculated.
\end_layout

\begin_layout Standard
For a small progress measure 
\begin_inset Formula $\rho$
\end_inset

 and an edge 
\begin_inset Formula $vw\in E$
\end_inset

, the function 
\begin_inset Formula $Prog(\rho,v,w):(V\rightarrow M^{\top})\times E\rightarrow M^{\top}$
\end_inset

 determines a minimum value than can be assigned to 
\begin_inset Formula $v$
\end_inset

 if the edge 
\begin_inset Formula $vw$
\end_inset

 is included in the strategy for whichever player controls 
\begin_inset Formula $v$
\end_inset

, as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Prog(\rho,v,w)=\begin{cases}
\top & \mbox{if \ensuremath{\rho(w)=\top}, otherwise:}\\
\min_{m\in M^{\top}}m\geq_{\phi(v)}\rho(w) & \mbox{if \ensuremath{\phi(v)\equiv0\mod{2}},}\\
\min_{m\in M^{\top}}m>_{\phi(v)}\rho(w) & \mbox{if }\ensuremath{\phi(v)\equiv1\mod{2}}.
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
This function is used to define the function 
\begin_inset Formula $Lift(\rho,v):(V\rightarrow M^{\top})\times V\times(V\rightarrow M^{\top})$
\end_inset

, which updates a progress measure 
\begin_inset Formula $\rho$
\end_inset

 to reflect the optimal strategy for the controlling player of 
\begin_inset Formula $v$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Lift(\rho,v)(u)=\begin{cases}
\rho(u) & \mbox{if \ensuremath{u\neq v}}\\
\max\{\rho(v),\min_{vw\in E}Prog(\rho,v,w)\} & \mbox{if \ensuremath{u=v\ \wedge\ v\in V_{0}}}\\
\max\{\rho(v),\max_{vw\in E}Prog(\rho,v,w)\} & \mbox{if }\ensuremath{u=v\ \wedge\ v\in V_{1}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Note that this definition reflects that Even will try to minimize the progress
 measure while Odd tries to maximize it.
 Similarly, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
the function 
\begin_inset Formula $Lift(\rho,v):(V\rightarrow M^{\top})\times(V\rightarrow M^{\top})$
\end_inset

 updates a progress measure at any one vertex, if possible:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Lift(\rho)=\begin{cases}
Lift(\rho,v) & \mbox{if \ensuremath{\exists v\in V:\; Lift(\rho,v)\neq\rho},}\\
\rho & \mbox{otherwise}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
There may be different vertices 
\begin_inset Formula $v$
\end_inset

 that satisfy the precondition on the first clause; in that case, any of
 the possible vertices may be chosen.
 Since 
\begin_inset Formula $Lift(\rho)$
\end_inset

 is a monotone function on a complete lattice, it has a unique minimum fixed
 point that can be found by iterative application starting from the minimum
 element, the zero progress measure, 
\begin_inset Formula $\rho(v)=\vec{0}$
\end_inset

 for all 
\begin_inset Formula $v\in V$
\end_inset

.
 Jurdziński proves that this minimum fixed point encodes both the winning
 sets and an optimal strategy for player Even, as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W_{0}=\{v\in V:\;\rho(v)<\top\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W_{1}=\{v\in V:\;\rho(v)=\top\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\sigma_{0}(v)=w\mbox{ if }v\in V_{0}\cap W_{0}\ \wedge\ vw\in E\ \wedge\ \rho(v)=_{\phi(v)}\rho(w)
\]

\end_inset


\end_layout

\begin_layout Standard
In the last definition, the choice of 
\begin_inset Formula $w$
\end_inset

 may not be unique (though there necessarily must be one appropriate successor),
 and in that case any of the possible successors may be arbitrarily chosen
 to obtain an optimal strategy.
\end_layout

\begin_layout Section
Lifting Strategies 
\begin_inset CommandInset label
LatexCommand label
name "sub:Lifting-Strategies"

\end_inset


\end_layout

\begin_layout Standard
Jurdziński's algorithm is straightforward, but it leaves open two important
 implementation details:
\end_layout

\begin_layout Enumerate
How can we determine which vertices are liftable (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)\neq\rho$
\end_inset

) and similarly, how do we know when the minimum fixed point has been reached
 (i.e.
 when no more liftable vertices remain)?
\end_layout

\begin_layout Enumerate
When multiple vertices are liftable, which should we select to improve the
 progress measure?
\end_layout

\begin_layout Standard
Existing implementations generally follow Jurdziński's formulation, and
 just compute 
\begin_inset Formula $Lift(\rho,v)$
\end_inset

 for different vertices until they find one that changes the current progress
 measure, and when all options are eliminated, conclude that a fixed point
 has been found.
\end_layout

\begin_layout Standard
The order in which vertices are selected for (potential) lifting is not
 specified by Jurdziński's formulation, because any lifting order will lead
 to the same, unique fixed point.
 However, the order in which vertices are lifted is important in practice,
 because some sequences may be considerably shorter than others, and thus
 result in a faster calculation.
 Since the optimal lifting sequence cannot be predicted in advance, a heuristic
 approach must be used instead.
 Jurdziński already hints at the importance of using a suitable lifting
 strategy (which he calls “evaluation policy”): 
\emph on
“our algorithm can be seen as a generic algorithm allowing many different
 evaluation policies; good heuristics can potentially improve performance
 of the algorithm”
\emph default
.
\end_layout

\begin_layout Standard
This raises the question how large the gap between good and bad policies
 actually is in practice.
 Jurdziński gives an upper bound for the total number of lifts in a game
 by simply calculating the size of the small progress measure set:
\begin_inset Formula 
\[
\left|V\right|\cdot\left|M\right|=\left|V\right|\cdot\prod_{i=1}^{\left\lfloor d/2\right\rfloor }\left(\left|\phi^{-1}(2i-1)\right|+1\right)\leq\left(\frac{n}{\left\lfloor d/2\right\rfloor }\right)^{\left\lfloor d/2\right\rfloor }
\]

\end_inset


\end_layout

\begin_layout Standard
This is useful to establish the worst-case complexity but it is also an
 overapproximation: only the vertices with greatest priority values can
 be lifted 
\begin_inset Formula $\left|M\right|$
\end_inset

 times.
 A more accurate characterization takes into account the priorities of the
 vertices and how often they occur:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\prod_{p=0}^{d-1}\sum_{q=0}^{p}\left|M_{q}\right|\left|\phi^{-1}(p)\right|
\]

\end_inset


\end_layout

\begin_layout Standard
This is a tighter bound, but it can only be approached is specially crafted
 graphs, even with the worst possible lifting strategies.
 How much can be gained compared to the 
\emph on
worst
\emph default
 lifting strategies is not even very interesting; after all, we would never
 intentionally use a bad lifting strategy.
 The more interesting question to investigate is how much we can improve
 upon 
\emph on
trivial
\emph default
 lifting strategies (which may already work reasonably well in practice).
\end_layout

\begin_layout Standard
As will be discussed in detail later, it turns out that we can bound the
 overhead of a naive lifting strategy to a factor
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $\left|V\right|$
\end_inset

 in lifting attempts.
 Athough this limits the gains we can expect somewhat, the vertex set 
\begin_inset Formula $V$
\end_inset

 is large enough in practice to justify trying to minimize the lifting sequence.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(Open question: can we determine an optimal sequence with hindsight?)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Core algorithm
\end_layout

\begin_layout Standard
A 
\emph on
lifting strategy
\emph default
 is a heuristical algorithm that, depending on information available about
 a partial solution (such as the structure of the graph, the values of the
 progress measure vectors, or the history of vertices being lifted) determines
 which vertex will be selected for the next lifting attempt.
 Lifting strategies are typically stateful, and although sophisticated lifting
 strategies may cause fewer work to be done in the SPM algorithm itself
 (by reducing the number of lifting attempts performed) it is important
 to keep in mind that this may come at the cost of spending more time and
 memory on internal bookkeeping.
\end_layout

\begin_layout Standard
To talk about lifting strategies and their efficiency, it is useful to establish
 some terminology.
 A vertex for which 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)=\rho$
\end_inset

 is called stable (with respect to progress measure 
\begin_inset Formula $\rho$
\end_inset

), and unstable if 
\begin_inset Formula $Lift(\rho,v)\neq\rho$
\end_inset

.
 A lifting attempt at vertex 
\begin_inset Formula $v$
\end_inset

 consists of calculating 
\begin_inset Formula $Lift(\rho,v)$
\end_inset

 and is called succesful if 
\begin_inset Formula $Lift(\rho,v)\neq\rho$
\end_inset

 (and we can update our progress measure) and unsuccesful (or failed) otherwise.
 In other words: the set of stable vertices corresponds with the set of
 vertices at which lifting attempts would succeed.
 Finally, a vertex is called 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
dirty
\emph default
 if it has not been lifted since one of its successors has been lifted,
 and clean otherwise.
 As a result, unstable vertices are a subset of dirty vertices, and the
 difference is relevant because most implementations track 
\emph on
dirty
\emph default
 but not 
\emph on
unstable
\emph default
 vertices explicitly, and must attempt lifting of dirty vertices to determine
 whether they are stable or not.
\end_layout

\begin_layout Standard
The core algorithm can be described as a function taking a small progress
 measure that is appropriately initialized and a lifting strategy; see Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:SPM v1 Core"

\end_inset

.
 In this arrangement, the core algorithm notifies the lifting strategy of
 succesful lifts, and the lifting strategy decides both the order in which
 vertices are lifted, and signals termination when the minimum fixed point
 has been reached.
\end_layout

\begin_layout Standard
This separation of concerns exists in most previous implementations of Small
 Progress Measures and is attractive because it keeps the core algorithm
 very simple, while still allowing a sophisticated approach to be used by
 the lifting strategy.
 Of course, this also means that the performance of the algorithm depends
 crucially on the strategy chosen.
\end_layout

\begin_layout Standard
In the following, I will describe the most commonly used lifting strategies,
 and how I implemented them in my framework.
 After that, I will describe some of the improvements I made to the core
 algorithm as outlined above.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SmallProgressMeasures(spm, lifting_strategy)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    v = lifting_strategy.next()
\end_layout

\begin_layout Plain Layout

	while (v != NO_VERTEX) {
\end_layout

\begin_layout Plain Layout

        new_spm = Lift(spm, v)
\end_layout

\begin_layout Plain Layout

        if (spm[v] > new_spm[v]) {
\end_layout

\begin_layout Plain Layout

            lifting_strategy.lifted(v)
\end_layout

\begin_layout Plain Layout

            spm[v] = new_spm[v]
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        v = lifting_strategy.next()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Core Small Progress Measures Algorithm 
\begin_inset CommandInset label
LatexCommand label
name "alg:SPM v1 Core"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Linear Lifting Strategy
\end_layout

\begin_layout Standard
Arguably the most basic strategy consists of trying to lift vertices in
 order of increasing indices, repeating the process as necessary, until
 all vertices in the graph have failed to be lifted in succession.
 Its advantages are that it is simple to implement and requires very little
 time and memory to select vertices.
 The main disadvantage is that it may spend a majority of the time attempting
 (and failing) to lift vertices in stable parts of the game graph.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Linear-Lifting-Strategy"

\end_inset

 gives pseudo-code for a simple implementation of this algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

num_failed = 0
\end_layout

\begin_layout Plain Layout

next_vertex = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lifted(Vertex v) {
\end_layout

\begin_layout Plain Layout

	num_failed = 0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vertex next() {
\end_layout

\begin_layout Plain Layout

	if num_failed >= V {
\end_layout

\begin_layout Plain Layout

		return NO_VERTEX
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		num_failed = num_failed + 1
\end_layout

\begin_layout Plain Layout

		next_vertex = (next_vertex + 1) mod V
\end_layout

\begin_layout Plain Layout

		return next_vertex
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Linear Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Linear-Lifting-Strategy"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

(In Van de Pol and Weber's implementation, this approach is called 
\emph on
swiping
\emph default
.)
\end_layout

\begin_layout Standard
A variation of the strategy is to iterate vertices in reverse order.
 This can be beneficial in cases where the graph has been constructed in
 a forward fashion, so that vertices tend to have higher indices than their
 predecessors, and therefore since changes in the graph propagate from vertices
 to their predecessors, iterating in reverse may cause more vertices to
 be lifted in one pass.
 For example, in a cycle graph with vertices numbered in cycle order, iterating
 in forward direction would lift only one vertex per pass, while lifting
 in backward direction would lift all.
\end_layout

\begin_layout Standard
There are a few things we can do to minimize the number of passes executed:
\end_layout

\begin_layout Enumerate
Calculate the ratio of “forward” and “backward” edges and choose the optimal
 direction accordingly.
\end_layout

\begin_layout Enumerate
Permute vertex indices based on the order they are visited by depth-first
 or breadth-first search through the graph, which should create a more favorable
 edge ratio.
\end_layout

\begin_layout Enumerate
Alternate the direction of iteration on every pass.
\end_layout

\begin_layout Standard
The advantage of the third approach is that it does not require precalculation/p
reprocessing of the game graph.
 Compared to the first approach, it will create at most twice as much work.
 Permuting vertex indices can produce even better results, but even the
 second approach isn't guaranteed to yield optimal results.
\end_layout

\begin_layout Subsection
Predecessor Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "sub:Predecessor-Lifting-Strategy"

\end_inset


\end_layout

\begin_layout Standard
A more sophisticated lifting strategy takes into account that a known-stable
 vertex can only become unstable after the progress measure vector of one
 of its successors has been updated.
 After all, the value for one vertex depends only on the values for its
 successors.
\end_layout

\begin_layout Standard
The predecessor lifting strategy uses a set datastructure to store potentially
 unstable (“dirty”) vertices, which is initialized to all vertices in the
 graph with progress mesaures less than 
\begin_inset Formula $\top$
\end_inset

.
 A vertex is arbitrarily removed from this set to be lifted, and if this
 succeeds, its predecessors are added back into the set.
 All vertices not in the set are necessarily stable, so when the set becomes
 empty, lifting is complete.
\end_layout

\begin_layout Standard
The advantage of this strategy is that it prevents a lot of unnecessary
 lifting that may occur with the linear lifting strategy.
 In fact, the ratio of unsuccesful to succesful lifts is strictly limited
 by the maximum indegree of a vertex in the graph.
 Again, pathological cases can be constructed where this strategy performs
 badly.
 For example, when the game graph is complete (i.e.
 
\begin_inset Formula $E=V\times V$
\end_inset

) all vertices remain in the set until the game is completely solved.
 Fortunately, graphs with such properties arise rarely in practice.
\end_layout

\begin_layout Standard
The main disadvantage of the lifting strategy is that it requires maintaining
 the set of unstable vertices, which requires 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 extra memory, and extra time proportional to the average indegree of lifted
 vertices.
 In my solver, this set is implemented with a linear array of Boolean variables
 to indicate whether a vertex is in the set, and another array which acts
 as a circular queue of vertices, in order to allow constant time insertion
 and removal of vertices.
\end_layout

\begin_layout Standard
In PGSolver (which is limited to single-threaded operation) the predecessor
 lifting strategy is the only lifting strategy implemented.
 Van de Pol and Weber call this the 
\emph on
work list approach
\emph default
 but reject it in their multi-core solver because they are worried about
 the overhead involved in maintaining the necessary data structures in a
 concurrent setting.
\end_layout

\begin_layout Standard
However, in my experience, available memory is rarely the limiting factor
 when solving parity games, and the data structures used can be implemented
 efficiently even in a lock-free manner, so I think there is little reason
 to omit this strategy from a solver, even one where high performance in
 a concurrent environment is the primary concern.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
do I have a concurrent implementation?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

queued = Vector<bool>(V)
\end_layout

\begin_layout Plain Layout

queue = Queue<Vertex>()
\end_layout

\begin_layout Plain Layout

for v in [0..V) {
\end_layout

\begin_layout Plain Layout

    if not top(w) {
\end_layout

\begin_layout Plain Layout

   	queued[v] = true
\end_layout

\begin_layout Plain Layout

	   queue.push(v)
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lifted(Vertex v) {
\end_layout

\begin_layout Plain Layout

	for w in predecessors(v) {
\end_layout

\begin_layout Plain Layout

		if not queued[w] and not top(w) {
\end_layout

\begin_layout Plain Layout

			queued[w] = true
\end_layout

\begin_layout Plain Layout

			queue.push(w)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vertex next() {
\end_layout

\begin_layout Plain Layout

	if queue.empty() {
\end_layout

\begin_layout Plain Layout

		return NO_VERTEX
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		v = queue.pop()
\end_layout

\begin_layout Plain Layout

		queued[v] = false
\end_layout

\begin_layout Plain Layout

		return v
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Predecessor Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Predecessor-Lifting-Strategy"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The pseudo-code for the predecessor lifting strategy is given in Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Predecessor-Lifting-Strategy"

\end_inset

 which shows that the main datastructure used is a queue.
 Crucial to the implementation is that every vertex is queued at most once,
 which prevents attempted lifting of vertices which are not dirty, and additiona
lly allows the queue to be implemented as a fixed-length array.
 An invariant maintained by this algorithm is that the set of vertices queued
 corresponds exactly with the set of dirty vertices; 
\begin_inset Formula $\texttt{next()}$
\end_inset

 simply returns a dirty vertex until the queue becomes empty, at which point
 all vertices are necessarily stable.
\end_layout

\begin_layout Standard
There is some freedom of implementation when deciding which vertex from
 the set of potentially unstable vertices to lift next.
 My implementation uses no external information, but can be configured to
 extract vertices from the queue in a first in, first out (FIFO) or last
 in, last out (LIFO) manner, in which case the queue works like a stack.
 Extracting vertices in LIFO order may have the benefit of providing better
 cache locality, even when it doesn't reduce the number of lifts.
 The benchmark results presented later will show the performance difference
 between the two policies in practice.
\end_layout

\begin_layout Subsection
Focus List Approach
\end_layout

\begin_layout Standard
The 
\emph on
focus list approach
\emph default
 is a strategy designed by Van de Pol and Weber to mitigate some of the
 problems of the linear lifting strategy without introducing complicated
 data structures that may be hard to parallellize efficiently.
 Solving occurs by alternation of two phases of operation.
\end_layout

\begin_layout Standard
First, the algorithm iterates linearly over the vertices of the graph, putting
 vertices which are succesfully lifted on a fixed-size work list.
 When the work list is full, the second phase begins: vertices on the work
 list are assigned an initial credit value and are selected for lifting
 again.
 When lifting a vertex succeeds, its credit is incremented linearly (adding
 a constant); if it fails, it is decreased exponentially (dividing by a
 constant).
 A vertex whose credit drops below a certain threshold is removed from the
 work list.
 When the work list is empty or a predetermined amount of lifting attempts
 have been performed, the work list is cleared and the first phase is resumed.
\end_layout

\begin_layout Standard
The idea behind the work list is that it captures unstable parts of the
 graph.
 When processing the work list, either lifting attempts will have a high
 success rate, or the list will be cleared quickly, allowing new vertices
 to be selected.
 Limiting the number of attempts at this time ensures that if little progress
 is made in one part of the game (i.e.
 despite high lifting success rate, vertices do not stabilize) work will
 soon continue on some other part of the game.
\end_layout

\begin_layout Standard
Since Van de Pol and Weber are the only ones to implement this strategy,
 there is little emperical evidence available about its performance, though
 they report in 
\begin_inset CommandInset citation
LatexCommand cite
key "vandepol2008multicore"

\end_inset

 that it performs much better than linear lifting in some cases, and not
 much worse in most other cases, which suggests it meets its design goals.
 Compared to the predecessor lifting strategy, it has the advantage of being
 able to postpone difficult parts of the game, which may help in some hard
 cases.
\end_layout

\begin_layout Standard
The main downside of the strategy is that it depends on various constants
 (work list size, initial credit, credit increment, credit divisor) to work
 well.
 In Weber's implementation these are emperically derived while testing on
 random games, but it is unclear if and how these values should change for
 other types of games.
\end_layout

\begin_layout Standard
The implementation of the focus list lifting strategy is described in Algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Focus-List-Lifting"

\end_inset

.
 For clarity, the algorithm is presented as if the strategy calls the 
\begin_inset Formula $\texttt{lift()}$
\end_inset

 method directly, instead of being called from the core algorithm; this
 is the inverse of how the strategy is implemented in reality.
 (The interaction between the core algorithm and the lifting strategy would
 best be implemented as a pair of coroutines, but unfortunately few programming
 languages support coroutines properly.)
\end_layout

\begin_layout Standard
Some of the parameters in this algorithm are fixed: the initial credit (here:
 2) assigned to vertices on the focus list; the linear increment when lifting
 succeeds (again, 2); and the exponential decay when it doesn't (here: 
\begin_inset Formula $\frac{1}{2}$
\end_inset

).
 With these parameters, which were taken from van de Pol and Weber's implementat
ion, a vertex is selected for lifting at least three times, but will stay
 on the focus list longer if lifting succeeds occassionally (more precesily,
 it needs to be succesfully lifted at least once every three attempts to
 stay on the list).
 The remaining two parameters are 
\begin_inset Formula $\texttt{max\_size}$
\end_inset

 and 
\begin_inset Formula $\texttt{max\_attempts}$
\end_inset

; the maximum size of the focus list and the maximum number of lifting attempts
 performed in phase 2 before switching back to phase 1.
 These parameters can vary, but are chosen as 
\begin_inset Formula $\frac{\left|V\right|}{10}$
\end_inset

 and 
\begin_inset Formula $\left|V\right|$
\end_inset

 (respectively) by default.
\end_layout

\begin_layout Standard
In terms of overhead, the focus list implements a circular buffer with an
 array of vertex/cost pairs.
 The size of this array is equal to 
\begin_inset Formula $\texttt{max\_size}$
\end_inset

 and this is the main factor in the memory used by the strategy.
 Otherwise, the focus list lifting strategy has little overhead.
 In particular, the runtime overhead is smaller than with the predecessor
 lifting strategy.
 When the focus list is small, the algorithm additionally benefits from
 being able to keep the active parts of the game in cache memory.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

phase = 1
\end_layout

\begin_layout Plain Layout

num_attempts = 0
\end_layout

\begin_layout Plain Layout

num_failed = 0
\end_layout

\begin_layout Plain Layout

next_vertex = 0
\end_layout

\begin_layout Plain Layout

focus_list = Queue<Pair<Vertex, Int>>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while true {
\end_layout

\begin_layout Plain Layout

	num_attempts = num_attempts + 1
\end_layout

\begin_layout Plain Layout

	if (phase == 1) {
\end_layout

\begin_layout Plain Layout

		if lift(next_vertex) {
\end_layout

\begin_layout Plain Layout

			num_failed = 0
\end_layout

\begin_layout Plain Layout

			focus_list.push(<next_vertex, 2>)
\end_layout

\begin_layout Plain Layout

		} else {
\end_layout

\begin_layout Plain Layout

			num_failed = num_failed + 1
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		next_vertex = (next_vertex + 1) mod V
\end_layout

\begin_layout Plain Layout

		if num_failed == V {
\end_layout

\begin_layout Plain Layout

			break
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if num_attempts == V || focus_list.size() == max_size {
\end_layout

\begin_layout Plain Layout

			/* N.B.
 focus_list is non-empty because
\end_layout

\begin_layout Plain Layout

			        num_failed < num_attempts */
\end_layout

\begin_layout Plain Layout

			phase = 2
\end_layout

\begin_layout Plain Layout

			num_attempts = 0
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	} else {  /* phase == 2 */
\end_layout

\begin_layout Plain Layout

		v, credit = focus_list.pop()
\end_layout

\begin_layout Plain Layout

		if lift(v) {
\end_layout

\begin_layout Plain Layout

			focus_list.push(<v, credit + 2>)
\end_layout

\begin_layout Plain Layout

		} else if (credit > 0) {
\end_layout

\begin_layout Plain Layout

			focus_list.push(<v, credit / 2>)
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if focus_list.empty() || num_attempts == max_attempts {
\end_layout

\begin_layout Plain Layout

			focus_list.clear()
\end_layout

\begin_layout Plain Layout

			phase = 1
\end_layout

\begin_layout Plain Layout

			num_attempts = 0
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Focus List Lifting Strategy 
\begin_inset CommandInset label
LatexCommand label
name "alg:Focus-List-Lifting"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Maximum Measure Propagation 
\begin_inset CommandInset label
LatexCommand label
name "sub:Maximum-Measure-Propagation"

\end_inset


\end_layout

\begin_layout Standard
The maximum measure propagation strategy is a context-aware variant of the
 predecessor lifting strategy.
 It returns a vertex from the queue for which the minimum successor (for
 Even-controlled vertices) or the maximum successor (for Odd-controlled
 vertices) is maximal over all queued vertices.
 In other words: it picks a vertex such that the value assigned by a succesful
 lifting attempt is as large as possible.
 The rationale behind this strategy is that since the final progress measure
 for a vertex does not depend on the order of lifting, it makes sense to
 try to propagate higher values first rather than waste time on updating
 lower values, which might be overwritten later.
\end_layout

\begin_layout Standard
It is not difficult to imagine scenarios where this order of lifting provides
 benefit.
 For example, whenever a vertex is known to be won by player Odd (when it
 is assigned 
\begin_inset Formula $\top$
\end_inset

) all vertices in its attractor set will be set to 
\begin_inset Formula $\top$
\end_inset

 before any other vertices are lifted, since 
\begin_inset Formula $\top$
\end_inset

 is the maximal value in the graph.
 With the normal predecessor lifting strategy, these vertices might have
 been lifted multiple times before inevitably finally reaching top value.
\end_layout

\begin_layout Standard
Maximum measure propagation can be viewed as a context-aware variant of
 predecessor lifting in that it still returns vertices from a queue, but
 rather than using insertion order to determine which vertex to lift next,
 it considers the values assigned to vertices so far.
\end_layout

\begin_layout Standard
Three variations of this idea are implemented:
\end_layout

\begin_layout Enumerate
Maximum measure metric: prioritize vertices with 
\emph on
greatest
\emph default
 successor value (described above)
\end_layout

\begin_layout Enumerate
Maximum step metric: prioritize vertices with 
\emph on
greatest difference
\emph default
 compared to their successor
\end_layout

\begin_layout Enumerate
Minimum measure: prioritize vertices with 
\emph on
least
\emph default
 successor value
\end_layout

\begin_layout Standard
As with predecessor lifting, ties between queued vertices can be broken
 in two ways based on insertion order.
 (Predecessor lifting itself can be viewed as a variant that does not prioritize
 queued vertices at all.)
\end_layout

\begin_layout Standard
A disadvantage of the context-aware lifting strategy is that it incurs more
 overhead, since a priority queue data structure must be maintained in order
 to efficiently select vertices for lifting.
 An in-place binary heap of vertex indices is used for this purpose, while
 the predecessor lifting strategy required only a circular buffer.
 The overhead incurred by maintaining the heap can be alleviated somewhat
 by removing the insertion-order tie-breaking rule (so that queued vertices
 are only partially ordered).
\end_layout

\begin_layout Standard
The in-place heap itself causes no memory overhead compared to a circular
 buffer, but requires more work to keep it balanced, especially since the
 proper position of a vertex in the heap depends not only on the value assigned
 to it, but also on the values assigned to its successor vertices.
 That means that whenever a vertex is removed from the queue to be lifted,
 the heap structure may be invalidated at multiple locations.
 To resolve this, the predecessors of the lifted vertex must be located
 in the heap and be moved up (for the maximum measure and step metric) or
 down (for the minimum measure metric) in the heap as necessary to restore
 the heap property.
 This necessitates storing the position of queued vertices in the heap.
 Finally, restoring the heap property requires that vertices are processed
 in the correct order based on their position in the heap: when moving vertices
 up, vertices higher in the heap should be processed first.
\end_layout

\begin_layout Standard
From the above description, it should be clear that maximum measure propagation
 (and its variants) is quite a bit more complicated than simple predecessor
 lifting, both in terms of implementation difficulty and the amount of computati
onal overhead added to each lifting attempt.
 However; this might be worth it if the final progress measure can be computed
 more quickly.
 This will be assessed later on.
\end_layout

\begin_layout Section
Improvements
\end_layout

\begin_layout Standard
Apart from choosing better lifting strategies, improvements to the core
 algorithm are possible too.
 I will discuss the improvements I implemented below; some are novel, and
 others have been previously implemented.
\end_layout

\begin_layout Subsection
Eliminating failed lifting attempts 
\begin_inset CommandInset label
LatexCommand label
name "sub:Eliminating-failed-lifting"

\end_inset


\end_layout

\begin_layout Standard
When implementing some of the more sophisticated lifting strategies (such
 as the predecessor- and maximum-measure strategies) it became apparant
 that the core algorithm as described in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:SPM v1 Core"

\end_inset

 (and as implemented in all tools that I know of) is not as efficient as
 it could be.
 To determine if a vertex is stable, it must be lifted.
 In order to lift it, the minimum (or maximum) successor must be found,
 and its progress measure vector must be compared with that of the predecessor.
 Many of these comparisons can be avoided if the core algorithm keeps track
 of the relevant minimum/maximum successor for each vertex.
\end_layout

\begin_layout Standard
For example, if there is a vertex 
\begin_inset Formula $v$
\end_inset

 controlled by Even, and one of its successors (say: 
\begin_inset Formula $w$
\end_inset

) is lifted, this affects 
\begin_inset Formula $v$
\end_inset

's stability if (and only if) 
\begin_inset Formula $w$
\end_inset

 is the current minimum successor for 
\begin_inset Formula $v$
\end_inset

.
 Without retaining this information, however, the only way of knowing whether
 
\begin_inset Formula $v$
\end_inset

's progress measure vector is too low is to re-examine the vectors assigned
 to each of 
\begin_inset Formula $v$
\end_inset

's successors.
\end_layout

\begin_layout Standard
Failed lifting attempts can be eliminated completely by storing for each
 vertex whether it  is stable and what its current minimum/maximum successor
 is.
 This requires O(
\begin_inset Formula $V$
\end_inset

) extra space in the core algorithm, but simplifies lifting strategy implementat
ion.
 Additionally, at the end of the algoritm, the minimum successors form an
 optimal strategy for Even.
\end_layout

\begin_layout Standard
Effectively, this turns the core algorithm inside out: instead of checking
 the successors of a vertex to see if it can be lifted, we only lift known-unsta
ble vertices and then check its predecessors to see if any of them are destabili
zed by the change.
 This may first appear to be a rather trivial variation, and while it is
 true it doesn't change the worst-case performance of the algorithm, the
 fundamental difference is that it eliminates many redundant progress measure
 vector comparisons.
\end_layout

\begin_layout Standard
It should be clear that the amount of work done per lifting attempt is roughly
 equal on average for both formulations of the core algorithm: while the
 original formulation requires examining all successors of the vertex being
 lifted, this variant examines its predecessors instead.
 However, since this variant algorithm eliminates all failed lifting attempts
 (which make up a considerable part of lifting attempts in most test cases)
 this variation is faster in practice.
\end_layout

\begin_layout Standard
I will call the earlier formulation of the core algorithm the “standard
 framework” since it matches Jurdziński's description and is implemented
 in earlier solving tools, and call this variation the “improved framework”
 since it turns out (as will be shown in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Empirical-Evaluation"

\end_inset

) that moving the responsibility of tracking stable vertices from the lifting
 strategy to the core algorithm is a strict improvement, at least for lifting
 strategies that are at least as sophisticated as the predecessor lifting
 strategy.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
pseudo-code of SmallProgressMeasures2?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

for (verti v = 0; v < V; ++v) {
\end_layout

\begin_layout Plain Layout

	if (is_top(v)) {
\end_layout

\begin_layout Plain Layout

		stable[v] = true;
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		if v is controlled by Even:
\end_layout

\begin_layout Plain Layout

			strategy[v] = minimum successor
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			strategy[v] = maximum successor
\end_layout

\begin_layout Plain Layout

		stable[v]  = !(spm[v] <? spm[strategy[v]])
\end_layout

\begin_layout Plain Layout

		if (!stable[v]) q.push(v);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while (!queue.empy())
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	verti w = queue.pop()
\end_layout

\begin_layout Plain Layout

	for each predecessor v:
\end_layout

\begin_layout Plain Layout

		if v is not top:
\end_layout

\begin_layout Plain Layout

			if v controlled by Even:
\end_layout

\begin_layout Plain Layout

				if strategy[v] = w:
\end_layout

\begin_layout Plain Layout

					strategy[v] = get_min_succ(v)
\end_layout

\begin_layout Plain Layout

					stable[v] = !(spm[v] <? spm[strategy[v]])
\end_layout

\begin_layout Plain Layout

			if v is controlled by Odd:
\end_layout

\begin_layout Plain Layout

				if strategy[v] = w or spm[w] > spm[strategy[v]]:
\end_layout

\begin_layout Plain Layout

					strategy[v] = w
\end_layout

\begin_layout Plain Layout

					stable[v] = !(spm[v] <? spm[strategy[v]])
\end_layout

\begin_layout Plain Layout

			if !stable[v]:
\end_layout

\begin_layout Plain Layout

				queue.push(v)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SPMv2 (TODO)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Optimization after lifting to top 
\begin_inset CommandInset label
LatexCommand label
name "sub:Optimization-after-lifting"

\end_inset


\end_layout

\begin_layout Standard
The implemention of 
\begin_inset Formula $\texttt{lift}$
\end_inset

 follows the descripton given in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SPM-Description"

\end_inset

, but with one important enhancement: whenever a vertex with odd priority
 
\begin_inset Formula $p$
\end_inset

 is lifted to 
\begin_inset Formula $\top$
\end_inset

, the value of 
\begin_inset Formula $M_{p}$
\end_inset

 is decreased by 1.
 As a result, during solving, 
\begin_inset Formula $M$
\end_inset

 is effectively determined by the cardinalities of only those vertices with
 progress measures less than 
\begin_inset Formula $\top$
\end_inset

.
 Note that this may cause some progress measure vectors to temporarily exceed
 the new vector bounds 
\begin_inset Formula $M'$
\end_inset

, but this will be resolved when the vertex is lifted, as it necessarily
 must (see below).
\end_layout

\begin_layout Standard
This enhancement is not described by Jurdziński and not implemented in any
 of the other solvers based on Small Progress Measures, to my knowledge;
 all of these assume 
\begin_inset Formula $M$
\end_inset

 to be constant during solving.
 It was invented specifically to remedy cases where the dual solving approach
 (described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Two-sided-SPM"

\end_inset

) would perform worse compared to the approach of solving the normal and
 dual game in succession.
 These cases arise because in the latter approach vertices won by Even (in
 the normal game) are removed from the dual game before solving, which reduces
 the complexity of the second problem.
 With the two-sided approach no vertices are ever removed, which could cause
 the dual game to have significantly higher bounds on the progress measure
 codomain 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
Besides eliminating this disadvantage in the dual-solving approach, the
 enhancement also benefits the regular algorithm.
\end_layout

\begin_layout Subsubsection
Correctness
\end_layout

\begin_layout Standard
In Small Progress Measures, non-
\begin_inset Formula $\top$
\end_inset

 vectors encode an optimal strategy for Even; informally, the elements of
 the vectors encode how many vertices with odd priorities can be visited
 consecutively in a winning play before encountering a vertex with a lesser
 priority.
 Since vertices which are assigned 
\begin_inset Formula $\top$
\end_inset

 value (i.e.
 which are won by Odd) cannot be part of a winning play for Even, they will
 be excluded from this count, and therefore the least fixed point will necessari
ly have all vectors within the reduced bounds.
\end_layout

\begin_layout Standard
To fit this optimization into Jurdziński's framework, we should introduce
 a smaller set of progress measures
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $M'(\rho)$
\end_inset

 the bounds of which are dependent on the count of 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
non-
\begin_inset Formula $\top$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 vertices in the partially-constructed progress measure 
\begin_inset Formula $\rho$
\end_inset

:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula 
\[
M'_{i}(\rho)=\begin{cases}
\{0\} & \mbox{if \ensuremath{i\equiv0\mod{2}}}\\
\{0..\left|\phi^{-1}(i)\setminus\rho^{-1}(\top)\right|\} & \mbox{if \ensuremath{i\equiv1\mod{2}}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Clearly, 
\begin_inset Formula $M'(\rho)\subseteq M$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 Then, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $Prog'(\rho,v,w)$
\end_inset

 can be defined like 
\begin_inset Formula $Prog(\rho,v,w)$
\end_inset

 but drawing from 
\begin_inset Formula $M'(\rho)$
\end_inset

 instead of 
\begin_inset Formula $M$
\end_inset

, and similarly 
\begin_inset Formula $Lift'(\rho,v)$
\end_inset

 can be defined in terms of 
\begin_inset Formula $Prog'(\rho,v,w)$
\end_inset

 instead of 
\begin_inset Formula $Prog(\rho,v,w)$
\end_inset

.
 At this point, Jurdzińksi's theorems apply equally to 
\begin_inset Formula $Prog'(\rho,v,w)$
\end_inset

.
 In particular, the monotonicity of the lifting function is preserved and
 thus fixed point iteration can still be used to find a minimal fixed point
 of 
\begin_inset Formula $Lift'(\rho,v)$
\end_inset

 that yields an optimal solution for Even.
\end_layout

\begin_layout Standard
A more intuitive way to see that decreasing the progress measure bounds
 is permissible, even without fixing any vectors that are now out of range,
 consider that if vertex 
\begin_inset Formula $v$
\end_inset

 with priority 
\begin_inset Formula $p$
\end_inset

 is set to 
\begin_inset Formula $\top$
\end_inset

, then 
\begin_inset Formula $v\in W_{1}$
\end_inset

 and thus 
\begin_inset Formula $Attr^{1}(\left\{ v\right\} )\subseteq W_{1}$
\end_inset

 and we could solve the subgame induced by 
\begin_inset Formula $V\setminus Attr^{1}(\left\{ v\right\} )$
\end_inset

 with associated bounds 
\begin_inset Formula $M"$
\end_inset

 instead.
 However, since 
\begin_inset Formula $M"{}_{p}\subseteq M_{p}'$
\end_inset

 and since we compute a minimum fixed point in both cases, the final progress
 measures vectors must be the same for corresponding vertices in both games.
 This guarantees that the final value of all vectors will lie in 
\begin_inset Formula $M"{}^{\top}$
\end_inset

.
 (Note that attractor set computation achieves the same effect as propagating
 
\begin_inset Formula $\top$
\end_inset

 values as usual.)
\end_layout

\begin_layout Subsection
Game/Graph Preprocessing
\end_layout

\begin_layout Standard
Instead of improving SPM itself, there are a few transformations that can
 be applied to the parity game before passing it to the solver.
 These preprocessing operations are intended to be relatively cheap compared
 to solving the game itself (at least in the worst case).
\end_layout

\begin_layout Subsubsection
Loop removal 
\begin_inset CommandInset label
LatexCommand label
name "sub:Loop-removal"

\end_inset


\end_layout

\begin_layout Standard
One peculiarity of Small Progress Measures is that it may spend a lot of
 time lifting vertices with high priority values which lie on a cycle.
 The most typical example of this is a vertex which is controlled by player
 Odd, has a high, odd priority and a loop as its only edge.
 The final progress measure for such a vertex will obviously be 
\begin_inset Formula $\top$
\end_inset

 (since Odd will keep the token at this vertex indefinitely), but its progress
 measure will change only in small increments, requiring many lifts to reach
 its final value.
\end_layout

\begin_layout Standard
Something similar occurs for vertices of odd priority which are controlled
 by Even.
 Although these cannot be initialized to 
\begin_inset Formula $\top$
\end_inset

 (they may still be won by Even) we can discard the loop edge to speed up
 propagation of values from successor vertices through this vertex.
\end_layout

\begin_layout Standard
All known implementations of Small Progress Measures do some form of preprocessi
ng where such cases are detected and the progress measures of vertices won
 by Odd are set to 
\begin_inset Formula $\top$
\end_inset

 before running the main algorithm.
 Four cases can be distinguished based on the controller and parity of a
 vertex, as summarized in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SPM-preprocessing"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Player
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Priority
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Winner
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loop edge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Other edges
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
undecided
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
undecided
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\top$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Preprocessing of vertices with loops
\begin_inset CommandInset label
LatexCommand label
name "tab:SPM-preprocessing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Note that when a vertex has only one outgoing edge, then it can be considered
 to belong to either player; in this case it's most beneficial to assign
 it to the player corresponding to the parity of its priority.) There are
 different ways to use this information; the simplest is to remove the useless
 edges and initialize the progress measure vector to 
\begin_inset Formula $\top$
\end_inset

 for the fourth case, and then solve the rest of the game as usual.
\end_layout

\begin_layout Standard
It should be noted that in two of the four cases, it is known to which winning
 set the vertex belongs, and the associated strategy is to use the loop
 back to the vertex.
 A simple extension is then to collect sets of these vertices for each player,
 and extend these to their attractor sets, to obtain a larger subset of
 vertices that are completely solved and can be removed from the game entirely.
 The resulting game graph then has no more loops.
\end_layout

\begin_layout Subsubsection
Winner-controlled cycle removal 
\begin_inset CommandInset label
LatexCommand label
name "sub:Winner-controlled-cycle-removal"

\end_inset


\end_layout

\begin_layout Standard
In his solver, Freark van der Berg introduced a more sophisticated version
 of the loop removal process described above.
 He searches for cycles of vertices controlled by Odd with odd priority,
 using a depth-first-search approach limited to a relatively shallow depth
 (8, in his experiments).
 This results in detection of small cycles only but despite this limitation,
 his benchmark results show that this already provides significant benefits
 over the removal of loops only; at least in large unclustered random games,
 where small cycles are common.
\end_layout

\begin_layout Standard
This idea can be improved upon in several ways:
\end_layout

\begin_layout Enumerate
Search for cycles of any size (not just small ones).
\end_layout

\begin_layout Enumerate
Don't limit the search to fixed parity vertices: only the parity of the
 least priority of a cycle matters; if that matches the controlling player,
 the priorities for the other vertices is irrelevant.
\end_layout

\begin_layout Enumerate
Search for cycles controlled by Even as well as Odd.
\end_layout

\begin_layout Standard
The last generalization does not reduce the progress measure bounds, but
 it is still useful because it is a quick way to solve part of the winning
 set of player Even.
\end_layout

\begin_layout Standard
The general process is called 
\emph on
winner-controlled cycle removal
\emph default
; i.e.
 removal of all cycles which are entirely controlled by the player corresponding
 to the dominant priority.
 To find these cycles, depth-first searching through all cycles in the graph
 would be too slow, but fortunately there is a more efficient solution,
 which is similar to the approach used to verify strategies.
\end_layout

\begin_layout Standard
To detect all 
\begin_inset Formula $i$
\end_inset

-cycles controlled by player 
\begin_inset Formula $p$
\end_inset

 (where 
\begin_inset Formula $p\equiv i\mod{2})$
\end_inset

 in the graph, construct the subgraph induced by the vertices controlled
 by 
\begin_inset Formula $p$
\end_inset

 with priority greater than or equal to 
\begin_inset Formula $i$
\end_inset

.
 (Vertices controlled by 
\begin_inset Formula $1-p$
\end_inset

 with outdegree 1 may be considered controlled by 
\begin_inset Formula $p$
\end_inset

 for this purpose.) Decompose the graph into strongly connected components.
 Vertices with priority 
\begin_inset Formula $i$
\end_inset

 that occur in a connected component with at least one edge (i.e.
 either the component contains at least two vertices or the vertex has a
 loop) are part of a cycle with dominant priority 
\begin_inset Formula $i$
\end_inset

.
 If we collect one such vertex per component (if one exists) and then compute
 the attractor set for these vertices, we have identified all vertices which
 either lie on 
\begin_inset Formula $p$
\end_inset

-controlled 
\begin_inset Formula $i$
\end_inset

-cycles or in their attractor set.
\end_layout

\begin_layout Standard
Strategies can be constructed as follows.
 For each vertex in the initial vertex set, pick an arbitrary successor
 
\emph on
in the same component
\emph default
.
 The rest of the strategy is generated as part of attractor set computation.
 Finally, we can extend the winning regions identified in the subgame to
 the attractor set in the global game.
 All vertices identified this way are solved and may be removed from the
 game.
\end_layout

\begin_layout Standard
It may appear redundant to compute attractor sets twice, but it is necessary
 to construct correct strategies.
 The first computation is necessary to construct the 
\begin_inset Formula $i$
\end_inset

-cycles that are winning for player 
\begin_inset Formula $p$
\end_inset

, creating a valid strategy for all solved vertices, while the second calculatio
n extends the solution as far as possible, which is necessary to guarantee
 the remaining subgame is a proper game.
\end_layout

\begin_layout Standard
To find winning cycles for all priorities, the process outlined above is
 simply repeated for each priority in the game.
 Every iteration requires constructing a subgraph with the appropriate vertices,
 decomposing it into strongly connected components, computing the attractor
 set in that subgraph, again in the original game, and finally computing
 a subgame with the remaining vertices.
 Using appropriate data structures, each of these operations takes at most
 time linear in the number of the edges in the graph, for a total runtime
 complexity of 
\begin_inset Formula $O(dE)$
\end_inset

.
\end_layout

\begin_layout Standard
This is considerably more than the 
\begin_inset Formula $O(E)$
\end_inset

 time required for winner-controlled loop removal only, but the potential
 benefits are much larger too, making this preprocessing step useful in
 practice.
 Although cycle removal makes loop removal obsolete (since loops are simply
 very short cycles) it may still be beneficial to run the loop-removal routine
 first to remove winner-controlled loops (and vertices in their attractor
 set) more quickly than the more general procedure could.
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

winner_controlled_cycles(ParityGame game, Strategy strategy)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Set<Vertex> solved
\end_layout

\begin_layout Plain Layout

	Strategy strategy
\end_layout

\begin_layout Plain Layout

	Priority p = 0
\end_layout

\begin_layout Plain Layout

	while p < game.d {
\end_layout

\begin_layout Plain Layout

		ParityGame subgame = game.make_subgame({ v in game.graph.V
\end_layout

\begin_layout Plain Layout

			where (v not in solved) and game.priority(v) >= p) and
\end_layout

\begin_layout Plain Layout

			        ( game.player(v) == p mod 2 or
\end_layout

\begin_layout Plain Layout

				      game.graph.outdegree(v) == 1 ) })
\end_layout

\begin_layout Plain Layout

		Set<Vertex> won = { }
\end_layout

\begin_layout Plain Layout

		for each SCC of subgraph {
\end_layout

\begin_layout Plain Layout

			for edge (v,w) in SCC {
\end_layout

\begin_layout Plain Layout

				if subgame.priority(v) == p {
\end_layout

\begin_layout Plain Layout

					if game.player(v) == p mod 2 {
\end_layout

\begin_layout Plain Layout

						strategy[v] = w
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					won.insert(v)
\end_layout

\begin_layout Plain Layout

					break
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		make_attractor_set(subgame, p mod 2, won, strategy)
\end_layout

\begin_layout Plain Layout

		solved.add(won)
\end_layout

\begin_layout Plain Layout

		make_attractor_set(game, p mod 2, solved, strategy)
\end_layout

\begin_layout Plain Layout

		p = p + 1
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return solved
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Winner-controlled cycle removal 
\begin_inset CommandInset label
LatexCommand label
name "alg:Winner-controlled-cycle-removal"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Decomposition into strongly-connected components
\end_layout

\begin_layout Standard
If the game graph contains multiple strongly-connected components, the game
 can be solved in smaller chunks by identifying these components and then
 solving them individually in reverse topological order (i.e.
 starting with components without outgoing edges).
 The question then becomes how to handle edges between components, since
 a subgame induced by a component with outgoing edges may not be a proper
 game.
 A simple approach is to collapse the winning sets of solved components
 into single vertices, but more can be gained by extending winning regions
 identified in one component into attractor sets which may extend into other
 areas of the graph and yield solutions for those vertices basically for
 free.
\end_layout

\begin_layout Standard
This approach can be taken even further by recursively decomposing components
 in the main graph that have been partially solved in the above way.
 This approach is taken in PGSolver and for ease of comparison also in my
 own tool, but it should be noted that it's not strictly an improvement
 of the above method.
 There may be cases where decomposition yields a large component every time,
 and then solving the whole game would take 
\begin_inset Formula $O(EV)$
\end_inset

 time and 
\begin_inset Formula $O(V)$
\end_inset

 invocations of the underlying solver, which sounds good considering the
 worst-case complexity of most solvers, but may be rather slow in practice.
\end_layout

\begin_layout Standard
To prevent such degenerate cases my implementation limits the maximum recursion
 depth in the component solver (which has the additional benefit of preventing
 the solver from crashing due to stack overflow).
\end_layout

\begin_layout Subsubsection
Priority propagation
\end_layout

\begin_layout Standard
Finally, a simple preprocessing step that can be applied to speed up solving
 with Small Progress Measures (and possibly other algorithms as well), is
 a process called 
\emph on
priority propagation
\emph default
 (a term suggested in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

 though the concept already appears in 
\begin_inset CommandInset citation
LatexCommand cite
key "antonik2009polynomial"

\end_inset

): we can replace the priority assigned to a vertex with the greatest priority
 among its successors, if the latter is less than the former, without affecting
 winning sets or optimal strategies in the game, and similarly for the predecess
ors of a vertex.
 (Friedmann & Lange distinguish the two cases by calling them 
\emph on
backwards
\emph default
 and 
\emph on
forwards propagation
\emph default
 respectively, though there seems to be little reason to apply one process
 but not the other.)
\end_layout

\begin_layout Standard
This can be seen to be correct by considering that in a finite graph, if
 a play passes through a vertex infinitely often, it must also pass through
 at least one of its successors infinitely often.
 When the vertex priority is greater than all of its successors', then it
 cannot be the dominant priority of the play, so it can be safely decreased.
 The same argument applies to predecessors, of course.
\end_layout

\begin_layout Standard
The rationale for applying this transformation before running SPM is that
 it tends to shift the distribution of priorities towards lower values (since
 lower values can replace higher values, but not the other way around),
 which could reduce the number of different possible small progress measure
 values (i.e.
 the size of the set 
\begin_inset Formula $M$
\end_inset

) and make vector comparisons/updates slightly faster, since the prefixes
 operated on are shorter on average.
\end_layout

\begin_layout Standard
In practice the performance gain derived from priority propagation appears
 to be small, as has also been noted by Keiren in 
\begin_inset CommandInset citation
LatexCommand cite
key "keiren2009"

\end_inset

.
 Friedmann & Lange report that 
\emph on

\begin_inset Quotes eld
\end_inset

emperically, the use of priority propagation turns out to be harmful
\begin_inset Quotes erd
\end_inset


\emph default
, though their emperical data is not presented, so it is unclear whether
 they mean that the time spend preprocessing the graph exceeds the time
 saved during solving, or whether priority propagation actually makes the
 game harder to solve.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
experiment!
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Vertex reordering
\end_layout

\begin_layout Standard
The vertices of a graph are not intrinsically ordered.
 However, algorithms that iterate over vertices one by one (such as the
 linear lifting strategy) must assign some order to the vertices, at least
 implicitly.
\end_layout

\begin_layout Standard
With Small Progress Measures, information is propagated backwards against
 the direction of edges: when a vertex is lifted, this may cause some of
 its predecessors to become unstable and suitable for lifting too.
 As a result, the linear lifting strategy is more efficient when vertices
 are ordered such that predecessors are lifted after their successors.
 In order to make such algorithms more efficient, my tool supports several
 options to reorder vertices before running the solving algorithm:
\end_layout

\begin_layout Enumerate
Re-order vertices by depth-first search order.
\end_layout

\begin_layout Enumerate
Re-order vertices by breadth-first search order.
\end_layout

\begin_layout Enumerate
Reverse the order of vertices.
\end_layout

\begin_layout Standard
Reversing the order of vertices is useful when the graph has been constructed
 in a forward fashion, which occurs for example when exploring a state space
 explicitly.
 These reordering operations can also be combined; for example, it may make
 sense to use reverse search order to maximize the ratio of backward to
 forward edges.
\end_layout

\begin_layout Standard
Although vertex reordering makes little difference in practice, it is a
 cheap preprocessing pass that is useful to have as an option.
\end_layout

\begin_layout Subsection
Two-sided SPM 
\begin_inset CommandInset label
LatexCommand label
name "sub:Two-sided-SPM"

\end_inset


\end_layout

\begin_layout Standard
A noteworthy variant of the Small Progress Measures algorithm was implemented
 by Oliver Friedmann in PGSolver, although it has not been described in
 literature.
 In this case, the algorithm is not run for one player at a time, but for
 both players at once.
 In Friedmann's implementation this means that a single vertex is selected,
 and it is lifted both in the normal game and its dual, and if either attempt
 succeeds, the predecessor vertices are queued.
 Effectively, the queue is shared between the two games.
 Conceivably, the two games could be processed independently, even in parallel
 on separate machines.
\end_layout

\begin_layout Standard
Periodically (in the current implementation after every 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifting attempts) information about winning vertices is exchanged between
 the games, by conservatively identifying vertices in one game that are
 won by the player for which we are computing the strategy, and setting
 the progress measures of these vertices to 
\begin_inset Formula $\top$
\end_inset

 in the corresponding dual game for his opponent.
 These vertices are identified as follows.
\end_layout

\begin_layout Standard
Without loss of generality, assume we are computing the strategy for player
 Even.
 Then, we add a mark to every vertex for which any of the following conditions
 apply:
\end_layout

\begin_layout Enumerate
Its progress measure is 
\begin_inset Formula $\top$
\end_inset


\end_layout

\begin_layout Enumerate
The vertex is controlled by Even and either:
\end_layout

\begin_deeper
\begin_layout Enumerate
all of its successors are marked; or
\end_layout

\begin_layout Enumerate
its progress measure is less than (or equal to, if the vertex priority is
 odd) all of its unmarked successors
\end_layout

\end_deeper
\begin_layout Enumerate
The vertex is controlled by Odd and either:
\end_layout

\begin_deeper
\begin_layout Enumerate
one of its successors is marked; or
\end_layout

\begin_layout Enumerate
its progress measure is less than (or equal to, if the vertex priority is
 odd) one of its successors
\end_layout

\end_deeper
\begin_layout Standard
Here, 
\begin_inset Quotes eld
\end_inset

less
\begin_inset Quotes erd
\end_inset

 means less with respect to the priority of the current vertex.
 Note that these conditions are consistent with the usual criteria for lifting
 vertices, where the marked vertices are considered to be set to 
\begin_inset Formula $\top$
\end_inset

.
 The interpretation of the marks is that marked vertices may be won by Odd,
 and unmarked vertices are known to be won by Even.
 The unmarked vertices therefore are a subset of the winning set of Even,
 and the corresponding vertices in the dual game being solved for Odd can
 be set 
\begin_inset Formula $\top$
\end_inset

.
 The same process can, of course, be applied for Odd in the dual game to
 get vertices which should be set to 
\begin_inset Formula $\top$
\end_inset

 in Even's game.
\end_layout

\begin_layout Standard
To compute a maximal set of marked vertices, a similar approach as in the
 main SPM algorithm is used: all vertices are queued, checked against the
 properties mentioned above, and whenever a mark is add to a vertex, its
 predecessors must be re-examined, so they are queued again.
 The difference with the main SPM algorithm is that a mark can be added
 only once, which bounds the total processing time to the number of edges
 in the graph.
\end_layout

\begin_layout Standard
The rationale for propagating this information  every 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifting attempts is that this amortizes the overhead involved against the
 work done lifting vertices, so that the worst-case complexity remains unchanged.
\end_layout

\begin_layout Standard
There is some similarity with Schewe's “big steps
\begin_inset Quotes erd
\end_inset

 approach 
\begin_inset CommandInset citation
LatexCommand cite
key "schewe2007solving"

\end_inset

 to solving parity games, which also tries to find small winning regions
 first in order to reduce the rest of the problem to simpler terms.
 The similarity is that both approaches provide a way to avoid “getting
 stuck” repeatedly lifting vertices by very small increments.
 Schewe achieves this by using reduced progress measure bounds to find small
 winning regions, obtaining only a partial solution using Small Progress
 Measures, and relies on the recursive algorithm (see chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Zielonka's-Recursive-Algorithm"

\end_inset

) to solve the remainder of the game.
\end_layout

\begin_layout Standard
The two-sided approach solves games entirely with Small Progress Measures
 and is therefore simpler than Schewe's, but doesn't improve performance
 in the worst-case performance.
 (It should be noted however, that in PGSolver the two approaches are combined:
 the “big steps” solver uses the SPM implementation with the two-sided optimizat
ion.)
\end_layout

\begin_layout Subsubsection
Advantages & Disadvantages
\end_layout

\begin_layout Standard
In practice, a game and its dual are often not of the same difficulty.
 In that case, it makes sense to try to solve them both, in order to discover
 the solution to the easiest one, and then use the information gained to
 construct a subgame with the remaining unsolved vertices in the dual game,
 which is then usually much easier to solve.
 The extra amount of work done in this case is at most equal to the amount
 of work done for the easiest game, but with the benefit that we do not
 have to know or guess in advance which of the players is easier to solve
 for.
\end_layout

\begin_layout Standard
The second advantage of Friedmann's two-sided approach compared to solving
 a game and its dual independently, is that it can propagate information
 between games even when neither is completely solved.
 This is useful because even in cases where both games are equally hard,
 they each may contain small regions that can be solved relatively easily
 and then used to simplify the other game.
\end_layout

\begin_layout Standard
There may be rare cases where none of the benefits apply.
 In that case, up to twice as much work may be spent on lifting vertices,
 and some additional overhead is incurred searching for stable regions in
 the games.
 Since the cost of this search can be amortized against the time spent on
 lifting, the worst-case slowdown can be brought arbitrarily close to a
 factor of 2.
\end_layout

\begin_layout Subsubsection
Implementation differences
\end_layout

\begin_layout Standard
Though the observation that the two-sided approach could use, at worst,
 twice as much time and space as the standard algorithm may seem obvious,
 it is actually not automatically true.
 Perhaps surprisingly, PGSolver can take orders of magnitude longer to solve
 games with the two-sided approach than without it.
 The cause of this is that that PGsolver omits construction of subgames
 entirely, even after one of the sides is completely solved, and consequently
 does not benefit from a reduction in progress measure bounds that occurs
 when constructing a subgame for the harder part of the game.
 This problem is rectified by reducing progress measure vector bounds whenever
 vertices are lifted to 
\begin_inset Formula $\top$
\end_inset

 (rather than calculating these bounds once, before starting solving), which
 is a new optimization that will be described in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimization-after-lifting"

\end_inset

.
\end_layout

\begin_layout Standard
Another difference between PGSolver and my implementation is that PGSolver
 uses a single lifting strategy for both the normal and dual game, and when
 lifting vertices, recomputes progress measures for both games at once.
 Although that works, it seems plausible that the sets of liftable vertices
 in the normal and dual game will diverge, so it seems more reasonable to
 instantiate separate lifting strategies for the two games in order to do
 more useful work.
\end_layout

\begin_layout Standard
Finally, in an attempt to propagate information about losing vertices earlier,
 my solver attempts 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifts in one game, before propagating information and switching to the
 dual game (rather than performing 
\begin_inset Formula $2\left|V\right|$
\end_inset

 lifting attempts in total before propagating information in both directions).
\end_layout

\begin_layout Standard
Of these three differences, the first is crucial for optimal performance,
 while the other two are at best small improvements over Friedmann's implementat
ion.
\end_layout

\begin_layout Section
Distributed implementation
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Partition graph, process independently, propagate changes at overlapping
 vertices.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Zielonka's Recursive Algorithm 
\begin_inset CommandInset label
LatexCommand label
name "chap:Zielonka's-Recursive-Algorithm"

\end_inset


\end_layout

\begin_layout Standard
An entirely different approach to solving parity games arises from a constructiv
e proof of the existince of memoryless strategies by Wiesław Zielonka in
 
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset

.
 It is presented solely as a proof, not as an efficient algorithm, but it
 has been shown (e.g.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

 and in 
\begin_inset CommandInset citation
LatexCommand cite
key "keiren2009"

\end_inset

) to work well as an actual solver too.
\end_layout

\begin_layout Standard
Zielonka's formulation of the algorithm is based on previous work by McNaughton
 
\begin_inset CommandInset citation
LatexCommand cite
key "mcnaughton1993infinite"

\end_inset

.
 The main difference is that McNaughton limits himself to finite graphs,
 while Zielonka concerns himself with infinite graphs as well.
 Beauces of their fundamental similarity, Zielonka's algorithm is sometimes
 referred to as McNaughton's algorithm in literature on parity games.
\end_layout

\begin_layout Standard
The algorithm is based on a proof by induction on the number of different
 priorities: when there is a single priority, the game is trivially solved
 (this is the basis for the induction).
 Then, assuming that we can solve any game with 
\begin_inset Formula $d$
\end_inset

 priorities, we can solve any game with 
\begin_inset Formula $d+1$
\end_inset

 priorities as follows.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename illustrations/zielonka-steps.svg
	lyxscale 50
	width 17cm

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
One iteration of Zielonka's algorithm 
\begin_inset CommandInset label
LatexCommand label
name "fig:zielonka-steps"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Without loss of generality (using priority compression if necessary) suppose
 we start with a game 
\begin_inset Formula $\Gamma$
\end_inset

 with some vertices having priority 0.
 Then, we can compute the attractor set of these vertices for player Even
 (
\begin_inset Formula $U=Attr^{0}(\Gamma,\phi^{-1}(0)$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 and take its complement 
\begin_inset Formula $V'$
\end_inset

 (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V'=V\setminus U)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 and call the induced subgame
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\Gamma'$
\end_inset

 (
\begin_inset Formula $\Gamma'=\Gamma|V'$
\end_inset

).
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
Since there are no vertices with priority 
\begin_inset Formula $0$
\end_inset

 left in 
\begin_inset Formula $\Gamma'$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
, it has at most 
\begin_inset Formula $d$
\end_inset

 different priorities and
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 we can invoke the induction hypothesis to solve 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\Gamma'$
\end_inset

, yielding winning sets 
\begin_inset Formula $W'_{0}$
\end_inset

 and 
\begin_inset Formula $W'_{1}$
\end_inset

 and associated strategies.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
At this point, we know that 
\begin_inset Formula $W'_{1}\subseteq W_{1}$
\end_inset

 because 
\begin_inset Formula $V'$
\end_inset

 is a trap for Even in 
\begin_inset Formula $\Gamma$
\end_inset

 and therefore any strategy which works for Odd in 
\begin_inset Formula $\Gamma'$
\end_inset

 is winning in 
\begin_inset Formula $\Gamma$
\end_inset

 too.
 The same does not apply to 
\begin_inset Formula $W_{0}$
\end_inset

, because it is possible that Odd can escape from 
\begin_inset Formula $W_{0}$
\end_inset

 into 
\begin_inset Formula $U$
\end_inset

 as 
\begin_inset Formula $V'$
\end_inset

 is not a trap for Odd.
 Let 
\begin_inset Formula $U'=Attr^{1}(\Gamma,W'_{1})$
\end_inset

; then 
\begin_inset Formula $U'\subseteq W'_{1}$
\end_inset

 (since it is the attractor of a winning region) and 
\begin_inset Formula $V\setminus U'$
\end_inset

 is a trap for Odd in 
\begin_inset Formula $\Gamma$
\end_inset

 (as the complement of an Odd-attractor).
 Consequently it suffices to solve the subgame 
\begin_inset Formula $\Gamma|\left(V\setminus U'\right)$
\end_inset

 to determine the remainder of the winning sets.
\end_layout

\begin_layout Standard
We thus repeat the process to solve increasingly smaller subgames, until
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $U=\emptyset$
\end_inset

 (i.e.
 no vertices with priority 0 remain and we we can invoke the induction hypothesi
s to solve it) or 
\begin_inset Formula $U'=\emptyset$
\end_inset

 (i.e.
 all remaining vertices are won by Even).
 Winning strategies can be constructed along the way.
 In the base case (when there is only a single priority left) the winning
 player can pick abritrary successors for his strategy.
 Otherwise, recursive solving and attractor set computation yield strategies
 which can be combined into a global strategy.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:zielonka-steps"

\end_inset

 shows the steps taken for each iteration of Zielonka's algorithm; the unsolved
 part of the game after the third step is used in the next iteration.
\end_layout

\begin_layout Standard
From the above, it is clear that to solve a game with 
\begin_inset Formula $d$
\end_inset

 priorities, we must recursively call the solver 
\begin_inset Formula $O(V)$
\end_inset

 times, giving a worst-case runtime of 
\begin_inset Formula $O(V^{d})$
\end_inset

.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann-recursive-lower-bound"

\end_inset

, Friedmann presents a class of games requiring exponential time to solve,
 with 
\begin_inset Formula $\Omega(fib(V))$
\end_inset

 as a lower bound (where 
\begin_inset Formula $fib(i)$
\end_inset

 returns the 
\begin_inset Formula $i$
\end_inset

-th Fibonacci number).
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The actual algorithm implementation varies a little from the proof structure
 for practical reasons.
 For one thing, the implementation is restricted to finite graphs.
 The inductive proof lends itself to being implemented recursively, but
 a straightforward recursive formulation is undesirable here, because deep
 recursion on a large game may overflow the runtime stack.
 Instead, the implementation is iterative and recurses only when computing
 subgames with fewer priorities, bounding the maximum recursion depth by
 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
Additionally, instead of solving one priority at a time, we will speed up
 the solving process by always looking for the next inversion of parity
 in the game.
 Let an inversion of parity be a priority 
\begin_inset Formula $p$
\end_inset

 such that there is a priority 
\begin_inset Formula $n<p$
\end_inset

 with 
\begin_inset Formula $n\not\equiv p\mod{2}$
\end_inset

 and there are some vertices with priority 
\begin_inset Formula $n$
\end_inset

, some vertices with priority 
\begin_inset Formula $p$
\end_inset

, but no vertices with priority 
\begin_inset Formula $o$
\end_inset

 for any 
\begin_inset Formula $n<o<p$
\end_inset

.
 The number of inversions of parity in the initial game is a limit on the
 recursion depth, but typically (after priority compression) this is equal
 to 
\begin_inset Formula $d$
\end_inset

.
 However, for smaller subgames, the number of inversions may be much lower,
 as not all priority values are necessarily used.
 Specifically, if there are no inversions of parity, then all priorities
 assigned to vertices have the same parity, and the corresponding player
 trivially wins the entire game.
\end_layout

\begin_layout Standard
Otherwise, all vertices with priority less than 
\begin_inset Formula $p$
\end_inset

 (or, equivalently, less than or equal to 
\begin_inset Formula $n$
\end_inset

) can be compressed into a single value.
 In the implementation, this is done implicitly by adding all of these vertices
 to the minimum-priority attractor set (though the game itself is unchanged).
\end_layout

\begin_layout Standard
The recursive algorithm is presented in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Zielonka's-Recursive-Algorithm"

\end_inset

.
 Recall that 
\family typewriter
strategy
\family default
 maps vertices to successor vertex indices (where the value 
\begin_inset Formula $\texttt{NO\_VERTEX}$
\end_inset

 is used to indicate that a vertex is not in the controller's winning set).
 In the implementation this is a simple array of vertex indices, which requires
 that subgame construction preserves vertex indices.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

solve(ParityGame game, Strategy strategy)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Priority p = least_inversion(game)
\end_layout

\begin_layout Plain Layout

	while p < game.d {
\end_layout

\begin_layout Plain Layout

		Set<Vertex> min_prio = { v in game.graph.V
\end_layout

\begin_layout Plain Layout

			where game.priority(v) < p }
\end_layout

\begin_layout Plain Layout

		Set<Vertex> min_prio_attr =
\end_layout

\begin_layout Plain Layout

			make_attractor_set(game, (p-1) mod 2, min_prio, strategy)
\end_layout

\begin_layout Plain Layout

		Set<Vertex> unsolved =
\end_layout

\begin_layout Plain Layout

			game.graph.get_complement(min_prio_attr)
\end_layout

\begin_layout Plain Layout

		if |unsolved| == 0 { break }
\end_layout

\begin_layout Plain Layout

		ParityGame subgame = game.make_subgame(unsolved)
\end_layout

\begin_layout Plain Layout

		solve(subgame, strategy)
\end_layout

\begin_layout Plain Layout

		Set<Vertex> lost = { v in subgame.graph.V
\end_layout

\begin_layout Plain Layout

			where strategy.winner(v) == p mod 2 }
\end_layout

\begin_layout Plain Layout

		if |lost| == 0 { break }
\end_layout

\begin_layout Plain Layout

		Set<Vertex> lost_attr = 
\end_layout

\begin_layout Plain Layout

			make_attractor_set(game, p mod 2, lost, strategy)
\end_layout

\begin_layout Plain Layout

		Set<Vertex> remaining =
\end_layout

\begin_layout Plain Layout

			game.graph.get_complement(lost_attr)
\end_layout

\begin_layout Plain Layout

		game = game.make_subgame(remaining)
\end_layout

\begin_layout Plain Layout

		p = least_inversion(game)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for v in game.graph.V {
\end_layout

\begin_layout Plain Layout

		if game.priority(v) < p {
\end_layout

\begin_layout Plain Layout

			if game.player(v) == game.priority(v) mod 2 {
\end_layout

\begin_layout Plain Layout

				strategy[v] = any successor of v
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				strategy[v] = NO_VERTEX
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zielonka's Recursive Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Zielonka's-Recursive-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The execution of the main algorithm depends on several, simpler helper functions
:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{least\_inversion}$
\end_inset

 returns the least inversion in the game, as described above, by analyzing
 the cardinality of priorities in use.
 If there is no inversion, the game index 
\begin_inset Formula $\texttt{d}$
\end_inset

 is returned instead.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{make\_attractor\_set}$
\end_inset

 takes a vertex set and extends it to its attractor set with respect to
 the given player, as described earlier.
 For all vertices that are added to the set (but not those in initial set)
 the accompanying strategy is also assigned, so that play according to the
 strategy leads to the vertices in the initial set.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{get\_complement}$
\end_inset

 returns the complement of a given vertex set, with respect to the vertex
 set of a graph.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\texttt{make\_subgame}$
\end_inset

 constructs the subgame induced by the given vertex set.
 Since in Zielonka's algorithm subgames are constructed from the complement
 of an attractor set, this always results in a proper game.
 (For purposes of the algorithm outlined above, it is assumed that vertex
 identifiers are preserved, so that assignments to the global strategy array
 are consistent with the global game.)
\end_layout

\begin_layout Standard
From a high-level point of view, the algorithm operates by first assuming
 that all vertices in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\texttt{min\_prio\_attr}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 are won by the corresponding player and then recursively solving the rest
 of the game.
 If the rest of the game is won by the same player, the procedure is complete;
 otherwise, the opponent has a non-empty winning set, and can win from any
 vertices in its attractor set as well.
 This attractor set is removed from the game, and the procedure is repeated
 with the remainder, until it becomes empty or entirely won by one player.
\end_layout

\begin_layout Subsection
Strategy computation
\end_layout

\begin_layout Standard
The strategy for vertices in 
\begin_inset Formula $\texttt{min\_prio\_attr}\setminus\texttt{min\_prio}$
\end_inset

 is assigned during attractor set computation.
 The strategy for vertices in its complement are assigned by the recursive
 invocation of 
\begin_inset Formula $\texttt{solve}$
\end_inset

.
 The strategy for vertices in the attractor set of vertices lost to the
 opponent are overwritten by the next attractor set computation; this part
 of the strategy is then final, and the vertices in this set are removed
 from the graph.
\end_layout

\begin_layout Standard
The while-loop exits in three cases: when the game has no more inversions,
 when the attractor set of the minimum priority vertices covers the entire
 game graph, or when the vertices outside this attractor set are all won
 by the player corresponding to the minimum priority vertices.
 In all of these cases, the remaining game has no inversions (i.e.
 it is a single-parity game).
 At this point, the only vertices for which the strategy has not been assigned,
 are those with priority less than 
\begin_inset Formula $\texttt{p}$
\end_inset

.
 For those, it suffices to pick an arbitrary successor in the remaining
 part of the game (which is done in the for-loop at the end) to complete
 the strategy.
\end_layout

\begin_layout Subsection
Termination
\end_layout

\begin_layout Standard
In this algorithm every recursive invocation removes at least one inversion
 from the game (when 
\begin_inset Formula $\texttt{solve}$
\end_inset

 is called recursively, all vertices with priority less than 
\begin_inset Formula $\texttt{p}$
\end_inset

 are removed, so 
\begin_inset Formula $\texttt{p}$
\end_inset

 is not an inversion in the subgame) so the number of inversions in the
 initial game is an upper bound on the recursion depth.
 Further more, every complete iteration of the while loop removes at least
 two vertices from the game (one in 
\begin_inset Formula $\texttt{lost}$
\end_inset

 and another in its attractor set, overlapping 
\begin_inset Formula $\texttt{min\_prio\_attr}$
\end_inset

) until the game is empty or completely solved, so the maximum number of
 iterations in the while loop is 
\begin_inset Formula $\frac{\left|V\right|}{2}$
\end_inset

.
 Combined, these observations guarantee the algorithm terminates.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- real worst case is probably smaller than 
\begin_inset Formula $\left(\frac{\left|V\right|}{2}\right)^{d}$
\end_inset

; need to figure out how small, and if possible construct a worst-case example.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parallelization
\end_layout

\begin_layout Standard
Zielonka's recursive algorithm is entirely deterministic, in the sense that
 the subgames that must be computed to arrive at an answer are fixed, and
 they can only be computed in a fixed order.
 This is very different from Small Progress Meaures, where individual lifting
 operations can be performed in any order, and can even be performed independent
ly in parallel, without affecting the final outcome of the algorithm.
\end_layout

\begin_layout Standard
This property of Zielonka's algorithm can be seen clearly in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Zielonka's-Recursive-Algorithm"

\end_inset

: every statement in the while-loop depends directly on the result obtained
 in the immediately preceding statement.
 As a result, it is impossible to reorder any statements, let alone evaluate
 different statements in parallel, which suggests that the algorithm cannot
 be parallelized at this level; at least, not without reformulating the
 algorithm.
\end_layout

\begin_layout Standard
Fortunately, parallelizing the algorithm at the top level is not the only
 possible approach.
 Although the algorithm is highly determinstic in its execution, the operations
 that are performed are relatively high-level and computationally expensive.
 Again, in this regard the algorithm differs from Small Progress Measures,
 where the basic operation (a lifting attempt) is so simple that it makes
 little sense to try and parallelize it, for the synchronization overhead
 would likely negate the speedup gained by parallelization.
\end_layout

\begin_layout Subsection
Distributed computation
\end_layout

\begin_layout Standard
My approach to parallelizing Zielonka's algorithm is therefore based on
 attempting to parallize the basic high-level operations on which the algorithm'
s execution is based: 
\begin_inset Formula $\texttt{make\_attractor\_set}$
\end_inset

, 
\begin_inset Formula $\texttt{get\_complement}$
\end_inset

, 
\begin_inset Formula $\texttt{make\_subgame}$
\end_inset

 and the construction of vertex sets in the while-loop, and the construction
 of a final strategy in the for-loop at the end.
 To this end, the initial game graph is partitioned over all available processes
 by assigning every process a distinct part of the vertex set.
 Every process will execute the main algorithm independently, and compute
 the part of the strategy that applies to its local vertex set.
\end_layout

\begin_layout Standard
In the following, it is assumed that processes execute symmetrically (all
 execute the same program) and independently (requiring no synchronization
 between instructions) but that communication is possible between any pair
 of processes by way of message passing.
 This is a fairly common distributed computing scenario, that requires a
 fast local network between otherwise independent computers.
\end_layout

\begin_layout Standard
Besides distributing the computation over several processes, the data structures
 are distributed as well.
 Every process stores the following information locally:
\end_layout

\begin_layout Itemize
The part of the global vertex set assigned to this process; this will be
 called the 
\emph on
internal vertex set
\emph default
.
\end_layout

\begin_layout Itemize
The part of the global strategy corresponding with the internal vertex set.
\end_layout

\begin_layout Itemize
A subgame of the global game graph that contains at least the internal vertex
 set.
\end_layout

\begin_layout Standard
Since no global data needs to be stored at individual processes, the amount
 of memory required per process for a given game decreases as the number
 of assigned processes increases.
 This approach therefore allows the size of games that can be solved to
 be scaled up with the number of processes.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Need to check: is this implemented? If so, more clearly list that as a feature!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With a fixed graph partition, most of the basic operations can be parallelized
 trivially.
 For example, when constructing the minimum priority vertex set, every process
 only considers the vertices in its assigned partition, and constructs a
 local set accordingly.
 The local sets computed by the individual processes form a partition of
 the set computed by the global algorithm.
 Set complements, subgames and final strategies can be constructed this
 way as well, requiring no synchronization between processes.
 The only tricky operation, and the only operation that requires communication
 between processes, is the computation of attractor sets.
 After all, containment of a vertex in an attractor set depends on whether
 none, one or all of its successors are already in the set, but these successors
 may not be part of the local vertex set.
\end_layout

\begin_layout Standard
To allow processes to communicate information about attractor sets in an
 efficient manner, it is useful to include in the local game graph not only
 vertices and edges in the internal vertex set, but also all adjacent vertices
 and the corresponding edges.
 This allows processes to share information with just the other interested
 processes, without having to resort to broadcasting all locally computed
 data, which may well generate so much communication overhead to negate
 any possible benefits from parallelization.
\end_layout

\begin_layout Subsection
Distributed attractor set computation
\end_layout

\begin_layout Standard
The distributed attractor set computation algorithms are based on the sequential
 implementation of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Attractor-set-computation"

\end_inset

, but now each process maintains its own queue of vertices (both internal
 and successors of internal vertices) and a part of the attractor set (internal
 vertices only).
 Processes can work through their local queue independently, but when an
 internal vertex is added to the local attractor set, this information must
 be communicated to the processes responsible for the predecessors of that
 vertex, so they the may add this vertex to their queue too.
\end_layout

\begin_layout Standard
Logically, internal vertices are only ever added to the queue by the process
 itself, and external vertices only by the corresponding external process.
\end_layout

\begin_layout Standard
I implemented two distributed algorithms, which differ in the way they communica
te vertex updates and detect termination.
 The first method is the simplest, but it may require a lot of synchronization
 between processes (and thus cause processes to waste time waiting on each
 other).
 The second method synchronizes only at the end of the calculation, and
 should therefore be more efficient.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
This needs a benchmark.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Synchronous method
\end_layout

\begin_layout Standard
In the synchronous method, the incremental sets from subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Attractor-sets"

\end_inset

 are computed explicitly, with full synchronization between all processes
 in between.
 Each step conists of two phases:
\end_layout

\begin_layout Enumerate
Each process independently calculates the next incremental attractor subset,
 keeping a list of newly added vertices in this phase.
\end_layout

\begin_layout Enumerate
All processes communicate their queued vertices with each other, making
 them aware of the external vertices added to the attractor set in the first
 phase.
\end_layout

\begin_layout Standard
The calculation ends when all processes report that their queues are empty.
 Separating the algorithm in discrete phases makes this case easy to detect.
 However, many steps may be required to reach this state, incurring a proportion
al amount of synchronization overhead.
\end_layout

\begin_layout Subsubsection
Asynchronous method
\end_layout

\begin_layout Standard
In the asynchronous method, processes send updates about vertices as soon
 as they add them to their local attractor set, and add external vertices
 to their queue as soon as they receive them.
\end_layout

\begin_layout Standard
A process is considered 
\emph on
active
\emph default
 when it has vertices remanining in its local queue.
 When its queue becomes empty the process is 
\emph on
idle
\emph default
, but it will be reactivated when it receives an external vertex update
 from another process.
 The algorithm should terminate when all processes are idle, because then
 all queues are empty and the computation is complete.
 To detect distributed termination, I implemented the four-counter method
 described by Friedemann Mattern in 
\begin_inset CommandInset citation
LatexCommand cite
key "mattern1987algorithms"

\end_inset

.
\end_layout

\begin_layout Standard
Because processes are free to interleave three kinds of operations (processing
 queued vertices, sending vertex updates and receiving them), this method
 may be somewhat faster in practice.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
discuss the effect of partitioning schemes on the efficiency of these algorithms
?
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Empirical Evaluation 
\begin_inset CommandInset label
LatexCommand label
name "chap:Empirical-Evaluation"

\end_inset


\end_layout

\begin_layout Standard
An emperical evaluation of the performance of the algorithms described so
 far is necessary to determine how well they work in practice.
 However, meaningful benchmark results can only be obtained when these algorithm
s are applied to reasonably complex test data.
 Games which are too easily solved by preprocessing techniques or other,
 simpler methods should be excluded from the test set.
\end_layout

\begin_layout Standard
We will use two sources of games: clustered random games, and some of the
 games used earlier by Friedmann & Lange (described in detail in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

).
 The rationale is that clustered random games are an unlimited source of
 reasonably-hard games (when generated properly) while including some of
 the more structured games from Friedmann & Lange simplifies comparison
 of the results presented here with earlier reports.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
I want to show three things:
\end_layout

\begin_layout Itemize
maximum measure/step propagation is a valid strategy (I'v got this covered)
\end_layout

\begin_layout Itemize
decrement after lifting to top improves SPM especially in two-sided approach
 (TODO?)
\end_layout

\begin_layout Itemize
decycle solver works great (also compare with deloop solver)
\end_layout

\begin_layout Plain Layout
(Really emphasize my contributions here!)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Random games
\end_layout

\begin_layout Subsection
Generating random games 
\begin_inset CommandInset label
LatexCommand label
name "sub:Random-games"

\end_inset


\end_layout

\begin_layout Standard
To obtain meaningful results using randomly-generated data, the random graphs
 used for benchmarking are generated in a way that is intended to withstand
 at least a few of the most common preprocessing techniques.
\end_layout

\begin_layout Standard
Random games are characterized by the size of the vertex set 
\begin_inset Formula $|V|$
\end_inset

, the average outdegree (or, equivalently, average indegree), and the number
 of priorities 
\begin_inset Formula $d$
\end_inset

.
 For each vertex, the outdegree is chosen uniformly at random between 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $2\times outdegree-1$
\end_inset

 (to guarantee each vertex has at least one outgoing edge) and then adjacent
 vertices are chosen uniformly at random from the vertex set without duplicates
 and exluding the vertex itself (to exclude the possibility of loops).
 Finally, a priority for the vertex is chosen uniformly at random between
 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $d-1$
\end_inset

 (inclusive).
\end_layout

\begin_layout Standard
Graphs generated in this way typically consist of one large, strongly-connected
 component, and several small (usually single-vertex) components.
 For very small graphs there is even a risk of disconnecting the game graph
 entirely! To remedy this, after graph generation strongly-connected components
 are identified and those components that have either no incoming or no
 outgoing edges (i.e.
 they lie at the top or bottom of the hierarchy of strongly-connected components
) are connected to each other in a cycle in random order.
 This guarantees the output consists of a single, strongly-connected component
 (at the cost of introducing some extra edges).
\end_layout

\begin_layout Subsection
Generating clustered random games 
\begin_inset CommandInset label
LatexCommand label
name "sub:Clustered-random-games"

\end_inset


\end_layout

\begin_layout Standard
To create games with a little less uniform graph structure (which more closely
 resemble instances arising in practice, as well as being less likely to
 be solved completely by the cycle-removal preprocessor) it is useful to
 structure the game graph around clusters of some fixed size.
 To generate a game with 
\begin_inset Formula $|V|$
\end_inset

 vertices and clusters of size 
\begin_inset Formula $C$
\end_inset

, first 
\begin_inset Formula $\left\lfloor \frac{|V|}{C}\right\rfloor $
\end_inset

 clusters of size 
\begin_inset Formula $C$
\end_inset

 are randomly-generated using the procedure described in the previous subsection.
 Then, clusters are grouped together, at most 
\begin_inset Formula $C$
\end_inset

 at a time, and connected together according to a randomly-generated game
 with the same parameters.
\end_layout

\begin_layout Standard
For example, if 
\begin_inset Formula $|V|=50$
\end_inset

 and 
\begin_inset Formula $C=10$
\end_inset

, then 5 clusters of 10 vertices each are generated, as well as one 5-vertex
 top-level game that is used to connect these clusters: if there is an edge
 from, say, vertex 1 to 2 in the top-level game, then an edge is added from
 a random vertex in the first cluster to a random vertex in the second cluster.
 If 
\begin_inset Formula $|V|>C^{2}$
\end_inset

 then a third level is needed to combine groups of clusters, and so on,
 for a hierarchy of 
\begin_inset Formula $\left\lceil ^{C}\log\left|V\right|\right\rceil $
\end_inset

 levels in the final graph.
\end_layout

\begin_layout Standard
Since all games generated were strongly-connected, the combined graph will
 be strongly-connected as well.
 However, it does contain a few more edges, limited to a factor 
\begin_inset Formula $\frac{C}{C-1}$
\end_inset

 (as the sum of a geometric series).
 Consequently, if few extra edges are desired, the cluster size should not
 be set too small.
\end_layout

\begin_layout Section
Cases from 
\emph on
Solving Parity Games in Practice 
\begin_inset CommandInset label
LatexCommand label
name "sec:Cases-from-SPGIP"

\end_inset


\end_layout

\begin_layout Standard
Friedmann & Lange's benchmarks include four kinds of games:
\end_layout

\begin_layout Enumerate

\emph on
Decision procedures:
\emph default
 two subclasses of games constructed from recursively defined 
\begin_inset Formula $\mu$
\end_inset

-calculus formulae (
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\phi'$
\end_inset

).
\end_layout

\begin_layout Enumerate

\emph on
Elevator verification:
\emph default
 two model checking problems, consisting of checking the fairness of two
 similar elevator models (one fair, 
\begin_inset Formula $G$
\end_inset

; one unfair, 
\begin_inset Formula $G'$
\end_inset

).
\end_layout

\begin_layout Enumerate

\emph on
Towers of Hanoi
\emph default
: a simple model checking problem which verifies whether a position in the
 solitary Towers of Hanoi game is solveable.
\end_layout

\begin_layout Enumerate

\emph on
Random games
\emph default
: large games generated randomly.
\end_layout

\begin_layout Standard
The third class of games can be solved entirely using either decomposition
 into strongly connected components (as Friedmann and Lange also reported)
 or by owner-controlled cycle removal, and is therefore excluded from the
 test set.
\end_layout

\begin_layout Standard
The fourth class of games could be interesting, but the exact parameters
 used to generate these random games (especially how they are clustered)
 are not provided.
 It should be noted that unclustered random games can typically be solved
 completely using cycle removal, which is a preprocessing operation that
 is not available in PGSolver.
 Instead, we will use clustered random games as described in subsection
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Clustered-random-games"

\end_inset

.
 One notable difference with the random games used by Friedmann and Lange
 is that our games will consist of a single strongly-connected component
 only.
\end_layout

\begin_layout Standard
This leaves two classes which each include two kinds of games that can in
 turn be varied in size.
 The decision procedure games are generated using a separate tool called
 MLSolver.
 The elevator verification games are generated with a tool from the PGSolver
 suite.
 To prevent implementation details of these tools influencing the results,
 the vertices of the game graphs are shuffled before each experiment.
 This ensures the graph structure is retained while removing the effect
 that the particular vertex ordering produced by these tools might have
 had on the performance of various lifting strategies.
\end_layout

\begin_layout Standard
The properties of the games (such as size of the game graph, and number
 of different priorities) is summarized in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SPGIP-cases"

\end_inset

.
 A more detailed description of how these games are structured is available
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="23" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Game
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vertices
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Edges
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Priorities
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Largest component
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
435
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
584
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
131
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,677
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,530
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
368
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13,815
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18,330
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,068
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi_{5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60,674
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
79,591
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,658
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi_{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
259,170
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
340,982
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6,515
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi_{7}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,011,979
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,316,640
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15,991
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi_{8}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,939,223
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,128,098
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36,606
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi'_{10}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4,590
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6,520
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,812
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi'_{50}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21,910
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31,320
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8,652
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi'_{100}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43,560
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
62,320
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17,202
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi'_{500}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
216,760
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
310,320
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
85,602
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi'_{1000}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
433,260
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
620,320
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
171,102
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi'_{2000}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
866,260
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,240,320
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
342,102
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi'_{5000}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,165,260
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,100,320
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
855,102
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $G_{5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15,684
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26,354
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10,973
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $G'_{5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16,356
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38,194
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11,456
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $G_{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
108,336
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
180,898
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
78,818
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $G'_{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111,456
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
287,964
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
81,121
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $G_{7}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
861,780
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,431,610
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
643,756
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $G'_{7}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
876,780
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,484,252
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
655,073
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $G_{8}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,744,224
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12,810,736
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,894,533
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $G'_{8}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,814,016
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24,093,264
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,948,026
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Properties of testcases from 
\emph on
Solving Parity Games in Practice 
\begin_inset CommandInset label
LatexCommand label
name "tab:SPGIP-cases"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

It should be noted that these cases except the last (
\begin_inset Formula $G'$
\end_inset

) have the property that they do not require lifting any vertices to 
\begin_inset Formula $\top$
\end_inset

.
 Instead, Odd's winning region can be extracted by loop removal preprocessing
 (or by propagating 
\begin_inset Formula $\top$
\end_inset

 values after initializing odd-controlled odd-priority vertices with loops
 to 
\begin_inset Formula $\top$
\end_inset

) and the remaining subgame is won entirely by Even.
 For the unfair elevator (
\begin_inset Formula $G'$
\end_inset

) class of games, this property applies to the 
\emph on
dual
\emph default
 rather than the normal game.
\end_layout

\begin_layout Section
Benchmark platform
\end_layout

\begin_layout Standard
All benchmarks were performed on a Linux system with two Intel Xeon E5520
 processors (8 MB cache, 2.26 GHz clock speed) and 24 GB of memory (far more
 than needed for any testcase).
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
also hyperthreading, so in total 8 cores and 16 threads of control
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Results on random games
\end_layout

\begin_layout Standard
Tables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{random_graphs_lifts}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{random_graphs_time}
\end_layout

\end_inset

 show how the different lifting strategies perform on unclustered and clustered
 random graphs.
 The configurations differ on four (not completely independent) axes:
\end_layout

\begin_layout Enumerate

\emph on
Lifting strategy
\emph default
: linear lifting (
\begin_inset Quotes eld
\end_inset

lin
\begin_inset Quotes erd
\end_inset

), predecessor lifting (
\begin_inset Quotes eld
\end_inset

pred
\begin_inset Quotes erd
\end_inset

), maximum measure propagation (
\begin_inset Quotes eld
\end_inset

max
\begin_inset Quotes erd
\end_inset

), minimum measure propagation (
\begin_inset Quotes eld
\end_inset

min
\begin_inset Quotes erd
\end_inset

), and maximum step propagation (
\begin_inset Quotes eld
\end_inset

step
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Enumerate

\emph on
Direction/extraction order: 
\emph default
the linear lifting strategy can either iterate in forward direction (F)
 or alternate direction on each pass (A).
 The predecessor lifting strategy can either use queue-order (Q) or stack-order
 (S), while the maximum/minimum measure and maximum step strategies can
 also use the internal heap order (H).
 These varations are described in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Lifting-Strategies"

\end_inset

.
\end_layout

\begin_layout Enumerate

\emph on
Framework
\emph default
: either the traditional framework or the improved framework (I) described
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Eliminating-failed-lifting"

\end_inset

.
 The linear lifting strategy only supports the traditional framework, while
 the predecessor lifting strategy is the only one that supports both.
\end_layout

\begin_layout Enumerate

\emph on
Two-sided approach:
\emph default
 all strategies can use the two-sided solving approach (T) described in
 Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Two-sided-SPM"

\end_inset

.
\end_layout

\begin_layout Standard
Five different classes of random games were used, each with 10 priorities
 and outdegree 3, but with varying graph sizes and cluster sizes.
 In the results, 
\family typewriter
4000/16
\family default
 denotes a graph generated as discussed in subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Clustered-random-games"

\end_inset

 with 4000 vertices and cluster size 16.
 For each class 30 instances were randomly generated, and each solver configurat
ion was allowed to perform up to 
\begin_inset Formula $10^{9}$
\end_inset

 lifting attempts before being aborted.
 Apart from initializing vertices with loops to 
\begin_inset Formula $\top$
\end_inset

 (the weakest form of loop removal described in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Loop-removal"

\end_inset

), no preprocessing was applied.
\end_layout

\begin_layout Standard
Tables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{random_graphs_lifts}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{random_graphs_time}
\end_layout

\end_inset

 show how many instances in each class could be solved successfully by the
 given configuration, and also the average number of lifts (in millions
 of attempts) and time taken (in seconds), respectively.
 Both the number of lifts and the amount of time varied greatly between
 cases, so it is generally not meaningful to compare these except for cases
 where all instances in a class were completely solved.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
First, it is interesting to see that 
\emph on
clustered
\emph default
 random games are a lot more difficult to solve than larger 
\emph on
unclustered
\emph default
 games (at least, using Small Progress Measures) and that the more levels
 of clustering there are (i.e.
 the smaller the initial cluster size is) the more difficult these games
 become.
\end_layout

\begin_layout Standard
On the direction axis, it turns out that forward swiping works best for
 linear lifting.
 Perhaps surprisingly, the alternating variant requires significantly more
 lifting attempts (though well below the theoretical maximum of twice the
 number required for the forward swiping alternative).
 Manual inspection of the benchmark results reveals that the alternating
 variant, on average, requires fewer succesful lifting attempts but fails
 more lifting attempts, which results in a net loss in efficiency.
\end_layout

\begin_layout Standard
For the predecessor lifting strategy, queue-like (rather than stack-like)
 extraction order tends to solve the most cases.
 Since this order has the additional advantage that it is guaranteed to
 perform no worse than linear lifting (in the worst case) it seems reasonable
 to prefer queue-like behaviour.
 For the maximum measure lifting strategy and its variants, the results
 are less clear: in the one-sided framework using stack order results in
 at most one extra case being solved, but in the two-sided framework queue
 order performs better, but only by a small margin.
 Heap order never appears to be the best policy.
\end_layout

\begin_layout Standard
The results from the predecessor lifting strategy allow us to compare the
 traditional framework with the improved framework.
 That fewer lifting attempts are performed in the improved framework should
 come as no suprise, as it eliminates failed lifting attempts entirely,
 but what is more important, is the observation that in all cases the improved
 framework takes less time (roughly half as much) while solving the same
 number or more cases.
 This demonstrates that the “improved” framework is indeed an improvement
 in practice.
\end_layout

\begin_layout Standard
The two-sided approach turns out to be very effective on random games.
 Using any lifting strategy, the total number of solved games is increased,
 or the number of lifts required decreases by nearly an order of magnitude,
 or both.
 For some cases, these successes can be attributed to the fact that the
 two-way approach can solve the dual game before the normal game (in which
 case solving the dual game first would have benefited the one-sided approach
 too) but that cannot be the only reason why the two-sided approach works
 so well.
 For example, looking at the 
\family typewriter
4000/16
\family default
 class of games, it seems statistically unlikely that 0 out of 30 games
 could be solved normally, while the dual of 17 of these games 
\emph on
can
\emph default
 be solved in time.
 Consequently, it seems more likely that identification of stable regions
 contributes significantly to the ability to solve these problems.
\end_layout

\begin_layout Standard
(It should be noted that the generated random games are not completely symmetric
 because the highest priority, 0, always corresponds with Even, while the
 lowest corresponds with Odd.
 However, this means the 
\emph on
dual
\emph default
 game should be harder to solve, at least in the worst case, as the upper
 bound on the number of lifts mentioned in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Lifting-Strategies"

\end_inset

 implies.
 For random games in practice, this line of reasoning also proves to be
 true: dual games are slightly harder than normal games, though the margin
 gets smaller as the the number of priorities increases.)
\end_layout

\begin_layout Standard
Finally, the minimum measure propagation strategy works well only with the
 two-sided approach, and in that case it outperforms the maximum measure
 and maximum step approaches, but not the predecessor lifting strategy.
 Indeed, the predecessor lifting strategy appears to be the overall most
 effective strategy for these kinds of games.
 In the improved framework and using queue order, it solves the most cases
 in every set of random games, while using relatively little time.
 All in all, these results do not bode well for the more sophisticated lifting
 strategies.
 However, random cases are rather synthetic and (even with clustering) not
 very similar in structure to parity game instances that might arise in
 practice.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{adjustwidth}{-5cm}{-5cm}
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
footnotesize
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{l l|r r|r r|r r|r r|r r|r r|}
\end_layout

\begin_layout Plain Layout

	&
\end_layout

\begin_layout Plain Layout

    & 
\backslash
multicolumn{2}{c|}{4000/0}
\end_layout

\begin_layout Plain Layout

    & 
\backslash
multicolumn{2}{c|}{8000/0}
\end_layout

\begin_layout Plain Layout

    & 
\backslash
multicolumn{2}{c|}{16000/0}
\end_layout

\begin_layout Plain Layout

	& 
\backslash
multicolumn{2}{c|}{4000/16}
\end_layout

\begin_layout Plain Layout

    & 
\backslash
multicolumn{2}{c|}{4000/64} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	&
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 lifts
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 lifts
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 lifts
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 lifts
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 lifts 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Linear       & F     & 27 & $5.290$ & 25 & $7.997$ & 25 & $28.621$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Linear       & A     & 27 & $7.701$ & 25 & $11.710$ & 25 & $37.967$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & Q     & 30 & $2.033$ & 29 & $5.932$ & 28 & $18.813$ & 0 & $0.000$
 & 4 & $472.543$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & S     & 29 & $1.451$ & 28 & $0.699$ & 22 & $2.425$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & Q I   & 30 & $0.891$ & 30 & $3.114$ & 29 & $9.669$ & 0 & $0.000$
 & 4 & $179.287$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & S I   & 29 & $0.253$ & 29 & $0.287$ & 25 & $0.718$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & Q I   & 29 & $0.128$ & 29 & $0.079$ & 27 & $0.236$ & 0 & $0.000$
 & 1 & $533.683$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & S I   & 30 & $0.087$ & 30 & $0.133$ & 29 & $0.251$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & H I   & 30 & $0.254$ & 30 & $0.088$ & 26 & $0.242$ & 0 & $0.000$
 & 1 & $782.083$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & S I   & 30 & $0.261$ & 28 & $0.207$ & 28 & $0.326$ & 0 & $0.000$
 & 1 & $697.793$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & Q I   & 30 & $0.259$ & 29 & $0.193$ & 28 & $0.333$ & 0 & $0.000$
 & 1 & $672.232$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & H I   & 30 & $0.257$ & 29 & $0.194$ & 28 & $0.324$ & 0 & $0.000$
 & 1 & $712.803$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & Q I   & 25 & $36.135$ & 24 & $65.144$ & 9 & $109.908$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & S I   & 26 & $40.427$ & 24 & $61.187$ & 8 & $143.396$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & H I   & 26 & $42.547$ & 23 & $57.114$ & 9 & $153.542$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Linear       & F   T & 29 & $0.679$ & 27 & $0.352$ & 26 & $1.242$ & 1 & $802.259$
 & 5 & $272.809$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Linear       & A   T & 29 & $0.961$ & 28 & $0.482$ & 26 & $1.260$ & 1 & $854.010$
 & 5 & $326.392$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & Q   T & 30 & $0.049$ & 29 & $0.055$ & 30 & $0.188$ & 17 & $105.114$
 & 21 & $22.095$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & S   T & 30 & $0.107$ & 30 & $0.158$ & 28 & $0.306$ & 0 & $0.000$
 & 5 & $503.767$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & Q I T & 30 & $0.030$ & 30 & $0.031$ & 30 & $0.078$ & 18 & $46.409$
 & 21 & $9.023$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & S I T & 30 & $0.049$ & 30 & $0.067$ & 28 & $0.224$ & 0 & $0.000$
 & 10 & $304.465$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & Q I T & 30 & $0.033$ & 30 & $0.049$ & 30 & $0.114$ & 0 & $0.000$
 & 3 & $383.092$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & S I T & 30 & $0.032$ & 30 & $0.044$ & 30 & $0.103$ & 0 & $0.000$
 & 1 & $126.888$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & H I T & 30 & $0.032$ & 30 & $0.051$ & 30 & $0.127$ & 0 & $0.000$
 & 6 & $347.106$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & S I T & 30 & $0.089$ & 29 & $0.149$ & 30 & $0.400$ & 0 & $0.000$
 & 5 & $556.909$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & Q I T & 30 & $0.086$ & 30 & $0.207$ & 30 & $0.370$ & 0 & $0.000$
 & 5 & $576.287$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & H I T & 30 & $0.112$ & 29 & $0.145$ & 30 & $0.343$ & 0 & $0.000$
 & 3 & $407.758$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & Q I T & 30 & $0.043$ & 30 & $0.043$ & 30 & $0.124$ & 16 & $133.194$
 & 20 & $38.009$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & S I T & 30 & $0.041$ & 30 & $0.043$ & 30 & $0.135$ & 14 & $121.260$
 & 18 & $37.710$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & H I T & 30 & $0.044$ & 30 & $0.042$ & 30 & $0.155$ & 16 & $137.207$
 & 19 & $44.734$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
end{adjustwidth}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SPM performance on random graphs (in million lifts) 
\begin_inset CommandInset label
LatexCommand label
name "random_graphs_lifts"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{adjustwidth}{-5cm}{-5cm}
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
footnotesize
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{l l|r r|r r|r r|r r|r r|r r|}
\end_layout

\begin_layout Plain Layout

	&
\end_layout

\begin_layout Plain Layout

    & 
\backslash
multicolumn{2}{c|}{4000/0}
\end_layout

\begin_layout Plain Layout

    & 
\backslash
multicolumn{2}{c|}{8000/0}
\end_layout

\begin_layout Plain Layout

    & 
\backslash
multicolumn{2}{c|}{16000/0}
\end_layout

\begin_layout Plain Layout

	& 
\backslash
multicolumn{2}{c|}{4000/16}
\end_layout

\begin_layout Plain Layout

    & 
\backslash
multicolumn{2}{c|}{4000/64} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	&
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 time
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 time
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 time
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 time
\end_layout

\begin_layout Plain Layout

	& 
\backslash
#solved & avg.
 time 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Linear       & F     & 27 & $2.984$ & 25 & $2.897$ & 25 & $2.955$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Linear       & A     & 27 & $3.866$ & 25 & $2.461$ & 25 & $3.760$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & Q     & 30 & $0.851$ & 29 & $2.081$ & 28 & $3.477$ & 0 & $0.000$
 & 4 & $49.115$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & S     & 29 & $4.057$ & 28 & $3.308$ & 22 & $5.325$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & Q I   & 30 & $0.416$ & 30 & $2.167$ & 29 & $3.561$ & 0 & $0.000$
 & 4 & $23.124$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & S I   & 29 & $1.485$ & 29 & $2.335$ & 25 & $2.106$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & Q I   & 29 & $9.551$ & 29 & $6.416$ & 27 & $23.197$ & 0 & $0.000$
 & 1 & $451.474$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & S I   & 30 & $2.032$ & 30 & $14.288$ & 29 & $54.391$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & H I   & 30 & $28.878$ & 30 & $5.502$ & 26 & $11.688$ & 0 & $0.000$
 & 1 & $472.165$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & S I   & 30 & $26.484$ & 28 & $24.946$ & 28 & $31.141$ & 0 & $0.000$
 & 1 & $907.034$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & Q I   & 30 & $26.866$ & 29 & $47.951$ & 28 & $30.215$ & 0 & $0.000$
 & 1 & $884.866$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & H I   & 30 & $17.893$ & 29 & $27.546$ & 28 & $24.296$ & 0 & $0.000$
 & 1 & $449.360$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & Q I   & 25 & $71.726$ & 24 & $131.634$ & 9 & $197.808$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & S I   & 26 & $89.974$ & 24 & $112.067$ & 8 & $289.688$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & H I   & 26 & $62.227$ & 23 & $76.719$ & 9 & $197.744$ & 0 & $0.000$
 & 0 & $0.000$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Linear       & F   T & 29 & $2.801$ & 27 & $0.108$ & 26 & $0.659$ & 1 & $68.996$
 & 5 & $25.613$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Linear       & A   T & 29 & $3.991$ & 28 & $2.425$ & 26 & $0.631$ & 1 & $74.086$
 & 5 & $29.083$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & Q   T & 30 & $0.421$ & 29 & $0.041$ & 30 & $3.823$ & 17 & $19.376$
 & 21 & $10.955$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & S   T & 30 & $2.262$ & 30 & $4.198$ & 28 & $4.183$ & 0 & $0.000$
 & 5 & $82.203$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & Q I T & 30 & $0.265$ & 30 & $2.161$ & 30 & $3.075$ & 18 & $19.645$
 & 21 & $5.685$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Predecessor  & S I T & 30 & $0.182$ & 30 & $2.101$ & 28 & $3.314$ & 0 & $0.000$
 & 10 & $74.109$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & Q I T & 30 & $0.962$ & 30 & $3.433$ & 30 & $15.707$ & 0 & $0.000$
 & 3 & $444.737$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & S I T & 30 & $0.893$ & 30 & $11.229$ & 30 & $22.976$ & 0 & $0.000$
 & 1 & $114.589$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Measure & H I T & 30 & $0.686$ & 30 & $5.115$ & 30 & $7.341$ & 0 & $0.000$
 & 6 & $217.857$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & S I T & 30 & $1.778$ & 29 & $14.138$ & 30 & $37.116$ & 0 & $0.000$
 & 5 & $893.398$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & Q I T & 30 & $1.666$ & 30 & $66.055$ & 30 & $31.070$ & 0 & $0.000$
 & 5 & $792.409$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Max.
 Step    & H I T & 30 & $4.967$ & 29 & $4.491$ & 30 & $17.161$ & 0 & $0.000$
 & 3 & $319.749$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & Q I T & 30 & $1.253$ & 30 & $22.925$ & 30 & $17.763$ & 16 & $108.038$
 & 20 & $60.037$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & S I T & 30 & $1.216$ & 30 & $6.116$ & 30 & $16.386$ & 14 & $108.449$
 & 18 & $60.642$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Min.
 Measure & H I T & 30 & $0.657$ & 30 & $7.585$ & 30 & $9.471$ & 16 & $90.121$
 & 19 & $56.500$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
end{adjustwidth}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SPM performance on random graphs (time in seconds) 
\begin_inset CommandInset label
LatexCommand label
name "random_graphs_time"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Results on non-random games
\end_layout

\begin_layout Standard
To get a better view of how well different lifting strategies work on practical
 cases, we should also run benchmarks on the non-random cases described
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Cases-from-SPGIP"

\end_inset

.
 However, to reduce the number of variables involved in the analysis, we
 consider only queue-like extraction order and the improved framework for
 the predecessor lifting strategy, since the previous experiments have shown
 these to be the most efficient.
 As a result, these benchmarks focus on two aspects: the differences between
 lifting strategies, and the benefits of the two-sided solution apprach.
\end_layout

\begin_layout Standard
The strategies reported on are the linear lifting (
\begin_inset Quotes eld
\end_inset

lin
\begin_inset Quotes erd
\end_inset

), predecessor lifting (
\begin_inset Quotes eld
\end_inset

pred
\begin_inset Quotes erd
\end_inset

), minimum-measure propagation (
\begin_inset Quotes eld
\end_inset

min
\begin_inset Quotes erd
\end_inset

), maximum-measure propagation (
\begin_inset Quotes eld
\end_inset

max
\begin_inset Quotes erd
\end_inset

) and the maximum-step strategy (
\begin_inset Quotes eld
\end_inset

step
\begin_inset Quotes erd
\end_inset

).
 For linear lifting, the standard framework was used, and for the others,
 the improved framework described in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Eliminating-failed-lifting"

\end_inset

.
 Each configuration was allowed to run for up to an hour.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ExpandableInput{results-spm-spgip-lifts.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figures 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{spm_spgip_graphs_deciproc_lifting_attempts}
\end_layout

\end_inset

 and 
\begin_inset Formula $\ref{spm_spgip_graphs_elevator_lifting_attempts}$
\end_inset

 show the results in number of lifting attempts required to solve the test
 cases for the decision procedures and elevator verification cases respectively.
 
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
As expected, the linear lifting strategy performs the most work, and times
 out on some of the more difficult cases (however, so do some of the more
 sophisticated alternatives).
 The minimum measure propagation strategy was not expected to work well
 in this configuration, and indeed it does poorly on the decision procedures.
 However, on the elevator cases it appears to work just as well as the predecess
or lifting strategy.
\end_layout

\begin_layout Standard
Counting lifting attempts only, the maximum measure and maximum step lifting
 strategies are the best two.
 It seems fair to call the maximum step metric the overall winner, because
 even in cases where it is not the best strategy, it is fairly close to
 the best alternative (maximum measure propagation) and in the 
\begin_inset Formula $\phi'_{n}$
\end_inset

 cases it is significantly better than any other strategy.
\end_layout

\begin_layout Subsubsection
Time vs Lifts
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ExpandableInput{results-spm-spgip-time.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Measuring the total time used to solve each case (instead of the number
 of lifting attempts) paints a slightly different picture, as is shown in
 Figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "spm_spgip_graphs_deciproc_time_in_seconds"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "spm_spgip_graphs_elevator_time_in_seconds"

\end_inset

.
 The linear lifting strategy looks better compared to more sophisticated
 strategies, though (excepting minimum measure propagation) it is still
 the slowest.
 The predecessor lifting strategy now wins in the first case (
\begin_inset Formula $\phi_{n}$
\end_inset

) since the other strategies, while requiring fewer lifts, run considerably
 slower.
 However, for the second case (
\begin_inset Formula $\phi'_{n}$
\end_inset

) the maximum step strategy is still the winner since it scales much better
 to larger testcases.
 On the fair elevator case (
\begin_inset Formula $G_{n}$
\end_inset

) differences in performance are small, but on the unfair elevator (
\begin_inset Formula $G'_{n}$
\end_inset

) both the maximum measure and maximum step metric beat the simpler strategies
 by a large margin.
\end_layout

\begin_layout Subsection
Two-sided approach
\end_layout

\begin_layout Standard
The merits of the two-sided approach can be evaluated using these cases
 as well.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "spm_spgip_graphs_deciproc_lifting_attempts_a"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "spm_spgip_graphs_elevator_lifting_attempts_a"

\end_inset

 present the number of lifting attempts and time performed when the same
 strategies are used in conjunction with Friedmann's two-sided small progress
 measures implementation.
\end_layout

\begin_layout Standard
One difference is that the minimum measure lifting strategy performs much
 better than before.
 However, even in the two-sided framework it is still beaten by the simpler
 predecessor lifting strategy.
 Since this is consistent with the results on random graphs, it seems fair
 to conclude that the minimum measure lifting strategy simply does not live
 up to expectations and ought to be dismissed as a viable strategy.
\end_layout

\begin_layout Standard
Overall, the two-sided approach is not much faster (but also not much slower)
 except in the fourth case (unfair elevator verification, 
\begin_inset Formula $G'$
\end_inset

) where it performs much better.
 Figures 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{spm_spgip_charts_deciproc}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{spm_spgip_charts_elevator}
\end_layout

\end_inset

 show the differences between one-sided and two-sided solving using different
 lifting strategies for one instance of each case.
 However, the unfair elevator case is different from the others: for these
 games the dual is easier to solve than the normal game.
 In fact, solving the dual game using the one-way approach is faster than
 using the two-way approach, as the last bar chart in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{spm_spgip_charts_elevator}
\end_layout

\end_inset

 shows.
\end_layout

\begin_layout Standard
It is worth noting that in this last case, the SPM vector bounds give no
 indication that the dual game would be easier to solve.
 The elevator verification cases have only three priorities (0, 1 and 2)
 and in 
\begin_inset Formula $G'8$
\end_inset

 these occur 
\begin_inset Formula $651\,168$
\end_inset

, 
\begin_inset Formula $1\,793\,672$
\end_inset

 and 
\begin_inset Formula $5\,369\,176$
\end_inset

 times respectively.
 An approximation of the maximum number of lifts for the normal game is
 therefore 
\begin_inset Formula $1793672\times\left(1793672+5369176\right)$
\end_inset

 versus 
\begin_inset Formula $651168\text{×}(651168+1793672+5369176×5369176)$
\end_inset

 for the dual game: orders of magnitude larger, yet faster to solve in practice.
 This shows once again that worst-case estimations do not accurately predict
 how quickly games can be solved in practice.
\end_layout

\begin_layout Standard
From these charts it becomes clear that for the testcases under consideration
 (and unlike the random cases) the two-sided solving approach doesn't offer
 a significant improvement over the one-sided approach.
 At best, its performance is close to the performance of the one-sided approach
 on either the normal or the dual game (whichever is easier) but an additional
 benefit obtained from the exchange of stable region solution data between
 the two games does not appear to arise in these testcases.
 Although the two-sided approach is still useful when it is unknown which
 side of the game will be easier to solve (and in general this 
\emph on
is
\emph default
 hard to predict, as we saw in the 
\begin_inset Formula $G'$
\end_inset

 cases), the same result can also be achieved (arguably in a simpler way)
 by solving the dual game independently in parallel.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ExpandableInput{results-spm-spgip-lifts-a.tex}
\end_layout

\begin_layout Plain Layout


\backslash
ExpandableInput{results-spm-spgip-time-a.tex}
\end_layout

\begin_layout Plain Layout


\backslash
usetikzlibrary{patterns}
\end_layout

\begin_layout Plain Layout


\backslash
ExpandableInput{results-spm-spgip-twoway-charts.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Effectiveness of bounds reduction after lifting to top 
\begin_inset CommandInset label
LatexCommand label
name "sec:Benchmarks-optimization-lifting-to-top"

\end_inset


\end_layout

\begin_layout Standard
The optimization described in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimization-after-lifting"

\end_inset

 (reducing the bounds on the progress measure vectors after lifting a vertex
 to 
\begin_inset Formula $\top$
\end_inset

) can be evaluated on the same testcases.
 For the non-random cases, it turns out that vector updates never overflow,
 which should come as no surprise considering vertices are never lifted
 to 
\begin_inset Formula $\top$
\end_inset

 (except by propagating the 
\begin_inset Formula $\top$
\end_inset

 values assigned to vertices with loops) and as a result the optimization
 has no effect.
 The (normal) unfair elevator case, which doesn't have the above property,
 is the only exception: in those cases, the optimization reduces the number
 of lifts needed by about 2.5%.
\end_layout

\begin_layout Standard
The random graphs should be a little more interesting.
 We have performed the same experiments using the predecessor lifting strategy
 only, and only considering cases that can be solved with the optimization
 enabled.
 For each such case, the solver was run with the bounds reduction optimization
 disabled.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Lift-to-Top-optimization"

\end_inset

 shows the total number of lifts required with the optimization disabled
 and enabled respectively (as well as the ratio between the two) per test
 case and solver configuration (in this case, whether or not the two-sided
 solving approach was used).
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="7">
<features tabularvalignment="middle">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Graph
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cluster
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Two-sided
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cases
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lifts (base)
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lifts (reduced)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ratio
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4\,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $494\,317\,259$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $119\,932\,439$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.242622
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $8\,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1\,513\,641\,376$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $602\,220\,938$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.397862
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $16\,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $916\,432\,321$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $908\,309\,218$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.991136
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4\,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4\,890\,723\,902$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $790\,592\,155$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.161651
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4\,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $374\,374\,889$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $44\,696\,952$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.119390
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $8\,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2\,657\,833\,500$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $388\,786\,325$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.146279
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $16\,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4\,201\,582\,569$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $669\,228\,047$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.159279
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4\,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4\,939\,903\,038$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $596\,019\,198$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.120654
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4\,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $35\,295\,413\,593$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1\,791\,402\,821$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.050754
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Effectiveness of bounds reduction after lifting to top 
\begin_inset CommandInset label
LatexCommand label
name "tab:Lift-to-Top-optimization"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The data in this table supports two conclusions.
 First, that the optimization is more effective for the relatively compact-but-d
ifficult clustered random cases than for the large-but-simpler random games.
 Second, that it is more effective for the two-sided approach than the one-sided
 approach.
 For the two-sided approach, the optimization speeds up solving by a factor
 6-10, while for the one-sided approach a factor 1-6 seems more typical.
\end_layout

\begin_layout Standard
It should be noted that the benefit of enabling the optimization varies
 greatly between individual cases, though it is never detrimental.
 For example, the third row of the table shows a set of 29 cases which benefit
 little from the optimization.
 On the other hand, one of the 18 cases reported in the last row required
 27 billion lifts; nearly 30 times as much as the roughly 900 million lifts
 required with the optimization enabled.
 (Excluding this outlier would nearly double the ratio from 0.050754 to 0.107564
 for the last row.)
\end_layout

\begin_layout Standard
Because of these large individual differences, the ratios reported should
 be taken with a grain of salt.
 Accurate results would require much larger test cases.
 However, it seems fair to conclude that these benchmark results confirm
 that bounds reduction after lifting to top is an effective way to speed
 up Small Progress Measures in practice, especially for the two-sided approach.
\end_layout

\begin_layout Section
Effectiveness of cycle removal
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi_{8}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi'_{1000}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $G_{8}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $G'_{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SPM
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.539
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31.530
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
196.639
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
216.342
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
51.175
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
61.961
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
139.439
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
128.528
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DeSCC
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
4.096
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28.271
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
37.648
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38.093
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
49.206
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
45.863
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
65.821
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
68.466
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi_{8}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\phi'_{1000}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $G_{8}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $G'_{8}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zielonka
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
425.355
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28.716
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.385
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.085
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13.153
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
7.196
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
8.711
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12.801
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DeSCC
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
3.048
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27.370
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
0.283
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.137
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13.792
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12.577
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18.996
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16.501
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Effectiveness of cycle removal on nonrandom cases (time in seconds) 
\begin_inset CommandInset label
LatexCommand label
name "tab:Decycle-effectiveness-spgip"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Decycle-effectiveness-spgip"

\end_inset

 shows how preprocessing the game using cycle removal (Decycle) and/or decomposi
tion into strongly connected components (DeSCC) affects the total running
 time for nonrandom testcases.
 For Small Progress Measures, the predecessor lifting strategy in the improved
 framework was used.
 The bold figures mark the lowest solution time among the four possible
 configurations.
 These results show that in most cases SCC decomposition is more effective
 than cycle removal.
 However, in the fair elevator case (
\begin_inset Formula $G_{8}$
\end_inset

) cycle removal provides clear benefits.
\end_layout

\begin_layout Standard
These results are not entirely unsurprising since the games for 
\begin_inset Formula $\phi'$
\end_inset

 contain no winner-controlled cycles except for a single vertex with maximum
 priority that contains a loop, so in these cases, cycle removal is equivalent
 to loop removal.
 The games for 
\begin_inset Formula $\phi$
\end_inset

 contain a similar loop, and also a small winner-controlled cycle for the
 other player with a large attractor set that allows roughly half of the
 game to be solved by the decycle solver.
 Surprisingly, this appears to benefit Zielonka's recursive algorithm, but
 not Small Progress Measures.
 However, cycle removal still is not very useful there, because better results
 can be achieved by only applying SCC decomposition.
 (This reinforces the idea, as suggested in 
\begin_inset CommandInset citation
LatexCommand cite
key "friedmann2009solving"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand cite
key "gazda2013zielonka"

\end_inset

, that Zielonka's algorithm performs best when combined with SCC decomposition.)
\end_layout

\begin_layout Standard
For the fair elevator case, it is interesting that cycle removal combined
 with SCC decomposition yields best results when solving with Small Progress
 Measures, but adding SCC decomposition only slows down Zielonka's algorithm
 in this case.
\end_layout

\begin_layout Standard
Finally, it should be noted that in all cases where the preprocessing increased
 the total solving time, manual inspection of the solver output showed that
 this increase can be entirely ascribed to the time spent on preprocessing.
 The time spent by the general solver never increases, so these preprocessing
 steps do not seem to increase the difficulty of the underlying games.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unclustered Random
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Clustered Random
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zielonka
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decycle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
8.889
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.838
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26.373
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16.044
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DeSCC
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22.795
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.817
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27.346
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
14.838
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Effectiveness of cycle removal on nonrandom cases (time in seconds) 
\begin_inset CommandInset label
LatexCommand label
name "tab:Decycle-effectiveness-random-games"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Decycle-effectiveness-random-games"

\end_inset

 shows the running times on random graphs of 
\begin_inset Formula $10^{7}$
\end_inset

 vertices, average outdegree 3 and 10 different priorities.
 The clustered games are generated with cluster size 100.
 Runing times are averaged over 10 trials per configuration with different
 random graphs (though resulting timings varied little).
 Since these games are much too large to solve with Small Progress Measures,
 which already gets stuck on graphs with a few hundred thousand vertices,
 benchmarks have been performed using Zielonka's recursive algorithm only,
 which tends to be very effective at solving random games.
\end_layout

\begin_layout Standard
In fact, Zielonka's algorithm is so effective that solving the unclustered
 random games directly is faster than applying any sort of preprocessing.
 SCC decomposition adds 14 seconds of preprocessing overhead (without benefit,
 since these games tend to consist of one large component) and although
 cycle removal can solve such games entirely without invoking the general
 solver, this still takes somewhat longer than solving the game directly.
\end_layout

\begin_layout Standard
The clustered random games are somewhat more difficult to solve, and here
 the preprocessing algorithms are benefical.
 Roughly 90% of the game can be solved using cycle removal, and running
 SCC decomposition afterwards further simplifies the problem.
 In these cases, preprocessing operations actually speed up the solution
 process.
\end_layout

\begin_layout Standard
To summarize, cycle removal is highly effective on random games, on which
 SCC decomposition is not effective at all.
 However, Zielonka's algorithm is already quite good at solving random games
 (especially of the unclustered variety) so this benefit applies primarily
 to Small Progress Measures.
 However, results on clustered random games show that even Zielonka's algorithm
 can benefit from these optimizations.
\end_layout

\begin_layout Standard
On nonrandom cases, the results are mixed: in only one of the four cases
 described here cycle removal caused a significant speedup.
 However, the fact that such cases exist suggests that it is a useful feature
 to support.
\end_layout

\begin_layout Chapter
Conclusion
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quickly summarize results and explain how they relate to the research question;
 describe how my research improved the state of the art (which was the research
 goal): better understanding what works for SPM.
\end_layout

\begin_layout Plain Layout
Hopefully, we can get some useful conclusion like "I've found a lifting
 strategy that works well" and "I found an efficient way to solve a parity
 game concurrently" (this can be quantified pretty well since we have a
 serial algorithm to compare with).
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Future work
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe any untested hypotheses (things I thought about but don't have
 any results on).
 Describe possible ways to extend/improve the research.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Symbolic solving
\end_layout

\begin_layout Standard
Throughout this project, I worked with an explicit representation of the
 parity game graph.
 Although this representation is simple and efficient to work with, these
 graphs are often large and difficult to generate efficiently from higher-level
 problems, creating a performance bottleneck even before the parity game
 solver is invoked.
 When used as a vehicle for formal verification, generating and solving
 parity games symbolically might be a more practical approach.
\end_layout

\begin_layout Standard
Suitable symbolic representations would also allow infinite game graphs
 to be encoded, allowing entirely new classes of games to be solved.
 Zielonka's algorithm is already known to work on infinite graphs and can
 probably be adapted to a symbolic representation, although how well it
 performs in that case remains to be seen.
 It seems likely that other algorithms can be adapted to work on symbolic
 representations too.
\end_layout

\begin_layout Subsection
Concurrent and/or distributed solving
\end_layout

\begin_layout Standard
Although computer hardware is still getting exponentially faster over time,
 most performance gains recently have been effected by increasing the number
 of processor cores per chip, rather than increasing the base clock frequency
 of each core.
 This means that algorithms cannot be expected to scale up with the increase
 in processing power available unless they efficiently scale to multiple
 cores.
\end_layout

\begin_layout Standard
Currently, the best available parity game solvers run only sequentially.
 Although I have tried to develop concurrent (shared memory) and distributed
 (message passing) versions of my solvers, these did not exhibit comparable
 performance to their sequential counterparts, and (arguably worse) they
 did not even scale very well.
 Localizing the work performed and minimizing the required communication
 (either through message passing or shared data structures) between processes
 is difficult.
 Although some previous work has been done parallellizing Small Progress
 Measures, and not entirely without success, the resulting solvers still
 could not outperform more sophisticated algorithms (or even more sophisticated
 variants of Small Progress Measures, such as those discussed in this report).
\end_layout

\begin_layout Standard
The question of how to design efficient, non-sequential solvers that are
 at least competitive with sequential solvers, but also scale better when
 more processor cores are allocated to them, remains open.
 Finding a satisfactory answer would be a likely topic of future work.
\end_layout

\begin_layout Standard
A somewhat easier task, to start with, would be to efficiently parallellize
 the various preprocessing steps that greatly help solving parity games
 in practice: decomposition into strongly-connected components, removal
 of winner-controlled loops, solving single-player games, construction of
 subgames, and so on.
 (Note that some of these subproblems, such as identifying strongly-connected
 components, have been studied before and may already have adequate parallel
 formulations.) Even when these subproblems are solved, integrating their
 solutions into an efficient solver without introducing sequential performance
 bottlenecks is a challenge on its own.
\end_layout

\begin_layout Subsection
More efficient Strategy Improvement
\end_layout

\begin_layout Standard
My project revolved mainly around Jurdziński's Small Progress Measures algorithm
, and although I managed to make it work more efficiently in many ways,
 it is clear that this is not the preferred algorithm for solving parity
 games in practice.
 Parity game researchers (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Related-work"

\end_inset

: Related Work) typically suggest that algoritms based on Strategy Improvement
 should perform best in practice, but these games have not been investigated
 here at all.
\end_layout

\begin_layout Standard
The baseline for performance of these algorithms is set by PGSolver.
 Since my work showed that with careful design and implementation, large
 performance gains over this baseline are possible with Small Progress Measures
 and Zielonka's algorithm, it seems reasonable to suspect that future work
 on (Optimal) Strategy Improvement could yield similar results.
\end_layout

\begin_layout Subsection
Better benchmark cases
\end_layout

\begin_layout Standard
Finally, empirical research on parity games seems to be hampered by the
 lack of a clearly established problem domain.
 Consequently, there is no commonly accepted set of benchmark cases to evaluate
 solvers by, which makes it difficult to compare the various different approache
s fairly, and introduces the problem that the result of an empirical evaluation
 depends greatly on the benchmark set chosen by the evaluator.
\end_layout

\begin_layout Standard
Although different kinds of problems may call for different approaches (and
 thus different results in practice are not necessarily an indication of
 bad scientific work) an absolute, objective assessment of solvers is impossible
 without a predetermined, well-understood and commonly agreed-upon benchmark
 set.
 Such benchmark sets are common in other areas of research; for example,
 lossless data compression algorithms are typically benchmarked on the Calgary
 or Canterbury corpus.
 There is no equivalent benchmark set for parity game solvers.
 As a result, different researchers use different methods of evaluation,
 sometimes reaching different conclusions, which becomes problematic when
 test case details are underspecified and results are presented in a way
 that makes them appear more general than they really are.
\end_layout

\begin_layout Standard
It is not obvious what kind of games parity game solver should be tested
 on.
 Many practitioners choose to benchmark on randomly generated games, which
 are easy to generate, but do not look like anything that arises in practice.
 The same objection applies to synthetic games designed to elicit worst-case
 performance in some of the published algorithms.
 On the other hand, many games that do occur in practice (by converting
 a model checking problem into a parity game, for example) appear to be
 structurally weak, even if they are large: they often have few different
 priorities, only a single controlling player, or can be simplified and
 solved mainly using preprocessing techniques rather than invoking the parity
 game algorithm proper.
\end_layout

\begin_layout Standard
To advance the state of the art, it would be useful to define the problem
 domain for parity game solvers more clearly, as well as to describe how
 test cases may be drawn from this domain, ideally resulting in a standard
 benchmark set that can be used to compare solvers in practice.
 Such a benchmark set would be invaluable for future empirical work.
\end_layout

\begin_layout Chapter
TODO LIST
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- have I described everything I came up with?
\end_layout

\begin_layout Plain Layout
- should I say `minimum' or `minimal' fixed point?
\end_layout

\begin_layout Plain Layout
The following comes from an old version of the thesis; probably need to
 work this in somehow:
\end_layout

\begin_layout Plain Layout
- Explain how parity games relate to binary equation systems, mu-calculus.
 This basically motivates why research into parity games is of practical
 interest.
 Explain that improving practical performance is of interest even if computation
al complexity doesn't improve.
 (This is critical for motivating research into lifting heuristics and parallel
 algorithms.)
\end_layout

\begin_layout Plain Layout
- Need a 
\begin_inset Quotes eld
\end_inset

research question
\begin_inset Quotes erd
\end_inset

-like section that contains the research question from my proposal.
\end_layout

\begin_layout Plain Layout
- Describe globally what I'm going to do to improve the state of the art:
 Mainly two parts: (0.
 efficient implementation of existing algorithms => not really interesting
 on an academic level) 1.
 find better heuristics for small progress measures (detailed evaluation
 of SPM would be novel?) 2.
 find good way to parallelize small progress measures (this would be somewhat
 novel, although a lockfree implementation exists)
\end_layout

\begin_layout Plain Layout
- Note that source code + documentation is available online/at request
\end_layout

\begin_layout Plain Layout
- 
\begin_inset Quotes eld
\end_inset

small progress measures
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Small Progress Measures
\begin_inset Quotes erd
\end_inset

? (Be consistent!)
\end_layout

\begin_layout Plain Layout
- Finally: spell check!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "bibtotoc,plainurl"

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
Raw benchmark results
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
begingroup
\end_layout

\begin_layout Plain Layout

%
\backslash
setlength{
\backslash
LTleft}{-20cm plus -1fill}
\backslash
setlength{
\backslash
LTright}{
\backslash
LTleft}
\end_layout

\begin_layout Plain Layout

%
\backslash
scriptsize
\end_layout

\begin_layout Plain Layout

%
\backslash
begin{longtable}{l|r r r r r r r r r r r r|r r r r r r r r r r r r}
\end_layout

\begin_layout Plain Layout

%
\backslash
caption{Small Progress Measure benchmark on random graphs (seconds)}
\end_layout

\begin_layout Plain Layout

%
\backslash
label{somelabelshouldgohere} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

%& l:0 & l:1 & p:0 & p:1 & P:0 & P:1 & M:0 & M:1 & M:2 & m:0 & m:1 & m:2
 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
hline
\end_layout

\begin_layout Plain Layout

%
\backslash
endhead
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

%
\backslash
multicolumn{25}{r}{{Continued on next page...}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
endfoot
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

%
\backslash
hline 
\backslash
hline
\end_layout

\begin_layout Plain Layout

%
\backslash
endlastfoot
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

%
\backslash
ExpandableInput{results-tests4-seconds.tex}
\end_layout

\begin_layout Plain Layout

%
\backslash
end{longtable}
\end_layout

\begin_layout Plain Layout

%
\backslash
endgroup
\end_layout

\end_inset


\end_layout

\end_body
\end_document
