#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Title goes here
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
A 
\emph on
parity game
\emph default
 is a game played by two players, called Even and Odd, on a directed graph.
 Each vertex in the graph is associated with (
\emph on
owned
\emph default
 or 
\emph on
controlled
\emph default
 by) one of the two players.
 Furthermore, to each vertex a 
\emph on
priority
\emph default
 is assigned, which is a non-negative integer.
 The picture below visualizes one possible parity game:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
picture here
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are different conventions for the names of players.
 They can be called Even and Odd, or denoted by symbols ◇ and ◻, which is
 particularly useful when visualizing games, as can be seen in the picture
 above: the shape of the vertices corresponds with the players that control
 them.
 For the description of algorithms and data structures, especially when
 computations are involved, it is more convenient to use integers 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

.
 For example, if we consider a player 
\begin_inset Formula $x$
\end_inset

, his opponent can be described as 
\begin_inset Formula $1-x$
\end_inset

.
 For consistency, I will only use 0 and 1 here.
\end_layout

\begin_layout Standard
A parity game can therefore be described by a four-tuple 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

, where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V_{\text{0}}$
\end_inset

 and 
\begin_inset Formula $V_{\text{1}}$
\end_inset

 partition the set of vertices 
\begin_inset Formula $V=V_{0}\cup V_{1}$
\end_inset

 in the graph into vertices belonging to 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
Even and Odd respectively.
 
\begin_inset Formula $E$
\end_inset

 is the set of edges in the game graph.
 Note that 
\begin_inset Formula $E$
\end_inset

 is a true set: every ordered pair of vertices has at most one edge between
 them.
 Duplicate edges are not allowed, but loops (edges which lead from a vertex
 back to itself) may occur.
 
\begin_inset Formula $\phi:V\rightarrow\mathbb{N}_{0}$
\end_inset

 is the priority function that assigns a priority to every vertex in the
 graph.
 The number of distinct priority values assigned to vertices in the game,
 is called the 
\emph on
order of the game
\emph default
, wich is equal to the cardinality of the range of 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
Parity games can be played on finite as well as infinite graphs.
 A parity game is called finite if it is played on a graph with a finite
 number of vertices.
 Consequently, the number of edges will be finite too (since the edge set
 is 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
a subset of
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V\times V$
\end_inset

)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
.
 Finally, because the number of distinct priorities is bounded by 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left|V\right|$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
, the order of a finite game is finite as well.
\end_layout

\begin_layout Subsection
Game Play and Winning Conditions
\end_layout

\begin_layout Standard
A parity game is played by placing a token on some initial vertex.
 The player to whom the vertex belongs makes a move by moving the token
 to an adjacent vertex, which may belong to either player, who then makes
 the next move.
 When the token lands on a vertex without any outgoing edges, the game ends.
 However, it is more common for a game to continue indefinitely, causing
 an infinite sequence of moves.
 This sequence of moves on the graph is called a 
\emph on
play
\emph default
 and it can be described as the sequence of vertices visited by the token.
 Formally, 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is a play if 
\begin_inset Formula $\forall i\in\mathbb{N}\; v_{i}v_{i+1}\in E$
\end_inset

.
 A finite subsequence of a play that ends on a vertex with outgoing edges
 is called a 
\emph on
partial play
\emph default
.
\end_layout

\begin_layout Standard
For finite plays, the loser of the game is the player who is first unable
 to move.
 His opponent is the winner.
 In a finite play, the loser is therefore simply the controller of the final
 vertex in the play.
\end_layout

\begin_layout Standard
For infinite plays, we first define the 
\emph on
dominant priority
\emph default
 
\begin_inset Formula $P(\pi)$
\end_inset

 for a play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 as the smallest value that occurs infinitely often in the sequence 
\begin_inset Formula $\phi(v_{1})\phi(v_{2})\ldots$
\end_inset

 or formally: 
\begin_inset Formula $P(\pi)=\min\left\{ p\in\mathbb{N}_{0}:\left|\left\{ i\in\mathbb{N}:\phi(v_{i})=p\right\} \right|=\aleph_{0}\right\} $
\end_inset

.
 A play is won by player Even if the dominant priority for the play is even,
 and won by Odd otherwise (hence their names).
 When the set of priorities is finite, the dominant priority is well-defined,
 assigning a winner to every infinite play.
\end_layout

\begin_layout Standard
It should be noted that there is no consensus in literature on priorities
 should be ordered.
 Throughout this report I will use the convention of lower priority values
 having precedence over higher values, thus 
\begin_inset Formula $0$
\end_inset

 being the 
\begin_inset Quotes eld
\end_inset

highest
\begin_inset Quotes erd
\end_inset

 priority, as described above.
\end_layout

\begin_layout Subsection
Strategies and Solutions
\end_layout

\begin_layout Standard
A strategy for player 
\begin_inset Formula $x$
\end_inset

 assigns a move to each position in which 
\begin_inset Formula $x$
\end_inset

 is to move.
 Formally, the strategy is a function 
\begin_inset Formula $\dot{\sigma}_{x}:V^{*}\times V_{x}\rightarrow V$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 such that if 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=v_{n+1}$
\end_inset

 then 
\begin_inset Formula $v_{1}\ldots v_{n+1}$
\end_inset

 is a partial play.
 A play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is called consistent with a strategy 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
for player 
\begin_inset Formula $x$
\end_inset

 if 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{i})=v_{i+1}$
\end_inset

 for all 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $v_{i}\in V_{x}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
.
\end_layout

\begin_layout Standard
A strategy 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called 
\emph on
winning
\emph default
 for player 
\begin_inset Formula $x$
\end_inset

 at starting vertex 
\begin_inset Formula $v_{1}$
\end_inset

 if all plays 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 consistent with 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 are won by player 
\begin_inset Formula $x$
\end_inset

.
 Parity games of a finite order have the important property that they are
 fully 
\emph on
determined
\emph default
, i.e.
 for every starting vertex either player Even or player Odd has a winning
 strategy 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: reference proof; Borel determinancy
\end_layout

\end_inset

.
 Thus, for these games, we can partition the vertex set 
\begin_inset Formula $V$
\end_inset

 of the game graph into two sets of vertices 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

 which can be won by player Even and Odd respectively.
 When the order is infinite, we can still identify disjoint sets 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

, but they may not be a true partition.
\end_layout

\begin_layout Standard
In many practical applications, determination of winning sets is enough
 to constitute a solution.
 For example, when using parity games as a vehicle for model checking, the
 question whether a formal property holds corresponds with the question
 wether a particular vertex in a game graph is won by player Even or Odd.
 In this case, partitioning the vertices into winning sets is sufficient
 to determine whether the property holds.
 In fact, in this case it would suffice to determine which player wins from
 this particular vertex (without fully determining winning sets).
\end_layout

\begin_layout Standard
A possible objection against determining winning sets without associated
 strategies is that even if we assume the output to be correct, the winning
 sets alone do not provide any insight in 
\emph on
why
\emph default
 a particular vertex is won by a particular player.
 Strategies can be useful to understand the outcome of the games.
 In the application of model checking, strategies can be used to generate
 counter-examples to a desired property when it turns out it doesn't hold.
 Moreover, if we have not just a winning set, but also associated strategies,
 we can readily verify their correctness (as will be described in detail
 later).
\end_layout

\begin_layout Standard
Therefore, 
\emph on
solving a game
\emph default
 in the most general sense means to identify optimal strategies for both
 players in addition to winning sets for both players.
 A solution therefore is a triple 
\begin_inset Formula $W_{0},W_{1},\sigma$
\end_inset

.
 We require that 
\begin_inset Formula $\sigma$
\end_inset

 is defined at least for all vertices 
\begin_inset Formula $(V_{0}\cap W_{0})\cup(V_{\text{1}}\cap W_{1})$
\end_inset

.
 Note that even in finite games, strategies (unlike winning sets) do not
 complement each other, so given an optimal strategy for one player, we
 cannot (easily) deduce the strategy for his opponent.
 
\end_layout

\begin_layout Subsection
Optimal Strategies and Finite Memory
\end_layout

\begin_layout Standard
A strategy 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called an 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
optimal strategy
\emph default
 when it is winning for player 
\begin_inset Formula $x$
\end_inset

 starting from any vertex 
\begin_inset Formula $v\in W_{x}$
\end_inset

.
\end_layout

\begin_layout Standard
A strategy, as described above, is called an
\emph on
 infinite-memory strategies
\emph default
, because they can take the entire move history into account to determine
 the next move.
 In contrast, 
\emph on
memoryless strategies
\emph default
 are strategies which only depend on the last vertex visited by the token,
 i.e.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=\dot{\sigma}_{x}(w_{1}\ldots w_{n})$
\end_inset

 whenever 
\begin_inset Formula $v_{n}=w_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
We will define memoryless strategies as functions 
\begin_inset Formula $\sigma_{x}:V_{x}\rightarrow V$
\end_inset

 such that if
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\sigma_{x}(v)=w$
\end_inset

 then 
\begin_inset Formula $vw\in E$
\end_inset

.
 A memoryless strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

is then consistent with a play 
\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset

 if 
\begin_inset Formula $\sigma_{x}(v_{i})=v_{i+1}$
\end_inset

 for all 
\begin_inset Formula $v_{i}\in V_{x}$
\end_inset

.
 Without loss of generality, we can restrict the domain of 
\begin_inset Formula $\sigma_{\text{x}}$
\end_inset

 to 
\begin_inset Formula $V_{\text{x}}\cap W_{x}$
\end_inset

 since for vertices in 
\begin_inset Formula $V_{x}$
\end_inset

but not in 
\begin_inset Formula $W_{\text{x}}$
\end_inset

, player 
\begin_inset Formula $x$
\end_inset

 has no winning move, and therefore any adjacent vertex can be selected
 without consequences for the rest of the strategy.
 Even if we leave out these vertices for which the controlling player has
 no winning move, optimal strategies are not (necessarily) uniquely defined,
 unlike winning sets.
\end_layout

\begin_layout Standard
Sometimes we want to refer to the combined strategies of both players, 
\begin_inset Formula $\sigma$
\end_inset

, defined as:
\begin_inset Formula \[
\sigma(v)=\begin{cases}
\sigma_{0}(v) & \mbox{if }v\in V_{0}\\
\sigma_{1}(v) & \mbox{if }v\in V_{1}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
It turns out that for all games of a finite order optimal, memoryless strategies
 exist.
 Zielonka
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset

 gives two proofs of this property.
 Research on finite-order games typically focuses on finding memoryless
 strategies for both players, since these have the desirable property that
 they can be enumerated by simply listing the optimal move for every vertex.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
A consequence of both players following memoryless strategies on a finite
 graph (as pointed out by Jurdziński 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset

) is that play will eventually become periodic.
 In other words, for every play 
\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset

 there is some starting point 
\begin_inset Formula $k$
\end_inset

 and a period 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $v_{i}=v_{i+n}$
\end_inset

 for all 
\begin_inset Formula $i\geq k$
\end_inset

.)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For brevity, since this report is about finding optimal strategies to finite
 parity games, we will use the term 
\emph on
strategy
\emph default
 without further qualification to mean 
\emph on
optimal memoryless strategy
\emph default
.
\end_layout

\begin_layout Subsection
Restrictions on the graph
\end_layout

\begin_layout Standard
For convenience, I will assume some restrictions on the structure of the
 graph, which simplify the design and analysis of the data structures and
 algorithms involved considerably, but which do not diminish the practical
 utility of parity games algorithms.
 Of these, the first two properties are simplifications that do not limit
 the classes of games that can be analyzed in general.
 Only the third restriction is a true restriction in a theoretical sense.
\end_layout

\begin_layout Enumerate
Every vertex has at least one outgoing edge.
\end_layout

\begin_layout Enumerate
The graph is connected.
\end_layout

\begin_layout Enumerate
The graph is finite.
\end_layout

\begin_layout Standard
The first property makes finite plays impossible, which simplifies the analysis
 of many algorithms.
 We will call a game a 
\emph on
proper game
\emph default
 if its graph satisfies this property.
 However, improper games (whose game graphs contain vertices with no outgoing
 edges) can be turned into proper games by considering each vertex without
 outgoing edges.
 If it is controlled by player 
\begin_inset Formula $x$
\end_inset

, we can change its priority to 
\begin_inset Formula $1-x$
\end_inset

 and add an edge from the vertex back to itself.
 In the modified graph every vertex has an outgoing edge, yet it has the
 same solution and winning strategies as the original graph.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Does this need proof?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second property does not restrict the classes of games that can be solved
 either.
 During a play, the token never leaves the (weakly) connected component
 of the graph that it starts in, so for any unconnected graph, we can decompose
 the graph into weakly connected components, analyze these components individual
ly, and combine the results.
\end_layout

\begin_layout Standard
The final property is a true restriction because it makes it impossible
 to analyze infinite graphs.
 This has practical as well as theoretical benefits.
 From a practical point of view, since all of the game data is now finite,
 it allows us to represent graphs explicitly using only finite memory (otherwise
, we would need a symbolic representation).
 From a theoretical point of view, a finite vertex set allows for algorithms
 and proofs that do not generalize to infinite graphs.
 In particular, the winner of any play can be decided, because the order
 of the graph is finite.
\end_layout

\begin_layout Subsection
Restrictions on the set of priorities
\end_layout

\begin_layout Standard
When discussing actual implementations of data structures and algorithms,
 it is convenient to assume that the priorities in the game are not just
 integers, but bounded by a value that is as small as possible.
 Fortunately, we can reduce the values of priorities used to a range between
 0 and 
\begin_inset Formula $d$
\end_inset

 (exclusive), where 
\begin_inset Formula $d$
\end_inset

 is the order of the game.
 This is done by remapping priorities for vertices in a process called 
\emph on
priority compression.

\emph default
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite: PGSolver manual? or an earlier paper?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider we have a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 and we wish to apply priority compression.
 To do so, we find the first unused priority (say, 
\begin_inset Formula $p$
\end_inset

) in the game.
 If 
\begin_inset Formula $p=d$
\end_inset

 then all priorities from 
\begin_inset Formula $0$
\end_inset

 through 
\begin_inset Formula $d-1$
\end_inset

 (inclusive) are used and since the order of the game is 
\begin_inset Formula $d$
\end_inset

 this means we are done.
 Otherwise, let 
\series bold

\begin_inset Formula $q$
\end_inset


\series default
 be the least priority greater than 
\begin_inset Formula $p$
\end_inset

 that is used.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $p=0$
\end_inset

 then we can decrement all priorities by 
\begin_inset Formula $q$
\end_inset

 and, if 
\begin_inset Formula $q$
\end_inset

 is odd, we additionally switch the roles of players Even and Odd.
 Formally, we construct a game 
\begin_inset Formula $\Gamma'=(V_{\text{0}}',V_{\text{1}}',E',\phi')$
\end_inset

 where 
\begin_inset Formula $V_{x}'=V_{y}$
\end_inset

 and 
\begin_inset Formula $x=y-p\mod{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
, 
\begin_inset Formula $\phi'(v)=\phi(v)-q$
\end_inset

 and 
\begin_inset Formula $E'=E$
\end_inset

.
\end_layout

\begin_layout Standard
If, however, 
\begin_inset Formula $p>0$
\end_inset

 then we keep 
\begin_inset Formula $V_{0}'=V_{0}$
\end_inset

 and 
\begin_inset Formula $V_{1}'=V_{1}$
\end_inset

.
 However, if 
\begin_inset Formula $p\equiv q\mod{2}$
\end_inset

then we get rid of the unused priorities and lump the vertices with priority
 
\begin_inset Formula $q$
\end_inset

 in with those with priority 
\begin_inset Formula $p$
\end_inset

.
 After all, 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 have the same parity, and since none of the values in between are used,
 they can be interchanged without affecting the outcome of the game.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Does this need proof?
\end_layout

\end_inset

 More formally, in this case we define 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi'(v)$
\end_inset

 as:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 
\begin_inset Formula \[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q & \mbox{\mbox{if }\ensuremath{\phi(v)>p}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $p-q\equiv0\mod{2}$
\end_inset

 we have preserved parity: 
\begin_inset Formula $\phi'(v)\equiv\phi(v)\mod{2}$
\end_inset

.
 Finaly, if 
\begin_inset Formula $p>0$
\end_inset

 and 
\begin_inset Formula $p\not\equiv q\mod{2}$
\end_inset

 then we can remove the unused priorities, but we do not want to equate
 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 which have different priorities:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q+1 & \mbox{\mbox{if} \ensuremath{\phi(v)<p}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Again, since 
\begin_inset Formula $p-q+1\equiv0\mod{2}$
\end_inset

 this preserved the parity of 
\begin_inset Formula $\phi$
\end_inset

 while removing the unused priorities between 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 We need to repeat the process described here for every gap in the set of
 used priorities (which is at most 
\begin_inset Formula $d$
\end_inset

 times) and the result will always be a set of 
\begin_inset Formula $d$
\end_inset

 used priorities from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $d-1$
\end_inset

 (inclusive).
\end_layout

\begin_layout Standard
Most solving algorithms do not require that priorities are compressed into
 a minimal range, but the maximum occurring priority usually is a component
 in the total amount of time or memory required.
 Therefore, it is useful to preprocess every game to minimize the priority
 set in this way, especially since this can be easily done in time linear
 in the number of vertices, which makes it a relatively inexpensive operation.
\end_layout

\begin_layout Subsection
Common Terminology
\end_layout

\begin_layout Standard
There are a number of concepts which can be applied to parity games which
 have been described in literature before.
 In particular, Zielonka introduces some useful terminology in a treatise
 on two-player games played on coloured graphs (of which parity games are
 a subset) which will be repeated here.
 He describes attractor sets and traps.
 Additionally, I will describe subgames analogous to (though slightly different
 from) subarenas.
\end_layout

\begin_layout Subsubsection
Subgames
\end_layout

\begin_layout Standard
A 
\emph on
subgame
\emph default
 of a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 induced by a vertex set 
\begin_inset Formula $U\subseteq V$
\end_inset

 is the game 
\begin_inset Formula $\Gamma|U=(V_{\text{0}}\cap U,V_{\text{1}}\cap U,E\cap\left(U\times U\right),\phi|U)$
\end_inset

 where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi|U$
\end_inset

 denotes 
\begin_inset Formula $\phi$
\end_inset

 with its domain limited to 
\begin_inset Formula $U$
\end_inset

.
 In other words, the game obtained when only considering vertices from 
\begin_inset Formula $U$
\end_inset

 and ignoring the rest.
 
\begin_inset Formula $\Gamma|U$
\end_inset

 is called a 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
proper subgame
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 if every vertex in 
\begin_inset Formula $U$
\end_inset

 has at least one successor also in 
\begin_inset Formula $U$
\end_inset

 (in other words, it simply is a proper game as described above).
\end_layout

\begin_layout Subsubsection
Traps
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $vE$
\end_inset

 be the set of vertices which are successors of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $E$
\end_inset

, or formally 
\begin_inset Formula $vE=\left\{ w|vw\in E\right\} .$
\end_inset

 A non-empty vertex set 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $U\subseteq V$
\end_inset

 is a trap for player 
\begin_inset Formula $x$
\end_inset

 (or an 
\begin_inset Formula $x$
\end_inset

-trap, for short) when, informally, player 
\begin_inset Formula $x$
\end_inset

 cannot force the token out of 
\begin_inset Formula $U$
\end_inset

.
 Formally, 
\begin_inset Formula $U$
\end_inset

 is an 
\begin_inset Formula $x$
\end_inset

-trap if for all 
\begin_inset Formula $v\in U$
\end_inset

:
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \[
v\in V_{x}\rightarrow vE\subseteq U\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \[
v\in V_{1-x}\rightarrow vE\cap U\neq\emptyset\]

\end_inset


\end_layout

\begin_layout Subsubsection
Attractor sets
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Define attractor set.
\end_layout

\begin_layout Plain Layout
Describe duality between attractor sets and traps (complement of attractor
 set is a trap).
 Note that traps formed this way are always proper subgames.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Degenerate cases
\end_layout

\begin_layout Standard
In addition to games which do not comply with the restrictions mentioned
 above, there are also a few classes of degenerate games that are special
 cases of the general game describe above.
 There are mentioned separately because specific algorithms exist to solve
 them quicker than is possible for the general case.
\end_layout

\begin_layout Standard
These special cases are occasionally provided as input to a solver (for
 example, as the representation of a particularly simple model checking
 problem) but more commonly they arise after applying a number of reduction
 or partial solution techniques, as subproblems to be solved.
 Treating these cases separately can provide benefits in particular cases.
\end_layout

\begin_layout Subsubsection
Single-player games
\end_layout

\begin_layout Standard
A parity game is a 
\emph on
single-player game for player 
\begin_inset Formula $x$
\end_inset

 
\emph default
when all vertices controlled by player 
\begin_inset Formula $1-x$
\end_inset

 have outdegree equal to 1.
 In such a game, only player 
\begin_inset Formula $x$
\end_inset

 can make choices, and player 
\series bold

\begin_inset Formula $1-x$
\end_inset


\series default
 is forced to always move the token to the single available successor whenever
 it lands on one of his vertices.
\end_layout

\begin_layout Standard
In such a game, player 
\begin_inset Formula $x$
\end_inset

 wins from precisely from the vertices which lie on a cycle of which the
 minimum priority has parity equal to 
\begin_inset Formula $x$
\end_inset

, as well as from all vertices from which such a cycle can be reached.
 After all, his opponent has no choice, so he can never force the token
 out of a cycle or prevent player 
\begin_inset Formula $x$
\end_inset

 from reaching a cycle when there exists a path to it.
 The remaining vertices (if there are any) are won by player 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
In extremely rare cases the game is played on a cycle graph and neither
 player has a choice.
 In that case, strategies are trivial and whichever player has the dominant
 priority on the cycle wins from any vertex in the game.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: describe how to solve; similar to verification algorithm below.
 Maybe compare with PGSolver (if that's different).
 Otherwise, move details from verification to here.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Single-parity games
\begin_inset CommandInset label
LatexCommand label
name "sub:Single-priority-games"

\end_inset


\end_layout

\begin_layout Standard
If the priorities of vertices all have the same parity (even or odd) then
 the corresponding player will trivially win from every starting vertex,
 with an arbitrary strategy.
 A special case is the single-priority game, where only a single priority
 is used.
 Note that priority compression will reduce both single-parity and single-priori
ty games to a game in which 0 is the only priority in use, making this type
 of game easy to recognize.
\end_layout

\begin_layout Subsubsection
Graph decomposition
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe solving strongly connected components invidiually (not really a
 degenerate case but OK)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
What other simplifications/special cases have been identified.
\end_layout

\begin_layout Plain Layout
Browse PGSolver docs/Jeroen's thesis for stuff worth repeating here.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Verification of Strategies
\end_layout

\begin_layout Standard
Altough it is hard to compute the optimal strategies for the players in
 a parity game, it is much easier to verify that a pair of a winning sets
 and associated strategies are sound.
 To verify winning sets, it would suffice to solve a parity game with a
 known-good algorithm and then compare if the result is equal.
 This isn't possible for strategies, which are generally not unique, so
 even if we obtain an optimal strategy, this does not imply that different
 strategies are invalid.
 Therefore, we need a separate algorithm to verify strategies.
\end_layout

\begin_layout Standard
As we noted before, we are only interested in the strategy for vertices
 that are in the winning set of the player that controls them.
 Assume we are verifying the set 
\begin_inset Formula $W_{x}$
\end_inset

 with optimal strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 for player 
\begin_inset Formula $x$
\end_inset

.
 Define a graph with vertices limited to 
\begin_inset Formula $W_{x}$
\end_inset

 and the set of edges 
\begin_inset Formula $E|\sigma_{x}$
\end_inset

 as follows:
\begin_inset Formula \[
E|\sigma_{x}=\left\{ vw\in E:v\in\left(W_{x}\cap V_{x}\right)\wedge\sigma_{\text{x}}(v)=w\right\} \cup\left\{ vw\in E:v\in\left(W_{x}\cap V_{1-x}\right)\right\} \]

\end_inset


\end_layout

\begin_layout Standard
Less formally, the edge set includes the edges that are consistent with
 
\begin_inset Formula $x$
\end_inset

's strategy, as well as all edges originating at vertices controlled by
 his opponent.
 We must first verify two trivial properties:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $E|\sigma_{x}\subseteq E$
\end_inset

 (otherwise the strategy 
\begin_inset Formula $\sigma_{\text{x}}$
\end_inset

 prescribes a transition that is not available in the original game graph)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $E|\sigma_{x}\subseteq W_{\text{x}}\times W_{x}$
\end_inset

 (otherwise either the player or his opponent can move the token outside
 the winning set)
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Assuming these hold, then 
\begin_inset Formula $\Gamma|\sigma_{\text{x}}=(W_{x}\cap V_{x},W_{x}\cap V_{1-x},E|\sigma_{x},\phi|W_{x})$
\end_inset

 is a valid parity game, and precisely those plays in the original game
 consistent with strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 are possible in the game 
\begin_inset Formula $\Gamma|\sigma_{\text{x}}$
\end_inset

 as well, except that all choice for player 
\begin_inset Formula $x$
\end_inset

 has been removed: every vertex controlled by 
\begin_inset Formula $x$
\end_inset

 has only one successor, because 
\begin_inset Formula $x$
\end_inset

 is bound to play by his strategy.
 This makes the game 
\begin_inset Formula $\Gamma|\sigma_{x}$
\end_inset

 a single-player game controlled by player 
\begin_inset Formula $1-x$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: if we have described how to solve single-player games above, it suffices
 to say that we apply the same algorithm here and check if the winning set
 is empty.
 We still need to present complexity analysis of the total algorithm here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To verify that 
\begin_inset Formula $W_{x}$
\end_inset

 is a winning set for player 
\begin_inset Formula $x$
\end_inset

 when playing according to strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

, we must verify that the winning set for player 
\begin_inset Formula $1-x$
\end_inset

 in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\Gamma|\sigma_{\text{x}}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 is empty.

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 As noted earlier, when discussing single-player games, player 
\begin_inset Formula $1-x$
\end_inset

 can win from at least some vertices if (and only if) the graph contains
 a cycle with odd minimum priority (for brevity, let's call this an 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
odd cycle
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
).
 Thus, the final step in the verification process is to prove that no odd
 cycles exists.
\end_layout

\begin_layout Standard
If we call a cycle with minimum priority 
\emph on
i
\emph default
 an 
\emph on
i
\emph default
-cycle, then a directed graph contains a i-cycle if and only if it contains
 any vertices with priority 
\emph on
i
\emph default
 lying on a cycle after removal of all edges incident with vertices of priority
 less than 
\begin_inset Formula $i$
\end_inset

, because an 
\emph on
i
\emph default
-cycle can only include edges between vertices of priority 
\emph on
i
\emph default
 or higher.
 To find an 
\emph on
i
\emph default
-cycle in a graph with edges of priorities 
\emph on
i
\emph default
 or higher, we can use the connection between strongly connected components
 of the graph and a cycle in a graph: every cycle must lie in a single strongly
 connected component (since all vertices in a cycle are by the definition
 part of the same strongly connected component) and if the edge set of a
 strongly-connected component is non-empty, then all vertices in the strongly-co
nnected component must lie on a cycle.
\end_layout

\begin_layout Standard
For each odd priority, we can construct a subgraph with only edges incident
 to vertices of priority 
\emph on
i
\emph default
 or higher, decompose it into strongly connected components, and search
 for an edge incident to at least one vertex of priority 
\emph on
i
\emph default
 inside a single connected component.
 If found, we know that an i-cycle can be constructed in this component.
 If necessary, these i-cycles can be enumerated using a backtracking algorithm,
 but for the purpose of verification it suffices to know that one exists.
\end_layout

\begin_layout Standard
Verifying the first two properties described above takes time linear in
 the number of edges.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
FIXME: current implementation actually uses time less than E for both properties
! (See code.) Need to describe details above.
\end_layout

\end_inset

 Strongly connected components can be found in linear time as well, using
 Tarjan's algorithm
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1971depth"

\end_inset

.
 Because we need to construct a graph (and then find its components) once
 for each distinct priority to verify winning sets and strategies for both
 players, the final verification algorithm runs in 
\begin_inset Formula $O(E+E+d\left|E\right|)=O(d\left|E\right|)$
\end_inset

 worst-case time.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
Zielonka describes strategies for a more general class of games played on
 infinite (or finite) graphs, using colouring of vertices using colours
 from a finite set instead of simple integers, and with a more complex winning
 condition.
 The class of games he describes cannot generally be solved by memoryless
 strategies, but many of the concepts he mentions are applicable to parity
 games.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Borel determinacy; proof of winning strategies for either players
\end_layout

\end_inset


\end_layout

\begin_layout Section
Computational Complexity
\end_layout

\begin_layout Standard
[To write: something about known time complexity in NP and Co-NP (how?)
 and therefore likely to be in P (because otherwise NP=co-NP, which is unlikely).
 Best known complexity of algorithms.
 At least mention Zielonka, SPM and strategy improvement.
 Maybe add section about reduction to other (NP-complete of course) problems.
 Mention that solving games in practice usually takes considerably less
 time than the worst-case complexity suggests.]
\end_layout

\begin_layout Section
Application To Model Checking
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To write.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Common algorithms and data structures
\end_layout

\begin_layout Standard
The results that will be presented later on are based on emperical evaluation
 of various parity game solving algorithms on both synthetic and real-world
 cases.
 The results obtained therefore depend not only on the choice of algorithms,
 but also on various implementation details, such as the data structures
 and programming techniques used to implement those algorithms.
\end_layout

\begin_layout Standard
It has been shown that in practice different experimental tools have different
 performance characteristics despite being based on the same theoretical
 algorithms.
 This phenomon occurs because of undocumented differences in the implementation
 of these different tools, sometimes arising from intentional changes to
 those algorithms (preprocessing operations or optimizations for particular
 instances, for example) and more often because the algorithms described
 in literature are usually not described to a sufficient level of detail
 that they can be implemented without being forced to make concrete implementati
on choices.
 For theoretical analysis this is not necessary (and usually, in the interest
 of conciseness, not desired), but for practical results it matters significantl
y how the missing parts are implemented concretely.
\end_layout

\begin_layout Standard
In order to ensure that results to be presented here are reproducable, and
 to make the differences in results obtained with different tools easier
 to understand and explain, I will document the choices that I made in the
 implementation of my solving tool to a fair amount of detail.
 In particular, the core data structures and the algorithms will be documented
 precisely.
\end_layout

\begin_layout Standard
Finally, the descriptions provided here and in later chapters are a useful
 key to understanding the source code of my solver tool, since it provides
 a high-level overview of its design.
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
Recall that a parity game consists of a directed graph, a partition of vertices
 into sets owned by the two players, and the assignment of a priority to
 every vertex.
 This data must be represented in some way in a solver.
\end_layout

\begin_layout Standard
When executing a solving algorithm, the parity game data is read, but usually
 not modified.
 Therefore, an implementation that allows efficient read-only access is
 more important than a data structure with high flexibility in regards to
 updates.
 However, many of the simplification and preprocessing algorithms must either
 modify the parity game under consideration or be able to quickly produce
 a modified copy of it.
 This use case must be accommodated as well.
\end_layout

\begin_layout Standard
Finally, since practical instances of parity games tend to be fairly large,
 it is desirable that the parity game representation is as compact as possible,
 to the extend this is possible without compromising access speed.
 This not only reduces the amount of memory needed to solve particularly
 large instances, but also ensures that the solving algorithms benefit maximally
 from caching effects.
\end_layout

\begin_layout Subsection
The game graph structure
\end_layout

\begin_layout Standard
A parity game is played on a directed graph, which consists of a set of
 vertices (
\begin_inset Formula $V$
\end_inset

) and a set of edges (
\begin_inset Formula $E\subseteq V\times V$
\end_inset

).
 Vertices will be identified with integers from 0 through 
\begin_inset Formula $\left|V\right|$
\end_inset

 (exclusive).
 At a minimum, we will store 
\begin_inset Formula $\left|V\right|$
\end_inset

 and 
\begin_inset Formula $\left|E\right|$
\end_inset

, the number of vertices and edges in the graph respectively.
\end_layout

\begin_layout Standard
To represent the graph in its entirety, we then only need to store the edges.
 We could store those as an array of pairs of integers (the source and destinati
on vertices of a directed edge).
 This is reasonably compact (requiring 
\begin_inset Formula $2\left|E\right|$
\end_inset

 integers to be stored).
 However, this representation is impractical if we want to quickly access
 a set of successors (
\begin_inset Formula $vE$
\end_inset

) or predecessors (
\begin_inset Formula $Ev$
\end_inset

) of a vertex, which are common operations in many algorithms.
\end_layout

\begin_layout Standard
Therefore, a different representation is used.
 Suppose we start with the array of edges described above and sort them
 by source vertex first, and destination vertex second.
 Then, all the edges from a vertex 
\begin_inset Formula $v$
\end_inset

 to its successors will occur as a consecutive sequence in the edge array,
 and we can describe this as an interval 
\begin_inset Formula $[\mathtt{succBegin[v],\mathtt{succEnd[v]})}$
\end_inset

.
\end_layout

\begin_layout Standard
This representation as described would require 
\begin_inset Formula $2\left|E\right|+2\left|V\right|$
\end_inset

 integers to be stored, and allows the following operations to be performed
 efficiently:
\end_layout

\begin_layout Enumerate
Enumerate the successors of a vertex (
\begin_inset Formula $vE$
\end_inset

), in order.
\end_layout

\begin_layout Enumerate
Calculate the number of successors of a vertex (
\begin_inset Formula $\left|vE\right|$
\end_inset

), by calculating 
\begin_inset Formula $\mathtt{succEnd[v]}-\mathtt{succBegin[v]}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Determine if 
\begin_inset Formula $vw\in E$
\end_inset

 (with binary search, this could take 
\begin_inset Formula $O\left(log\left(\left|vE\right|+1\right)\right)$
\end_inset

 time).
\end_layout

\begin_layout Standard
Of course, the first operation is the one that is used most commonly.
 Additionally, we can apply two simplifications.
 First, since the predecessor vertex of all edges with indices between 
\begin_inset Formula $\mathtt{succBegin[v]}$
\end_inset

 and 
\begin_inset Formula $\mathtt{succEnd[v]}$
\end_inset

 are known to be equal to 
\begin_inset Formula $v$
\end_inset

, we don't need to store predecessor vertices at all.
 Additionally, it is easy to see that 
\begin_inset Formula $\mathtt{succEnd[v]=succBegin[v+1]}$
\end_inset

 for all 
\begin_inset Formula $v$
\end_inset

 except the last vertex, so we can store all indices in a single array of
 length 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left|V\right|+1$
\end_inset

.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
This it the final representation that is used, and requires 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\left|E\right|+\left|V\right|+1$
\end_inset

 integers to store the edge data.
 However, this edge representation only allows us to quickly find successors
 of edges.
 For some algorithms, it's useful to be able to find predecessors quickly
 as well.
 For this reason, the graph data structure by default stores the edge set
 in reverse order too, doubling the amount of memory required.
\end_layout

\begin_layout Standard
It should be noted that this dense edge representation does not allow efficient
 insertion or removal of individual edges in the game graph, because each
 such operation requires a large part of the edge array to be moved.
 Fortunately, the preprocessing algorithms that are applied in the solver
 are applied to the graph as a whole, and the cost of individual changes
 can therefore be amortized over the entire graph-wide operation.
\end_layout

\begin_layout Subsection
The parity game structure
\end_layout

\begin_layout Standard
In addition to the game graph, a parity game must store two attributes for
 each vertex:
\end_layout

\begin_layout Enumerate
The controlling player (Even or Odd), and
\end_layout

\begin_layout Enumerate
the associated priority value, 
\begin_inset Formula $\phi(v)$
\end_inset

.
\end_layout

\begin_layout Standard
These two attributes are packed into a two-byte structure, and stored in
 an array of length 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 Note that this limits the maximum priority that can be represented to 255,
 which seems low, but is much larger than occurs in practice (although synthetic
 cases with larger priorities could easily be generated).
\end_layout

\begin_layout Standard
Additionaly, we store in the parity game structure two properties of the
 game:
\end_layout

\begin_layout Enumerate
The priority limit (
\begin_inset Formula $d$
\end_inset

) which is calculated as the maximum priority value used + 1.
 (This is equal to the order of the game assuming all priority values are
 used.)
\end_layout

\begin_layout Enumerate
An array of integers of length 
\begin_inset Formula $d$
\end_inset

 that stores how many vertices occur with each individual priority value.
\end_layout

\begin_layout Standard
This information can be recomputed from the vertex attributes in time 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

, but it is useful in a number of situations, for example, to quickly calculate
 the worst-case execution time of the SPM algorithm or to quickly determine
 whether priority compression is possible.
\end_layout

\begin_layout Subsection
The solution structure
\end_layout

\begin_layout Standard
Every solving algorithm needs to return a solution to the given parity game,
 which consists of a partitioning of the vertex set into winning sets for
 both players, and a strategy for each player which is defined at least
 for vertices in the winning set of that player.
\end_layout

\begin_layout Standard
This characterization shows that there is a strong relation between winning
 sets and strategies of players: when a player controls a vertex which lies
 outside his winning set, he has no meaningful strategy there (as every
 possible move is by definition losing).
 Therefore, we will simply define solutions as arrays which assign to every
 vertex the successor vertex for the controlling player, or the special
 value 
\begin_inset Formula $-1$
\end_inset

 if it is in his opponent's winning set instead:
\begin_inset Formula \[
\mathtt{solution[v]}=\begin{cases}
\sigma_{0}(v) & \mbox{ if }v\in V_{0}\cap W_{0}\\
\sigma_{1}(v) & \mbox{ if }v\in V_{1}\cap W_{1}\\
-1 & \mbox{ if }v\in(V_{0}\cap W_{1})\cup(V_{1}\cap W_{0})\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
From a solution array, winning sets and strategies can be trivially obtained
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
W_{x}=\{v\in V_{x}:\;\mathtt{solution[v]}\neq-1\}\]

\end_inset


\begin_inset Formula \[
\sigma_{x}(v)=\begin{cases}
\mathtt{solution[v]} & \mbox{ if }v\in W_{x}\\
\min(vE) & \mbox{ if \ensuremath{v\notin W_{x}}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Note that the choice of the minimum successor for vertices which are lost
 to the current player is arbitrary; in those cases any successor could
 be chosen.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- describe preprocessing algorithms
\end_layout

\begin_layout Plain Layout
- describe SCC processing
\end_layout

\begin_layout Plain Layout
- descripe mapping used to map subgames back to original games, preserving
 results
\end_layout

\begin_layout Plain Layout
- browse code for stuff I didn't cover yet
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Small Progress Measures
\end_layout

\begin_layout Standard
Small Progress Measures is a relatively simple, iterative algorithm for
 partially solving parity games.
 A game is solved partially in the sense that the winning set and optimal
 strategy for one player is determined.
 To solve a game completely, the algorithm must therefore be run twice,
 but fortunately for the second run the part of the game that has already
 been solved can be omitted, which typically greatly reduces the time required
 to solve the remaining part of the game.
\end_layout

\begin_layout Standard
Small Progress Measures (or SPM for short) is attractive because it is relativel
y simple which allows it to be implemented easily and provides ample opportunity
 to parallellize the core algorithm.
 Additionally, the algorithm is among those with the lowest complexity bounds
 known for solving parity games, with a worst-case time complexity of 
\begin_inset Formula $O\left(\left|E\right|\left(\left|V\right|/\left\lfloor \frac{d}{2}\right\rfloor \right)^{\left\lfloor \frac{d}{2}\right\rfloor }\right)$
\end_inset

 and requiring 
\begin_inset Formula $O(\left|V\right|d)$
\end_inset

 space (in addition to space required to store the parity game itself).
\end_layout

\begin_layout Section
Description
\end_layout

\begin_layout Standard
Here I will outline SPM as described by Jurdziński.
 Let's assume we want to solve the game for player even.
 Then, we associate with each vertex a value, which is either a 
\series bold

\begin_inset Formula $d$
\end_inset


\series default
-vector of nonnegative integers or the special value 
\begin_inset Formula $\top$
\end_inset

 (top) indexed from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $d-1$
\end_inset

.
 The 
\series bold

\begin_inset Formula $d$
\end_inset


\series default
-vector is a member of the vector space 
\begin_inset Formula $M=M_{0}\times M_{1}\times\cdots\times M_{d-1}$
\end_inset

 where 
\begin_inset Formula $M_{i}$
\end_inset

 is defined:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
M_{i}=\begin{cases}
\{0\} & \mbox{if \ensuremath{i\equiv0\mod{2}}}\\
\{0..\left|\{v\in V:\phi(v)=i\}\right|\} & \mbox{if \ensuremath{i\equiv1\mod{2}}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Elements from the set 
\begin_inset Formula $M^{\top}=M\cup\{\top\}$
\end_inset

 are called Small Progress Measures (the term 
\begin_inset Quotes eld
\end_inset

small
\begin_inset Quotes erd
\end_inset

 is used because they come from a reduced vector space where every even
 element is fixed to zero) and will be denoted with lower-case Greek letters.
 On these values a comparison operator 
\begin_inset Formula $<_{i}$
\end_inset

 is defined that compares two vectors lexicographically up to (and including)
 the element with index 
\begin_inset Formula $i$
\end_inset

.
 
\begin_inset Formula $\top$
\end_inset

 is always considered greater than any vector.
 Formally:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\begin{array}{cl}
\alpha<_{i}\beta\;\Leftrightarrow\alpha\neq\top\wedge\beta=\top & \mbox{if }\ensuremath{\alpha=\top\mbox{ or }\beta=\top}\\
\exists j\leq i:\;\alpha_{j}<\beta_{j}\wedge\left(\forall k<j:\;\alpha_{j}=\beta_{j}\right) & \mbox{otherwise}\end{array}\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
The operator 
\begin_inset Formula $<_{i}$
\end_inset

 establishes a strict weak ordering on the elements of 
\begin_inset Formula $M^{\top}$
\end_inset

.
 The other operators can then be defined accordingly:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha>_{i}\beta\;\Leftrightarrow\;\beta<_{i}\alpha\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha\leq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha>_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha\geq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha<_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha=_{i}\beta\;\Leftrightarrow\left(\alpha\leq_{i}\beta\right)\wedge\left(\alpha\geq_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha\neq_{i}\beta\;\Leftrightarrow\left(\alpha<_{i}\beta\right)\vee\left(\alpha>_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\rho:V\rightarrow M$
\end_inset

 be a function that maps progress measures to vertices.
 We will first define a function 
\begin_inset Formula $Prog(\rho,v,w):(V\rightarrow M)\times E\rightarrow M^{\top}$
\end_inset

 that determines the minimum progress measure for 
\begin_inset Formula $v$
\end_inset

 when 
\begin_inset Formula $vw$
\end_inset

 is included in the strategy for player Even.
 It is defined as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Prog(\rho,v,w)=\begin{cases}
\top & \mbox{if \ensuremath{\rho(w)=\top}, otherwise:}\\
\min_{m\in M^{T}}m\geq_{\phi(v)}\rho(w) & \mbox{if \ensuremath{\phi(v)\equiv0\mod{2}},}\\
\min_{m\in M^{T}}m>_{\phi(v)}\rho(w) & \mbox{if }\ensuremath{\phi(v)\equiv1\mod{2}}.\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Next we can define a function 
\begin_inset Formula $Lift(\rho,v)$
\end_inset

 which attempts to increase the progress vector assigned to 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $\rho$
\end_inset

, as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Lift(\rho,v)(u)=\begin{cases}
\rho(u) & \mbox{if \ensuremath{u\neq v}}\\
\max\{\rho(v),\min_{vw\in E}Prog(\rho,v,w)\} & \mbox{if \ensuremath{u=v\wedge v\in V_{0}}}\\
\max\{\rho(v),\max_{vw\in E}Prog(\rho,v,w)\} & \mbox{if }\ensuremath{u=v\wedge v\in V_{1}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
And similarly, globally:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Lift(\rho)=\begin{cases}
Lift(\rho,v) & \mbox{if \ensuremath{\exists v\in V:\; Lift(\rho,v)\neq\rho},}\\
\rho & \mbox{otherwise}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Now if we iterate 
\begin_inset Formula $Lift(\rho)$
\end_inset

 starting from a zero progress measure (
\begin_inset Formula $\rho(v)_{i}=0$
\end_inset

 for all 
\begin_inset Formula $v\in V$
\end_inset

 and 
\begin_inset Formula $i\in\{0..d-1\}$
\end_inset

) we will arrive at a minimum fixed point 
\begin_inset Formula $\rho=Lift(\rho)$
\end_inset

.
 This is our final progress measure function and Jurdziński proves that
 we can use its value as follows to deduce the winning sets and the strategy
 for player Even:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
W_{0}=\{v\in V:\;\rho(v)<\top\}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
W_{1}=\{v\in V:\;\rho(v)=\top\}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\sigma_{0}(v)=w\mbox{ if \ensuremath{v\in W_{0}}and}\rho(v)=_{\phi(v)}\rho(w)\]

\end_inset


\end_layout

\begin_layout Standard
(Note that if in the last definition the choice of 
\begin_inset Formula $w$
\end_inset

 is not unique, we can arbitrarily choose any of the possible successors
 to obtain an optimal strategy.)
\end_layout

\begin_layout Subsection
[Choice of lifted vertex]
\end_layout

\begin_layout Standard
In the above description it has not been specified how we will select a
 vertex to be lifted (in the first line of the definition of 
\begin_inset Formula $Lift(\rho)$
\end_inset

) when more than one choice of vertex is available.
 This is because, as part of the correctness proof for the algorithm, Jurdziński
 shows that the order in which vertices are lifted does not matter for the
 correctness or worst-case performance of the algorithm.
 Regardless of the strategy used, the algorithm will always arrive at the
 unique minimum fixed point, and the worst-case number of applications of
 the 
\begin_inset Formula $Lift$
\end_inset

 function required to arrive at this fixed point, does not depend on the
 choice of vertices to lift.
\end_layout

\begin_layout Standard
However, in practice this strategy for vertex selection appears to have
 a large impact on the running time of the implementation.
 There are two reasons for this:
\end_layout

\begin_layout Enumerate
As mentioned above, in many cases an appropriate vertex selection strategy
 can reduce the number of applications of 
\begin_inset Formula $Lift(p)$
\end_inset

 required to find the minimum fixed point, and since each application takes
 roughly the same time, this generally means faster execution.
\end_layout

\begin_layout Enumerate
In a practical implementation, to find a vertex that can be lifted, one
 has to consider vertices from a possible set of candidates, and calculate
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)(v)$
\end_inset

 in order to determine if 
\begin_inset Formula $Lift(\rho,v)\neq\rho$
\end_inset

.
 An inappropriate strategy may spend a relatively large amount of time looking
 at vertices which cannot be lifted.
\end_layout

\begin_layout Standard
Additionally, the freedom to lift (or try to lift) vertices in any order
 enables implementors to write parallel implementations in which the game
 graph is partitioned and distributed over multiple processors, and vertices
 at different locations can be lifted independently and in parallel.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
To implement the algorithm described above, we work back from top to bottom.
 The top level algorithm is simple: start with all-zero progress measures,
 while a vertex can be found that can be lifted, lift it.
 Jurdziński notes that finding a suitable vertex to lift takes at most 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 time.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- describe nondetermenistic parts (lifting strategy)
\end_layout

\begin_layout Plain Layout
- cite parallel implementation by Michael
\end_layout

\begin_layout Plain Layout
- cite parallel implementaiton on PS3 [mention/cite Jorne Kandziora, Freark
 van den Berg]
\end_layout

\begin_layout Plain Layout
- describe dual version as implemented by Olivier Friedman
\end_layout

\begin_layout Plain Layout
- describe preprocessing passses: removing cycles of odd players/odd priority
 and setting measure to top (partially implemented) + what else?
\end_layout

\begin_layout Plain Layout
(re: removing odd cycles: cite PGSolver&Michael for loops on vertices, credit
 Freark for coming up with a very limited version applied to longer cycles)
\end_layout

\begin_layout Plain Layout
- note that solving time for the two players is usually highly asymmetric,
 which is why the dual method works well, and why it makes sense to try
 to pick the easiest player to solve for first, as the second run will be
 on a smaller graph and then run much faster.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Zielonka's Recursive Algorithm
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- describe how it works
\end_layout

\begin_layout Plain Layout
- note that it's a constructive proof
\end_layout

\begin_layout Plain Layout
- note that it's derived from McNaughton
\end_layout

\begin_layout Plain Layout
- describe my implementation
\end_layout

\begin_layout Plain Layout
- but finish stuff above first!
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
TODO LIST
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- identify and label lemma's so I can refer to them more easily
\begin_inset Newline newline
\end_inset

- replace x by a different player variable? (Zielonka uses 
\begin_inset Formula $\sigma$
\end_inset

 for players, but Jurdziński uses it for strategies instead)
\begin_inset Newline newline
\end_inset

- label lemmas (if needed for proofs)
\begin_inset Newline newline
\end_inset

- have I described everything I came up with?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
