#LyX 1.6.8 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Title goes here
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
A 
\emph on
parity game
\emph default
 is a game played by two players, called Even and Odd, on a directed graph.
 Each vertex in the graph is associated with (
\emph on
owned
\emph default
 or 
\emph on
controlled
\emph default
 by) one of the two players.
 Furthermore, to each vertex a 
\emph on
priority
\emph default
 is assigned, which is a non-negative integer.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename illustrations/introduction-example.svg
	width 10cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
A small example of a parity game
\begin_inset CommandInset label
LatexCommand label
name "fig:introduction-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are different conventions for the names of players.
 They can be called Even and Odd, or denoted by symbols ◇ and ◻, which is
 particularly useful when visualizing games, as can be seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:introduction-example"

\end_inset

: the shape of the vertices corresponds with the players that control them.
 For the description of algorithms and data structures, especially when
 computations are involved, it is more convenient to use integers 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

.
 For example, if we consider a player 
\begin_inset Formula $x$
\end_inset

, his opponent can be described as 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
A parity game can be described by a four-tuple 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

, where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V_{\text{0}}$
\end_inset

 and 
\begin_inset Formula $V_{\text{1}}$
\end_inset

 partition the set of vertices 
\begin_inset Formula $V=V_{0}\cup V_{1}$
\end_inset

 of the graph into vertices belonging to 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
Even and Odd respectively.
 
\begin_inset Formula $E$
\end_inset

 is the set of directed edges in the game graph.
 Note that 
\begin_inset Formula $E$
\end_inset

 is a true set: every ordered pair of vertices has at most one edge between
 them.
 Duplicate edges are not allowed, but loops (edges which lead from a vertex
 back to itself) may occur.
 
\begin_inset Formula $\phi:V\rightarrow\mathbb{N}_{0}$
\end_inset

 is the priority function that assigns a priority to every vertex in the
 graph.
 The number of distinct priority values assigned to vertices in the game,
 is called the 
\emph on
order of the game
\emph default
, wich is equal to the cardinality of the range of 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
Parity games can be played on finite as well as infinite graphs.
 A parity game is called finite if it is played on a graph with a finite
 number of vertices.
 Consequently, the number of edges will be finite too (since the edge set
 is 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
a subset of
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V\times V$
\end_inset

)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
.
 Finally, because the number of distinct priorities is bounded by 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left|V\right|$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
, the order of a finite game is finite as well.
\end_layout

\begin_layout Subsection
Game Play and Winning Conditions
\end_layout

\begin_layout Standard
A parity game is played by placing a token on some initial vertex.
 The player to whom the vertex belongs moves the token to an adjacent vertex,
 which may belong to either player, who then makes the next move.
 When the token lands on a vertex without any outgoing edges, the game ends.
 However, it is more common for a game to continue indefinitely, causing
 an infinite sequence of moves.
 This sequence of moves on the graph is called a 
\emph on
play
\emph default
 and it can be described as the sequence of vertices visited by the token.
 Formally, 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is a play if 
\begin_inset Formula $\forall i\in\mathbb{N}\; v_{i}v_{i+1}\in E$
\end_inset

.
 A finite subsequence of a play that ends on a vertex with outgoing edges
 is called a 
\emph on
partial play
\emph default
.
\end_layout

\begin_layout Standard
For finite plays, the loser of the game is the player who is first unable
 to move.
 His opponent is the winner.
 In a finite play, the loser is therefore simply the controller of the final
 vertex in the play.
\end_layout

\begin_layout Standard
For infinite plays, a more complicated notion of winning is used.
 Let the 
\emph on
dominant priority
\emph default
 
\begin_inset Formula $P(\pi)$
\end_inset

 for a play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 be the smallest value that occurs infinitely often in the sequence 
\begin_inset Formula $\phi(v_{1})\phi(v_{2})\ldots$
\end_inset

 or formally:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
P(\pi)=\min\left\{ p\in\mathbb{N}_{0}:\left|\left\{ i\in\mathbb{N}:\phi(v_{i})=p\right\} \right|=\aleph_{0}\right\} \]

\end_inset


\end_layout

\begin_layout Standard
A play is won by player Even if the dominant priority for the play is even,
 and won by Odd otherwise (hence their names).
 When the set of priorities is finite, the dominant priority is well-defined,
 assigning a winner to every infinite play.
\end_layout

\begin_layout Standard
It should be noted that there is no consensus in literature on how priorities
 should be ordered.
 Throughout this report I will use the convention of lower priority values
 having precedence over higher values, thus 
\begin_inset Formula $0$
\end_inset

 being the 
\begin_inset Quotes eld
\end_inset

highest
\begin_inset Quotes erd
\end_inset

 priority, which is consistent with the definition given above.
\end_layout

\begin_layout Subsection
Strategies and Solutions
\end_layout

\begin_layout Standard
A strategy for player 
\begin_inset Formula $x$
\end_inset

 assigns a move to each position in which 
\begin_inset Formula $x$
\end_inset

 is to move.
 Formally, the strategy is a function 
\begin_inset Formula $\dot{\sigma}_{x}:V^{*}\times V_{x}\rightarrow V$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 such that if 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=v_{n+1}$
\end_inset

 then 
\begin_inset Formula $v_{1}\ldots v_{n+1}$
\end_inset

 is a partial play.
 A play 
\begin_inset Formula $\pi=v_{1}v_{2}\ldots$
\end_inset

 is called consistent with a strategy 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
for player 
\begin_inset Formula $x$
\end_inset

 if 
\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{i})=v_{i+1}$
\end_inset

 for all 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $v_{i}\in V_{x}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
.
\end_layout

\begin_layout Standard
A strategy 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called 
\emph on
winning
\emph default
 for player 
\begin_inset Formula $x$
\end_inset

 at starting vertex 
\begin_inset Formula $v_{1}$
\end_inset

 if all plays 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 consistent with 
\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 are won by player 
\begin_inset Formula $x$
\end_inset

.
 Parity games of a finite order have the important property that they are
 fully 
\emph on
determined
\emph default
, i.e.
 for every starting vertex either player Even or player Odd has a winning
 strategy 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: cite proof; Borel determinacy
\end_layout

\end_inset

.
 Thus, for these games, we can partition the vertex set 
\begin_inset Formula $V$
\end_inset

 of the game graph into two sets of vertices 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

 which can be won by player Even and Odd respectively.
 When the order is infinite, we can still identify disjoint sets 
\begin_inset Formula $W_{\text{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $W_{1}$
\end_inset

, but they may not be a true partition.
\end_layout

\begin_layout Standard
In many practical applications, determination of winning sets is enough
 to constitute a solution.
 For example, when using parity games as a vehicle for model checking, the
 question whether a formal property holds corresponds with the question
 wether a particular vertex in a game graph is won by player Even or Odd.
 In this case it would suffice to determine which player wins from this
 particular vertex without computing strategies and even without fully determini
ng winning sets.
\end_layout

\begin_layout Standard
An objection against determining winning sets without associated strategies
 is that even if we assume the output to be correct, the winning sets alone
 do not provide any insight in 
\emph on
why
\emph default
 a particular vertex is won by a particular player.
 Strategies can be useful to understand the outcome of the games.
 In the application of model checking, strategies can be used to generate
 counter-examples to a desired property when it turns out it doesn't hold.
 Moreover, if we have not just a winning set, but also associated strategies,
 we can readily verify their correctness (as will be described in detail
 later).
\end_layout

\begin_layout Standard
Therefore, 
\emph on
solving a game
\emph default
 in the most general sense means to identify optimal strategies for both
 players in addition to winning sets for both players.
 Note that even in finite games, strategies (unlike winning sets) do not
 complement each other, so given an optimal strategy for one player, we
 cannot (easily) deduce the strategy for his opponent.
\end_layout

\begin_layout Subsection
Optimal Strategies and Finite Memory
\end_layout

\begin_layout Standard
A strategy 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}$
\end_inset

 is called an 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
optimal strategy
\emph default
 when it is winning for player 
\begin_inset Formula $x$
\end_inset

 starting from any vertex 
\begin_inset Formula $v\in W_{x}$
\end_inset

.
\end_layout

\begin_layout Standard
Strategy as described above are called 
\emph on
infinite-memory strategies
\emph default
, because they can take the entire move history into account to determine
 the next move.
 In contrast, 
\emph on
memoryless strategies
\emph default
 are strategies which depend only on the current position of token, i.e.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\dot{\sigma}_{x}(v_{1}\ldots v_{n})=\dot{\sigma}_{x}(w_{1}\ldots w_{n})$
\end_inset

 whenever 
\begin_inset Formula $v_{n}=w_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
We will define memoryless strategies as functions 
\begin_inset Formula $\sigma_{x}:V_{x}\rightarrow V$
\end_inset

 such that if
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\sigma_{x}(v)=w$
\end_inset

 then 
\begin_inset Formula $vw\in E$
\end_inset

.
 A memoryless strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 is then consistent with a play 
\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset

 if 
\begin_inset Formula $\sigma_{x}(v_{i})=v_{i+1}$
\end_inset

 for all 
\begin_inset Formula $v_{i}\in V_{x}$
\end_inset

.
 We can restrict the domain of 
\begin_inset Formula $\sigma_{\text{x}}$
\end_inset

 to 
\begin_inset Formula $V_{\text{x}}\cap W_{x}$
\end_inset

 since for vertices in 
\begin_inset Formula $V_{x}$
\end_inset

but not in 
\begin_inset Formula $W_{\text{x}}$
\end_inset

, player 
\begin_inset Formula $x$
\end_inset

 has no winning move, and therefore any adjacent vertex can be selected
 without consequences for the rest of the strategy.
 Even if we leave out these vertices for which the controlling player has
 no winning move, optimal strategies are not (necessarily) uniquely defined,
 unlike winning sets.
\end_layout

\begin_layout Standard
Sometimes we want to refer to the combined strategies of both players, 
\begin_inset Formula $\sigma$
\end_inset

, defined as:
\begin_inset Formula \[
\sigma(v)=\begin{cases}
\sigma_{0}(v) & \mbox{if }v\in V_{0}\\
\sigma_{1}(v) & \mbox{if }v\in V_{1}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
It turns out that for all games of finite order optimal memoryless strategies
 exist.
 Zielonka
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset

 gives two proofs of this property.
 Research on finite-order games typically focuses on finding memoryless
 strategies for both players, which can be described succinctly by simply
 listing an optimal move for every vertex, which is especially practical
 for games on finite graphs.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
A consequence of both players following memoryless strategies on a finite
 graph (as pointed out by Jurdziński 
\begin_inset CommandInset citation
LatexCommand cite
key "jurdzinski2000spm"

\end_inset

) is that play will eventually become periodic.
 In other words, for every play 
\begin_inset Formula $v_{1}v_{2}\ldots$
\end_inset

 there is some starting point 
\begin_inset Formula $k$
\end_inset

 and a period 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $v_{i}=v_{i+n}$
\end_inset

 for all 
\begin_inset Formula $i\geq k$
\end_inset

.)
\end_layout

\end_inset

Since this report is about finding optimal strategies to finite parity games,
 the term 
\emph on
strategy
\emph default
 without further qualification will be used to mean 
\emph on
optimal memoryless strategy
\emph default
, and the 
\emph on
solution
\emph default
 to a parity game is a triple 
\begin_inset Formula $W_{0},W_{1},\sigma$
\end_inset

 describing the winning sets and optimal strategy for both players.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename illustrations/introduction-example-solved.svg

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The example game solved
\begin_inset CommandInset label
LatexCommand label
name "fig:introduction-example-solved"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:introduction-example-solved"

\end_inset

 the solution for the example game presented earlier is shown.
 Vertices are partioned into winning sets for both players.
 Edges that cannot be part of winning strategies are dashed.
 In this particular case, any of the solid edges can be chosen to yield
 an optimal strategy.
\end_layout

\begin_layout Section
Computational Complexity
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To write: something about known time complexity in NP and Co-NP (how?) and
 therefore likely to be in P (because otherwise NP=co-NP, which is unlikely).
 Note that the decision problem is 
\begin_inset Quotes eld
\end_inset

does player x win starting from vertex v?
\begin_inset Quotes erd
\end_inset

 and the resulting strategy acts as a certificate, because strategies can
 be verified in polynomial time.
 Best known complexity of algorithms.
 At least mention Zielonka, SPM and strategy improvement.
 Maybe add section about reduction to other (NP-complete of course) problems.
 Mention that solving games in practice usually takes considerably less
 time than the worst-case complexity suggests.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Application To Model Checking
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To write.
 Should include mapping from modal mu calculus + LTS to parity games.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
Zielonka describes strategies for a more general class of games played on
 infinite (or finite) graphs, using colouring of vertices with colours from
 a finite set instead of simple integers, and with more complex winning
 conditions.
 The class of games he describes cannot generally be solved by memoryless
 strategies, but many of the concepts he mentions are applicable to parity
 games.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe where Parity Games lie in the Borel hierarchy.
\end_layout

\begin_layout Plain Layout
Describe previous solvers?
\end_layout

\begin_layout Plain Layout
Describe other algorithms not described in this paper (strategy improvement,
 others implemented in PGSolver).
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
[Detailed description]
\end_layout

\begin_layout Standard
[The goal of this part is to describe common restrictions and terminology
 which will be used in later descriptions and analysis of algorithms.
 Nothing new is introduced here.]
\end_layout

\begin_layout Section
Restrictions on the graph
\end_layout

\begin_layout Standard
For convenience, I will assume some restrictions on the structure of the
 graph, which simplify the design and analysis of the data structures and
 algorithms involved considerably, but which do not diminish the practical
 utility of parity games algorithms.
 Of these, the first two properties are simplifications that do not limit
 the classes of games that can be analyzed in general.
 Only the third restriction is a true restriction in a theoretical sense.
\end_layout

\begin_layout Enumerate
Every vertex has at least one outgoing edge.
\end_layout

\begin_layout Enumerate
The graph is connected.
\end_layout

\begin_layout Enumerate
The graph is finite.
\end_layout

\begin_layout Standard
The first property makes finite plays impossible, which simplifies the analysis
 of many algorithms.
 We will call a game a 
\emph on
proper game
\emph default
 if its graph satisfies this property.
 However, improper games (whose game graphs contain vertices with no outgoing
 edges) can be turned into proper games by considering each vertex without
 outgoing edges.
 If it is controlled by player 
\begin_inset Formula $x$
\end_inset

, we can change its priority to 
\begin_inset Formula $1-x$
\end_inset

 and add an edge from the vertex back to itself.
 In the modified graph every vertex has an outgoing edge, yet it has the
 same solution and winning strategies as the original graph.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Does this need proof?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second property does not restrict the classes of games that can be solved
 either.
 During a play, the token never leaves the (weakly) connected component
 of the graph that it starts in, so for any unconnected graph, we can decompose
 the graph into weakly connected components, analyze these components individual
ly, and combine the results.
\end_layout

\begin_layout Standard
The final property is a true restriction because it makes it impossible
 to analyze infinite graphs.
 This has practical as well as theoretical benefits.
 From a practical point of view, since all of the game data is now finite,
 it allows us to represent graphs explicitly using only finite memory (otherwise
, we would need a symbolic representation).
 From a theoretical point of view, a finite vertex set allows for algorithms
 and proofs that do not generalize to infinite graphs.
 In particular, the winner of any play can be decided, because the order
 of the graph is finite.
\end_layout

\begin_layout Section
Restrictions on the set of priorities
\end_layout

\begin_layout Standard
When discussing actual implementations of data structures and algorithms,
 it is convenient to assume that the priorities in the game are not just
 integers, but bounded by a value that is as small as possible.
 Fortunately, we can reduce the values of priorities used to a range between
 0 and 
\begin_inset Formula $d$
\end_inset

 (exclusive), where 
\begin_inset Formula $d$
\end_inset

 is the order of the game.
 This is done by remapping priorities for vertices in a process called 
\emph on
priority compression.

\emph default
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite: PGSolver manual? or an earlier paper?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider we have a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 and we wish to apply priority compression.
 To do so, we find the first unused priority (say, 
\begin_inset Formula $p$
\end_inset

) in the game.
 If 
\begin_inset Formula $p=d$
\end_inset

 then all priorities from 
\begin_inset Formula $0$
\end_inset

 through 
\begin_inset Formula $d-1$
\end_inset

 (inclusive) are used and since the order of the game is 
\begin_inset Formula $d$
\end_inset

 this means we are done.
 Otherwise, let 
\series bold

\begin_inset Formula $q$
\end_inset


\series default
 be the least priority greater than 
\begin_inset Formula $p$
\end_inset

 that is used.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $p=0$
\end_inset

 then we can decrement all priorities by 
\begin_inset Formula $q$
\end_inset

 and, if 
\begin_inset Formula $q$
\end_inset

 is odd, we additionally switch the roles of players Even and Odd.
 Formally, we construct a game 
\begin_inset Formula $\Gamma'=(V_{\text{0}}',V_{\text{1}}',E',\phi')$
\end_inset

 where 
\begin_inset Formula $V_{x}'=V_{y}$
\end_inset

 and 
\begin_inset Formula $x=y-p\mod{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
, 
\begin_inset Formula $\phi'(v)=\phi(v)-q$
\end_inset

 and 
\begin_inset Formula $E'=E$
\end_inset

.
\end_layout

\begin_layout Standard
If, however, 
\begin_inset Formula $p>0$
\end_inset

 then we keep 
\begin_inset Formula $V_{0}'=V_{0}$
\end_inset

 and 
\begin_inset Formula $V_{1}'=V_{1}$
\end_inset

.
 However, if 
\begin_inset Formula $p\equiv q\mod{2}$
\end_inset

 then we get rid of the unused priorities and lump the vertices with priority
 
\begin_inset Formula $q$
\end_inset

 in with those with priority 
\begin_inset Formula $p$
\end_inset

.
 After all, 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 have the same parity, and since none of the values in between are used,
 they can be interchanged without affecting the outcome of the game.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Does this need proof?
\end_layout

\end_inset

 More formally, in this case we define 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi'(v)$
\end_inset

 as:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 
\begin_inset Formula \[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q & \mbox{\mbox{if }\ensuremath{\phi(v)>p}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $p-q\equiv0\mod{2}$
\end_inset

 we have preserved parity: 
\begin_inset Formula $\phi'(v)\equiv\phi(v)\mod{2}$
\end_inset

.
 Finaly, if 
\begin_inset Formula $p>0$
\end_inset

 and 
\begin_inset Formula $p\not\equiv q\mod{2}$
\end_inset

 then we can remove the unused priorities, but we do not want to equate
 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 which have different priorities:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\phi'(v)=\begin{cases}
\phi(v) & \mbox{if }\phi(v)\leq p\\
\phi(v)+p-q+1 & \mbox{\mbox{if} \ensuremath{\phi(v)<p}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Again, since 
\begin_inset Formula $p-q+1\equiv0\mod{2}$
\end_inset

 this preserved the parity of 
\begin_inset Formula $\phi$
\end_inset

 while removing the unused priorities between 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 We need to repeat the process described here for every gap in the set of
 used priorities (which is at most 
\begin_inset Formula $d$
\end_inset

 times) and the result will always be a set of 
\begin_inset Formula $d$
\end_inset

 used priorities from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $d-1$
\end_inset

 (inclusive).
\end_layout

\begin_layout Standard
Most solving algorithms do not require that priorities are compressed into
 a minimal range, but the maximum occurring priority usually is a component
 in the total amount of time or memory required.
 Therefore, it is useful to preprocess every game to minimize the priority
 set in this way, especially since this can be easily done in time linear
 in the number of vertices, which makes it a relatively inexpensive operation.
\end_layout

\begin_layout Section
Common Terminology
\end_layout

\begin_layout Standard
There are a number of concepts which can be applied to parity games which
 have been described in literature before.
 In particular, Zielonka introduces some useful terminology in a treatise
 on two-player games played on coloured graphs (of which parity games are
 a subset) which will be repeated here.
 He describes attractor sets and traps.
 Additionally, I will describe subgames analogous to (though slightly different
 from) subarenas.
\end_layout

\begin_layout Subsection
Subgames
\end_layout

\begin_layout Standard
A 
\emph on
subgame
\emph default
 of a game 
\begin_inset Formula $\Gamma=(V_{\text{0}},V_{\text{1}},E,\phi)$
\end_inset

 induced by a vertex set 
\begin_inset Formula $U\subseteq V$
\end_inset

 is the game 
\begin_inset Formula $\Gamma|U=(V_{\text{0}}\cap U,V_{\text{1}}\cap U,E\cap\left(U\times U\right),\phi|U)$
\end_inset

 where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\phi|U$
\end_inset

 denotes 
\begin_inset Formula $\phi$
\end_inset

 with its domain limited to 
\begin_inset Formula $U$
\end_inset

.
 In other words, the game obtained when only considering vertices from 
\begin_inset Formula $U$
\end_inset

 and ignoring the rest.
 
\begin_inset Formula $\Gamma|U$
\end_inset

 is called a 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
\color inherit
proper subgame
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 if every vertex in 
\begin_inset Formula $U$
\end_inset

 has at least one successor also in 
\begin_inset Formula $U$
\end_inset

 (in other words, if 
\begin_inset Formula $\Gamma|U$
\end_inset

 is a proper game as described above).
\end_layout

\begin_layout Subsection
Traps
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $vE$
\end_inset

 be the set of vertices which are successors of 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $E$
\end_inset

, or formally 
\begin_inset Formula $vE=\left\{ w|vw\in E\right\} .$
\end_inset

 Analogously, 
\begin_inset Formula $Ew=\{v|vw\in E\}$
\end_inset

.
 A non-empty vertex set 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $U\subseteq V$
\end_inset

 is a trap for player 
\begin_inset Formula $x$
\end_inset

 (or an 
\begin_inset Formula $x$
\end_inset

-trap, for short) when, informally, player 
\begin_inset Formula $x$
\end_inset

 cannot force the token out of 
\begin_inset Formula $U$
\end_inset

.
 Formally, 
\begin_inset Formula $U$
\end_inset

 is an 
\begin_inset Formula $x$
\end_inset

-trap if for all 
\begin_inset Formula $v\in U$
\end_inset

:
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \[
v\in V_{x}\rightarrow vE\setminus U=\emptyset\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \[
v\in V_{1-x}\rightarrow vE\cap U\neq\emptyset\]

\end_inset


\end_layout

\begin_layout Subsection
Attractor sets
\end_layout

\begin_layout Standard
An attractor set for a player 
\begin_inset Formula $x$
\end_inset

 on a vertex set 
\bar under

\begin_inset Formula $U\subseteq V$
\end_inset


\bar default
, denoted 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

, is the set of vertices from which the player 
\begin_inset Formula $x$
\end_inset

 can force the token into one of the vertices in 
\begin_inset Formula $U$
\end_inset

 (including, by definition, vertices in 
\begin_inset Formula $U$
\end_inset

 itself).
 It is a fixed point attractor under expansion using the recursive definition:
\end_layout

\begin_layout Standard
Zielonka gives an iterative definition of an attractor set:
\begin_inset Formula \[
U_{0}=U\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
U_{i+1}=U_{i}\cup\{v\in V_{x}:\; vE\cap U_{i}\neq\emptyset\}\cup\{v\in V_{1-x}:\; vE\setminus U_{i}=\emptyset\}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
Attr^{x}(\Gamma,U)=U_{0}\cup U_{1}\cup\cdots\]

\end_inset


\end_layout

\begin_layout Standard
This is also useful to compute the attractor set iteratively.
 Since it is a fixed point attractor, 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
converges to 
\begin_inset Formula $U_{i}$
\end_inset

 with 
\begin_inset Formula $U_{i}=U_{i+1}$
\end_inset

.
 From a practical point of view, we expand the attractor set until we can
 add no more vertices to it, and then we are done.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Using an appropriate data structure (for example, a hash table) attractor
 sets can be computed in time linear in the number of edges incident to
 vertices in the resulting attractor set.
 With typical sparse graphs, this is linear in the size of the attractor
 set as well.
\end_layout

\begin_layout Subsubsection
Attractor strategies
\end_layout

\begin_layout Standard
An important property of attractor sets, is that if 
\begin_inset Formula $U\subseteq W_{x}$
\end_inset

, then 
\begin_inset Formula $Attr^{x}(\Gamma,U)\subseteq W_{x}$
\end_inset

 too.
 Of course, if we know the optimal strategy for all vertices 
\begin_inset Formula $v\in U$
\end_inset

, then we also want to extend this strategy to 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

.
 Fortunately, this can easily be done: every vertex that appears first in
 
\begin_inset Formula $U_{i+1}$
\end_inset

 (i.e.
 it is a member of 
\begin_inset Formula $U_{i+1}\setminus U_{i}$
\end_inset

) has a successor in 
\begin_inset Formula $U_{i}$
\end_inset

, and when we repeatedly choose such a successor, then we arrive at 
\begin_inset Formula $U_{0}$
\end_inset

 in 
\begin_inset Formula $i$
\end_inset

 steps, at which point the rest of the strategy is known.
 Zielonka proves these properties in more detail.
\end_layout

\begin_layout Subsubsection
Duality between attractor sets and traps
\end_layout

\begin_layout Standard
The second important property of attractor sets, is that the complement
 of an attractor set for player 
\begin_inset Formula $x$
\end_inset

 (formally: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V'=V\setminus Attr^{x}(\Gamma,U)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
) is a trap for 
\begin_inset Formula $x$
\end_inset

.
 Moreover, if 
\begin_inset Formula $\Gamma$
\end_inset

 is a proper game, 
\begin_inset Formula $\Gamma|V'$
\end_inset

 is a proper subgame
\emph on
 
\emph default
of 
\begin_inset Formula $\Gamma$
\end_inset

, since if a vertex 
\begin_inset Formula $v\in V'$
\end_inset

 has no successor 
\begin_inset Formula $w\in V'$
\end_inset

 then all its successors must be in 
\begin_inset Formula $Attr^{x}(\Gamma,U)$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 would have, by definition, been in the attractor set, instead of its complement.
\end_layout

\begin_layout Standard
This property is important because it means that if we start with a proper
 game (which is assumed in the following) then we can safely remove attractor
 sets of arbitrary vertex sets and obtain a proper subgame, which is not
 the case if we would remove arbitrary vertex sets.
 This technique can be used to break down a game in parts which are solved
 in order.
\end_layout

\begin_layout Section
Degenerate cases
\end_layout

\begin_layout Standard
In addition to games which do not comply with the restrictions mentioned
 earlier, there are also a few classes of degenerate games that are special
 cases of the general game describe above.
 They are mentioned separately because specific algorithms exist to solve
 them quicker than is possible for the general case.
\end_layout

\begin_layout Standard
These special cases are occasionally provided as input to a solver (for
 example, as the representation of a particularly simple model checking
 problem) but more commonly they arise as subgames to be solved after applying
 a number of reductions or partial solution techniques.
\end_layout

\begin_layout Subsection
Single-parity games
\begin_inset CommandInset label
LatexCommand label
name "sub:Single-priority-games"

\end_inset


\end_layout

\begin_layout Standard
If the priorities of vertices all have the same parity (even or odd) then
 the corresponding player will trivially win from every starting vertex,
 with an arbitrary strategy.
 A special case is the single-priority game, where only a single priority
 is used.
 Note that priority compression will reduce both single-parity and single-priori
ty games to a game in which 0 is the only priority in use, making this type
 of game easy to recognize.
\end_layout

\begin_layout Subsection
Single-player games
\end_layout

\begin_layout Standard
A parity game is a 
\emph on
single-player game for player 
\begin_inset Formula $x$
\end_inset

 
\emph default
when all vertices controlled by player 
\begin_inset Formula $1-x$
\end_inset

 have outdegree equal to 1.
 In such a game, only player 
\begin_inset Formula $x$
\end_inset

 can make choices, and player 
\series bold

\begin_inset Formula $1-x$
\end_inset


\series default
 is forced to always move the token to the single available successor whenever
 it lands on one of his vertices.
\end_layout

\begin_layout Standard
In such a game, player 
\begin_inset Formula $x$
\end_inset

 wins from precisely from the vertices which lie on a cycle of which the
 minimum priority has parity equal to 
\begin_inset Formula $x$
\end_inset

, as well as from all vertices from which such a cycle can be reached.
 After all, his opponent has no choice, so he can never force the token
 out of a cycle or prevent player 
\begin_inset Formula $x$
\end_inset

 from reaching a cycle when there exists a path to it.
 The remaining vertices (if there are any) are won by player 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
In extremely rare cases the game is played on a cycle graph and neither
 player has a choice.
 In that case, strategies are trivial and whichever player has the dominant
 priority on the cycle wins from any vertex in the game.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
What other special cases have been identified?
\end_layout

\begin_layout Plain Layout
Browse PGSolver docs/Jeroen's thesis for stuff worth repeating here.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Verification
\end_layout

\begin_layout Standard
In order to be able to ascertain the correctness of the implemented algorithms,
 it is useful to have a means of verifying the solutions produced by these
 algorithms.
 Of course, algorithms are typically published with a correctness proof
 before they are implemented, but mistakes could be introduced during implementa
tion, which makes it worthwhile to implement a verification routine to validate
 the emperical results.
 The verification algorithm depends on the correct solution of single-player
 games, for which a polynomial time algorithm will be presented.
 The verification algorithm runs 
\end_layout

\begin_layout Subsection
Solving single-player games
\end_layout

\begin_layout Standard
Without loss of generality, suppose we want to solve a single-player game
 for player Even.
 Player Even can win from at least some vertices if the graph contains a
 cycle with even dominant priority (for brevity, let's call this an 
\emph on
even cycle
\emph default
).
\end_layout

\begin_layout Standard
To solve the game, we iteratively identify an even cycle 
\begin_inset Formula $c_{1}c_{2}\ldots c_{n}\in V^{+}$
\end_inset

 in the game (
\begin_inset Formula $c_{i}c_{j}\in E$
\end_inset

 if 
\begin_inset Formula $i+1=j\mod{n}$
\end_inset

 and 
\begin_inset Formula $\min\phi(c_{j})=0\mod{2}$
\end_inset

) 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
and then solving the smaller subgame 
\begin_inset Formula $\Gamma|V\setminus Attr^{x}(\Gamma,\{v_{1}\ldots v_{n}\})$
\end_inset

 in the same manner.
 The strategy for player Even is formed by combining 
\begin_inset Formula $\sigma_{0}(c_{i})=c_{j}$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
if 
\begin_inset Formula $i+1=j\mod{n}$
\end_inset

 with the strategy obtained by computing the attractor set and solving the
 subgame.
 When eventually no even cycle remains, then all possible plays in the remaining
 subgame necessarily have odd dominant priority and player Odd wins from
 the remaining vertices with a trivial strategy, since by definition of
 a single-player game Odd has no choice in the game.
\end_layout

\begin_layout Standard
The question now becomes how to find these even cycles.
 If we call a cycle with dominant priority 
\emph on
i
\emph default
 an 
\emph on
i
\emph default
-cycle, then a game contains an 
\emph on
i
\emph default
-cycle if and only if it contains any vertices with priority 
\emph on
i
\emph default
 lying on a cycle after removal of all edges incident with vertices of priority
 less than 
\begin_inset Formula $i$
\end_inset

, because an 
\emph on
i
\emph default
-cycle can only include edges between vertices of priority 
\emph on
i
\emph default
 or higher.
 To find an 
\emph on
i
\emph default
-cycle in a graph with edges between vertices of priorities 
\emph on
i
\emph default
 or higher, we can use the connection between strongly connected components
 of the graph and a cycle in the graph: every cycle must lie in a single
 strongly connected component and if the edge set of a strongly-connected
 component is non-empty, then all vertices in the strongly-connected component
 must lie on a cycle (by the definition of strongly connected components).
\end_layout

\begin_layout Standard
To find an even cycle, we simply try to find an 
\begin_inset Formula $i$
\end_inset

-cycle all even values of 
\begin_inset Formula $i$
\end_inset

.
 When a component containing an 
\begin_inset Formula $i$
\end_inset

-cycle is found, backtracking can be used to find the cycle itself.
 Since strongly connected components can be found in linear time using Tarjan's
 algorithm
\begin_inset CommandInset citation
LatexCommand cite
key "tarjan1971depth"

\end_inset

, we need 
\begin_inset Formula $O(d\left|E\right|)$
\end_inset

 time worst-case to find a cycle when trying all values of 
\begin_inset Formula $i$
\end_inset

, but since it makes sense to try non-decreasing values of 
\begin_inset Formula $i$
\end_inset

 over the course of the global algorithm, which requires at most 
\begin_inset Formula $\left|V\right|\geq d$
\end_inset

 iterations, the total algorithm requires 
\begin_inset Formula $O(\left|V\right|\left|E\right|)$
\end_inset

, assuming subgames can be constructed in 
\begin_inset Formula $O(\left|E\right|)$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 as well.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: compare with PGSolver, if that's different.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Verification of strategies
\end_layout

\begin_layout Standard
Altough it is hard to compute the optimal strategies for the players in
 a parity game, it is much easier to verify that a pair of a winning sets
 and associated strategies are sound.
 To verify winning sets, it would suffice to solve a parity game with a
 known-good algorithm and then compare if the result is equal.
 This isn't possible for strategies, which are generally not unique, so
 even if we obtain an optimal strategy, this does not imply that different
 strategies are invalid.
 Therefore, we need a separate algorithm to verify strategies.
\end_layout

\begin_layout Standard
As we noted before, we are only interested in the strategy for vertices
 that are in the winning set of the player that controls them.
 Assume we are verifying the set 
\begin_inset Formula $W_{x}$
\end_inset

 with optimal strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

 for player 
\begin_inset Formula $x$
\end_inset

.
 Define a graph with vertices limited to 
\begin_inset Formula $W_{x}$
\end_inset

 and the set of edges 
\begin_inset Formula $E|\sigma_{x}$
\end_inset

 as follows:
\begin_inset Formula \[
E|\sigma_{x}=\left\{ vw\in E:v\in\left(W_{x}\cap V_{x}\right)\wedge\sigma_{\text{x}}(v)=w\right\} \cup\left\{ vw\in E:v\in\left(W_{x}\cap V_{1-x}\right)\right\} \]

\end_inset


\end_layout

\begin_layout Standard
Less formally, the edge set includes the edges that are consistent with
 
\begin_inset Formula $x$
\end_inset

's strategy, as well as all edges originating at vertices controlled by
 his opponent.
 We must first verify two trivial properties:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $E|\sigma_{x}\subseteq E$
\end_inset

 (otherwise the strategy 
\begin_inset Formula $\sigma_{\text{x}}$
\end_inset

 prescribes a transition that is not available in the original game graph)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $E|\sigma_{x}\subseteq W_{\text{x}}\times W_{x}$
\end_inset

 (otherwise either the player or his opponent can move the token outside
 the winning set)
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Assuming these hold, then 
\begin_inset Formula $\Gamma|\sigma_{\text{x}}=(W_{x}\cap V_{x},W_{x}\cap V_{1-x},E|\sigma_{x},\phi|W_{x})$
\end_inset

 is a proper subgame of 
\begin_inset Formula $\Gamma$
\end_inset

, and precisely those plays in the original game consistent with strategy
 
\begin_inset Formula $\sigma_{x}$
\end_inset

 are possible in the game 
\begin_inset Formula $\Gamma|\sigma_{\text{x}}$
\end_inset

 as well, except that all choice for player 
\begin_inset Formula $x$
\end_inset

 has been removed.
 Since every vertex controlled by 
\begin_inset Formula $x$
\end_inset

 has only one successor, this makes 
\begin_inset Formula $\Gamma|\sigma_{x}$
\end_inset

 a single-player game controlled by player 
\begin_inset Formula $1-x$
\end_inset

.
\end_layout

\begin_layout Standard
To verify that the original strategy was sound, we can solve this single
 player using the method described earlier, and verify that the winning
 set for player 
\begin_inset Formula $W_{1-x}$
\end_inset

 in the subgame is empty.
 This proves the validity of both the winning set 
\begin_inset Formula $W_{x}$
\end_inset

 and strategy 
\begin_inset Formula $\sigma_{x}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
maybe expand a bit on the proof?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verifying the first two properties described above takes time linear in
 the number of vertices.
 Since we only need to run part of the single-player solving algorithm (because
 we can stop as soon as we find one cycle won by player 
\begin_inset Formula $1-x$
\end_inset

, which is a suitable counter-example to the soundness of 
\begin_inset Formula $\sigma_{x}$
\end_inset

), 
\begin_inset Formula $O(d\left|E\right|)$
\end_inset

 time is required for the last step.
\end_layout

\begin_layout Chapter
Common algorithms and data structures
\end_layout

\begin_layout Standard
The results that will be presented later on are based on emperical evaluation
 of various parity game solving algorithms on both synthetic and real-world
 cases.
 The results obtained therefore depend not only on the choice of algorithms,
 but also on various implementation details, such as the data structures
 and programming techniques used to implement those algorithms.
\end_layout

\begin_layout Standard
It has been shown that in practice different experimental tools have different
 performance characteristics despite being based on the same theoretical
 algorithms.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite some proof?
\end_layout

\end_inset

 This phenomon occurs because of undocumented differences in the implementation
 of these different tools, sometimes arising from intentional changes to
 those algorithms (preprocessing operations or optimizations for particular
 instances, for example) and more often because the algorithms described
 in literature are usually not described to a sufficient level of detail
 that they can be implemented without being forced to make concrete implementati
on choices.
 For theoretical analysis this is not necessary (and usually, in the interest
 of conciseness, not desired), but for practical results it matters significantl
y how the missing parts are implemented concretely.
\end_layout

\begin_layout Standard
In order to ensure that the results presented here are reproducible, and
 to make the differences in results obtained with different tools easier
 to understand and explain, I will document the choices that I made in the
 implementation of my solving tool to a fair amount of detail.
 In particular, the core data structures and the algorithms will be documented
 precisely.
\end_layout

\begin_layout Standard
Finally, the descriptions provided here and in later chapters are a useful
 key to understanding the source code of my solver tool, since it provides
 a high-level overview of its design.
\end_layout

\begin_layout Section
Parity Games
\end_layout

\begin_layout Standard
Recall that a parity game consists of a directed graph, a partition of vertices
 into sets owned by the two players, and the assignment of a priority to
 every vertex.
 This data must be represented in some way in a solver.
\end_layout

\begin_layout Standard
When executing a solving algorithm, the parity game data is read, but usually
 not modified.
 Therefore, an implementation that allows efficient read-only access is
 more important than a data structure with high flexibility in regards to
 updates.
 However, many of the simplification and preprocessing algorithms must either
 modify the parity game under consideration or be able to quickly construct
 a modified copy of it.
 This use case must be accommodated as well.
\end_layout

\begin_layout Standard
Finally, since practical instances of parity games tend to be fairly large,
 it is desirable that the parity game representation is as compact as possible,
 to the extend this is possible without compromising access speed.
 This not only reduces the amount of memory needed to solve particularly
 large instances, but also ensures that the solving algorithms benefit maximally
 from cache effects.
\end_layout

\begin_layout Subsection
The game graph structure
\end_layout

\begin_layout Standard
A parity game is played on a directed graph, which consists of a set of
 vertices (
\begin_inset Formula $V$
\end_inset

) and a set of edges (
\begin_inset Formula $E\subseteq V\times V$
\end_inset

).
 Vertices will be identified with integers from 0 through 
\begin_inset Formula $\left|V\right|$
\end_inset

 (exclusive).
 At a minimum, we will store 
\begin_inset Formula $\left|V\right|$
\end_inset

 and 
\begin_inset Formula $\left|E\right|$
\end_inset

, the number of vertices and edges in the graph respectively.
\end_layout

\begin_layout Standard
To represent the graph in its entirety, we then only need to store the edges.
 We could store those as an array of pairs of integers (the source and destinati
on vertices of a directed edge).
 This is reasonably compact (requiring 
\begin_inset Formula $2\left|E\right|$
\end_inset

 integers to be stored).
 However, this representation is impractical if we want to quickly access
 a set of successors (
\begin_inset Formula $vE$
\end_inset

) or predecessors (
\begin_inset Formula $Ev$
\end_inset

) of a vertex, which are common operations in many algorithms.
\end_layout

\begin_layout Standard
Therefore, a different representation is used.
 Suppose we start with the array of edges described above and sort them
 by source vertex first, and destination vertex second.
 Then, all the edges from a vertex 
\begin_inset Formula $v$
\end_inset

 to its successors will occur as a consecutive sequence in the edge array,
 and we can store for each vertex the interval 
\begin_inset Formula $[\mathtt{succBegin[v],\mathtt{succEnd[v]})}$
\end_inset

.
\end_layout

\begin_layout Standard
This representation would require 
\begin_inset Formula $2\left|E\right|+2\left|V\right|$
\end_inset

 integers to be stored, and allows the following operations to be performed
 efficiently:
\end_layout

\begin_layout Enumerate
Enumerate the successors of a vertex (
\begin_inset Formula $vE$
\end_inset

), in order.
\end_layout

\begin_layout Enumerate
Calculate the number of successors of a vertex (
\begin_inset Formula $\left|vE\right|$
\end_inset

), by calculating 
\begin_inset Formula $\mathtt{succEnd[v]}-\mathtt{succBegin[v]}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Determine if 
\begin_inset Formula $vw\in E$
\end_inset

 (using binary search, this could take 
\begin_inset Formula $O\left(log\left(\left|vE\right|+1\right)\right)$
\end_inset

 time).
\end_layout

\begin_layout Standard
Of course, the first operation is the one that is most common.
 Next, we can apply two simplifications.
 First, since the predecessor vertex of all edges with indices between 
\begin_inset Formula $\mathtt{succBegin[v]}$
\end_inset

 and 
\begin_inset Formula $\mathtt{succEnd[v]}$
\end_inset

 are known to be equal to 
\begin_inset Formula $v$
\end_inset

, we don't need to store predecessor vertices at all.
 Additionally, it is easy to see that 
\begin_inset Formula $\mathtt{succEnd[v]=succBegin[v+1]}$
\end_inset

 for all 
\begin_inset Formula $v$
\end_inset

 except the last vertex, so we can store all indices in a single array of
 length 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left|V\right|+1$
\end_inset

, instead of using two arrays.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
This it the final representation that is used, and requires 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula $\left|E\right|+\left|V\right|+1$
\end_inset

 integers to store the edge data.
 However, this edge representation only allows us to quickly find successors
 of edges.
 For some algorithms, it is useful to be able to find predecessors quickly
 as well.
 For this reason, the graph data structure by default stores the edge set
 in reverse order too, doubling the amount of memory required.
\end_layout

\begin_layout Standard
It should be noted that this dense edge representation does not allow efficient
 insertion or removal of individual edges in the game graph, because each
 such operation requires a large part of the edge array to be moved.
 Fortunately, the preprocessing algorithms that are applied in the solver
 are applied to the graph as a whole, and the cost of individual changes
 can therefore be amortized over the entire graph-wide operation.
\end_layout

\begin_layout Subsection
The parity game structure
\end_layout

\begin_layout Standard
In addition to the game graph, a parity game must store two attributes for
 each vertex:
\end_layout

\begin_layout Enumerate
The controlling player (Even or Odd), and
\end_layout

\begin_layout Enumerate
the associated priority value, 
\begin_inset Formula $\phi(v)$
\end_inset

.
\end_layout

\begin_layout Standard
These two attributes are packed into a two-byte structure, and stored in
 an array of length 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 Note that this limits the maximum priority that can be represented to 255,
 which seems low, but is much larger than occurs in practice (although synthetic
 cases with larger priorities could easily be generated).
\end_layout

\begin_layout Standard
Additionaly, we store in the parity game structure two properties of the
 game:
\end_layout

\begin_layout Enumerate
The priority limit (
\begin_inset Formula $d$
\end_inset

) which is calculated as the maximum priority value used + 1.
 (This is equal to the order of the game assuming all priority values are
 used.)
\end_layout

\begin_layout Enumerate
An array of integers of length 
\begin_inset Formula $d$
\end_inset

 that stores how many vertices occur with each individual priority value.
\end_layout

\begin_layout Standard
This information can be recomputed from the vertex attributes in time 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

, but it is useful in a number of situations, for example, to quickly calculate
 the worst-case execution time of the SPM algorithm or to quickly determine
 whether priority compression is possible.
\end_layout

\begin_layout Subsection
The solution structure
\end_layout

\begin_layout Standard
Every solving algorithm needs to return a solution to the given parity game,
 which consists of a partitioning of the vertex set into winning sets for
 both players, and a strategy for each player which is defined at least
 for vertices in the winning set of that player.
\end_layout

\begin_layout Standard
This characterization shows that there is a strong relation between winning
 sets and strategies of players: when a player controls a vertex which lies
 outside his winning set, he has no meaningful strategy there (as every
 possible move is by definition losing).
 Therefore, we will simply define solutions as arrays which assign to every
 vertex the successor vertex for the controlling player, or the special
 value 
\begin_inset Formula $-1$
\end_inset

 if it is in his opponent's winning set instead:
\begin_inset Formula \[
\mathtt{solution[v]}=\begin{cases}
\sigma_{0}(v) & \mbox{ if }v\in V_{0}\cap W_{0}\\
\sigma_{1}(v) & \mbox{ if }v\in V_{1}\cap W_{1}\\
-1 & \mbox{ if }v\in(V_{0}\cap W_{1})\cup(V_{1}\cap W_{0})\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
From a solution array, winning sets and strategies can be trivially obtained
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
W_{x}=\{v\in V_{x}:\;\mathtt{solution[v]}\neq-1\}\]

\end_inset


\begin_inset Formula \[
\sigma_{x}(v)=\begin{cases}
\mathtt{solution[v]} & \mbox{ if }v\in W_{x}\\
\min(vE) & \mbox{ if \ensuremath{v\notin W_{x}}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Note that the choice of the minimum successor for vertices which are lost
 to the current player is arbitrary; in those cases any successor could
 be chosen.
\end_layout

\begin_layout Subsection
Solving subgames
\end_layout

\begin_layout Standard
Many algorithms require subgames to be constructed.
 Since the data structure described above requires a dense representation
 of vertices, this requires that all data is reconstructed.
 The subgame 
\begin_inset Formula $\Gamma|U$
\end_inset

 is constructed from an array containing the vertex identifiers in 
\begin_inset Formula $U$
\end_inset

 while the ordering of the elements determines the new identifiers of the
 vertices.
\end_layout

\begin_layout Standard
If the order of vertices in the subgame is maintained (in other words, if
 the input array contains nondecreasing identifiers) then constructing the
 subgame takes time linear in the number of edges of the new game.
 Since the algorithms that create subgames typically do not care about any
 particular vertex ordering, this is the common case.
 In the general case, reordering of successors or predecessors may be required,
 though this can be done on a per-vertex basis, which means the sorting
 overhead is small for typical games where edge in the graph have small
 outdegree.
\end_layout

\begin_layout Standard
The efficiency of subgame construction is important because it is a large
 part of the Zielonka's recursive algorithm and of decomposition in strongly
 connected components.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
I should probably quantify this
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, using the original vertex identifier array, strategies and winning
 sets computed for a subgame can be trivially converted to its original.
 This is useful to propagate solution information back to the main game
 in order to e.g.
 compute attractor sets.
\end_layout

\begin_layout Subsection
Attractor set computation
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe how attractor sets may be implemented such that core algorithms
 that time linear in the size of the attractor set.
 (Although the current implementation uses a simple set, so it requires
 O(E log V) where E and V are limited to the subgraph induced by the attractor
 set.)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Graph decomposition
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe solving strongly connected components invidiually (not really a
 degenerate case but OK)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- browse code for stuff I didn't cover yet
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Small Progress Measures
\end_layout

\begin_layout Standard
Small Progress Measures is a relatively simple, iterative algorithm for
 partially solving parity games proposed my Marcin Jurdziński.
 A game is solved only partially in the sense that the winning set and optimal
 strategy for one player is determined.
 To solve a game completely, the algorithm must therefore be run twice,
 but, fortunately, in the second pass the winning set of the first player
 can be omitted from the game graph, which typically reduces the time required
 to solve the remaining part of the game significantly.
\end_layout

\begin_layout Standard
Small Progress Measures (or SPM for short) is attractive because it is relativel
y simple which allows it to be implemented easily and provides ample opportunity
 to parallellize the core algorithm.
 Additionally, the algorithm is among those with the lowest complexity bounds
 known for solving parity games, with a worst-case time complexity of 
\begin_inset Formula $O\left(\left|E\right|\left(\left|V\right|/\left\lfloor \frac{d}{2}\right\rfloor \right)^{\left\lfloor \frac{d}{2}\right\rfloor }\right)$
\end_inset

 and requiring 
\begin_inset Formula $O(\left|V\right|d)$
\end_inset

 space (in addition to space required to store the parity game itself).
\end_layout

\begin_layout Standard
Oliver Friedmann proposed a variation of the algorithm that effectively
 combines the two passes in one, solving both the game and its dual at the
 same time.
 This does not improve on the worst-case time bounds (and, in fact, may
 require around twice as much time and memory compared to the standard algorithm
), but in practice avoids many of the pitfalls that cause excessive runtimes
 with the standard algorithm, which makes it a useful alternative in practice.
\end_layout

\begin_layout Standard
Small progress measures was previously implemented by Martin Lange and Olivier
 Friedmann in PGSolver (both the regular and two-way algorithm).
 A lock-free concurrent version was implemented by Weber and Van de Pol
 which works on shared-memory systems that do not reorder memory store operation
s.
 A concurrent implementation for the Playstation 3 (taking advantage of
 the capabilities of the multi-core Cell processor) was written by Jorne
 Kandziora and later improved upon by Freark van der Berg.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add references for all of these.
 Note the contribution of my implementation: better heuristics.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Description
\end_layout

\begin_layout Standard
Here I will outline SPM as described by Jurdziński.
 Let's assume we want to solve the game for player even.
 Then, we associate with each vertex a value, which is either a 
\series bold

\begin_inset Formula $d$
\end_inset


\series default
-vector of nonnegative integers or the special value 
\begin_inset Formula $\top$
\end_inset

 (top) indexed from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $d-1$
\end_inset

.
 The 
\series bold

\begin_inset Formula $d$
\end_inset


\series default
-vector is a member of the vector space 
\begin_inset Formula $M=M_{0}\times M_{1}\times\cdots\times M_{d-1}$
\end_inset

 where 
\begin_inset Formula $M_{i}$
\end_inset

 is defined:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
M_{i}=\begin{cases}
\{0\} & \mbox{if \ensuremath{i\equiv0\mod{2}}}\\
\{0..\left|\{v\in V:\phi(v)=i\}\right|\} & \mbox{if \ensuremath{i\equiv1\mod{2}}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Elements from the set 
\begin_inset Formula $M^{\top}=M\cup\{\top\}$
\end_inset

 are called Small Progress Measures (the term 
\begin_inset Quotes eld
\end_inset

small
\begin_inset Quotes erd
\end_inset

 is used because they come from a reduced vector space where every even
 element is fixed to zero) and will be denoted with lower-case Greek letters.
 On these values a comparison operator 
\begin_inset Formula $<_{i}$
\end_inset

 is defined that compares two vectors lexicographically up to (and including)
 the element with index 
\begin_inset Formula $i$
\end_inset

.
 
\begin_inset Formula $\top$
\end_inset

 is always considered greater than any vector.
 Formally:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\begin{array}{cl}
\alpha<_{i}\beta\;\Leftrightarrow\alpha\neq\top\wedge\beta=\top & \mbox{if }\ensuremath{\alpha=\top\mbox{ or }\beta=\top}\\
\exists j\leq i:\;\alpha_{j}<\beta_{j}\wedge\left(\forall k<j:\;\alpha_{j}=\beta_{j}\right) & \mbox{otherwise}\end{array}\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
The operator 
\begin_inset Formula $<_{i}$
\end_inset

 establishes a strict weak ordering on the elements of 
\begin_inset Formula $M^{\top}$
\end_inset

.
 The other operators can then be defined accordingly:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha>_{i}\beta\;\Leftrightarrow\;\beta<_{i}\alpha\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha\leq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha>_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha\geq_{i}\beta\;\Leftrightarrow\;\neg\left(\alpha<_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha=_{i}\beta\;\Leftrightarrow\left(\alpha\leq_{i}\beta\right)\wedge\left(\alpha\geq_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\alpha\neq_{i}\beta\;\Leftrightarrow\left(\alpha<_{i}\beta\right)\vee\left(\alpha>_{i}\beta\right)\]

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\rho:V\rightarrow M$
\end_inset

 be a function that maps progress measures to vertices.
 We will first define a function 
\begin_inset Formula $Prog(\rho,v,w):(V\rightarrow M)\times E\rightarrow M^{\top}$
\end_inset

 that determines the minimum progress measure for 
\begin_inset Formula $v$
\end_inset

 when 
\begin_inset Formula $vw$
\end_inset

 is included in the strategy for player Even.
 It is defined as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Prog(\rho,v,w)=\begin{cases}
\top & \mbox{if \ensuremath{\rho(w)=\top}, otherwise:}\\
\min_{m\in M^{T}}m\geq_{\phi(v)}\rho(w) & \mbox{if \ensuremath{\phi(v)\equiv0\mod{2}},}\\
\min_{m\in M^{T}}m>_{\phi(v)}\rho(w) & \mbox{if }\ensuremath{\phi(v)\equiv1\mod{2}}.\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Next we can define a function 
\begin_inset Formula $Lift(\rho,v)$
\end_inset

 which attempts to increase the progress vector assigned to 
\begin_inset Formula $v$
\end_inset

 in 
\begin_inset Formula $\rho$
\end_inset

, as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Lift(\rho,v)(u)=\begin{cases}
\rho(u) & \mbox{if \ensuremath{u\neq v}}\\
\max\{\rho(v),\min_{vw\in E}Prog(\rho,v,w)\} & \mbox{if \ensuremath{u=v\wedge v\in V_{0}}}\\
\max\{\rho(v),\max_{vw\in E}Prog(\rho,v,w)\} & \mbox{if }\ensuremath{u=v\wedge v\in V_{1}}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
And similarly, globally:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Lift(\rho)=\begin{cases}
Lift(\rho,v) & \mbox{if \ensuremath{\exists v\in V:\; Lift(\rho,v)\neq\rho},}\\
\rho & \mbox{otherwise}\end{cases}\]

\end_inset


\end_layout

\begin_layout Standard
Now if we iterate 
\begin_inset Formula $Lift(\rho)$
\end_inset

 starting from a zero progress measure (
\begin_inset Formula $\rho(v)_{i}=0$
\end_inset

 for all 
\begin_inset Formula $v\in V$
\end_inset

 and 
\begin_inset Formula $i\in\{0..d-1\}$
\end_inset

) we will arrive at a minimum fixed point 
\begin_inset Formula $\rho=Lift(\rho)$
\end_inset

.
 This is our final progress measure function and Jurdziński proves that
 we can use its value as follows to deduce the winning sets and the strategy
 for player Even:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
W_{0}=\{v\in V:\;\rho(v)<\top\}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
W_{1}=\{v\in V:\;\rho(v)=\top\}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\sigma_{0}(v)=w\mbox{ if \ensuremath{v\in W_{0}}and}\rho(v)=_{\phi(v)}\rho(w)\]

\end_inset


\end_layout

\begin_layout Standard
(Note that if in the last definition the choice of 
\begin_inset Formula $w$
\end_inset

 is not unique, we can arbitrarily choose any of the possible successors
 to obtain an optimal strategy.)
\end_layout

\begin_layout Standard
The top-level algorithm can now be describe very succinctly (and, unfortunately,
 vaguely) as follows.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Pseudo-code
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Lifting Strategies
\end_layout

\begin_layout Standard
In the above description it has not been specified how we will select a
 vertex to be lifted (in the first line of the definition of 
\begin_inset Formula $Lift(\rho)$
\end_inset

) when more than one choice of vertex is available.
 This is because, as part of the correctness proof for the algorithm, Jurdziński
 shows that the order in which vertices are lifted does not matter.
 Regardless of the strategy used, the algorithm will always arrive at the
 unique minimum fixed point, and the worst-case number of applications of
 the 
\begin_inset Formula $Lift$
\end_inset

 function required to arrive at this fixed point, does not depend on the
 choice of vertices to lift.
\end_layout

\begin_layout Standard
However, in practice this strategy for vertex selection appears to have
 a large impact on the running time of the implementation.
 There are two reasons for this:
\end_layout

\begin_layout Enumerate
As mentioned above, in many cases an appropriate vertex selection strategy
 can reduce the number of applications of 
\begin_inset Formula $Lift(p)$
\end_inset

 required to find the minimum fixed point, and since each application takes
 roughly the same time, this generally means faster execution.
\end_layout

\begin_layout Enumerate
In a practical implementation, to find a vertex that can be lifted, one
 has to consider vertices from a possible set of candidates, and calculate
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)(v)$
\end_inset

 in order to determine if 
\begin_inset Formula $Lift(\rho,v)\neq\rho$
\end_inset

.
 If the lifting attempt fails, we have achieved nothing, an inappropriate
 strategy may spend a relatively large amount of time on failed lifting
 attempts.
\end_layout

\begin_layout Standard
We will call the computation of 
\begin_inset Formula $Lift(\rho,v)(v)$
\end_inset

 a 
\emph on
lifting attempt
\emph default
, which can either succeed (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)(v)\ne\rho$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
) or fail 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $Lift(\rho,v)(v)=\rho$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
.
 Depending on the implementation, a succesful lifting attempt may be more
 costly than an unsuccesful attempt, but both have non-zero cost, so the
 goal for an efficient implementation will be to minimize both of these
 operations.
\end_layout

\begin_layout Standard
If lifting a vertex 
\begin_inset Formula $v$
\end_inset

 fails, we will call it (temporarily) stable for the current progress measure.
 A vertex becomes stable indefinitely when it has reached its value in the
 minimum fixed point.
 We try to avoid lifting stable vertices (as this does not progress the
 algorithm) but in many cases we cannot determine whether a vertex is stable
 unless we try to lift it, similar to how we have to try and fail to lift
 some vertices to determine that a minimum fixed point has been reached.
\end_layout

\begin_layout Standard
We will assume in the following that the cost of a succesful lifting attempt
 is constant regardless of the vertex being lifted.
 In practice, the cost depends at least on the priority of the vertex and
 how many successors it has 
\begin_inset Note Note
status open

\begin_layout Plain Layout
refer to actual implementation where this is clear
\end_layout

\end_inset

, but since both the maximum priority and the average out-degree is typically
 low, we might ignore this for sake of simplicity.
 Similarly, we will assume that the cost of failed lifting attempts is constant
 as well, and is no greater than that of a succesful lifting attempt, as
 the same successors must be examined, except that no updates are performed.
\end_layout

\begin_layout Standard
Ideally, the SPM algorithm performs succesful lifting attempts only and
 then stops, minimizing the total cost required to arrive at a solution.
 Unfortunately, there is no obvious way to select vertices to achieve this.
 Moreover, after the minimum fixed point has been found, we may have to
 perform additional (failing) lifting attempts just to verify that we have
 indeed found a fixed point.
 Unfortunately, there is no obvious way to select vertices in an optimal
 fashion.
 Therefore, lifting strategies are necessarily heuristical in nature, making
 a best-effort attempt at selecting a sequence of vertices that minimizes
 the cost.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(But can we determine an optimal sequence with hindsight?)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
lifting strategy
\emph default
 is a heuristical algorithm that, depending on the structure of the graph,
 the values of the progress measure vectors and/or the history of vertices
 being lifted, determines which vertex is selected for the next lifting
 attempt.
 Most sensible strategies are 
\emph on
online algorithms
\emph default
 in the sense that they take the success of the previous lifting operation
 into account to determine which vertex to lift next.
 As a result, the strategies are stateful, and although sophisticated lifting
 strategies may cause fewer work to be done in the SPM algorithm itself,
 this comes at the cost of requiring more time and memory spent on keeping
 state for the lifting strategy itself.
 We will present results which quantify this overhead for various possible
 strategies later.
\end_layout

\begin_layout Subsection
Termination conditions
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To write: which vertices do we need to lift to verify that we have found
 a fixed point
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Pseudo-code for core algorithm, which calls lifting strategy to determine
 both next vertex and when to stop.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Core Algorithm Implementation
\end_layout

\begin_layout Standard
To implement the Jurdziński's algorithm, we start with an all-zero progress
 measures, and while a vertex can be found that can be lifted, we lift it.
 Jurdziński notes that finding a suitable vertex to lift takes at most 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 time (by considering each vertex in succession).
 In practice we can do better, at least on average, with a suitable lifting
 strategy.
\end_layout

\begin_layout Standard
The small progress measure vectors themselves are stored simply in a contiguous
 array of length 
\begin_inset Formula $\left|V\right|\times\left\lfloor \frac{d}{2}\right\rfloor $
\end_inset

 (where 
\begin_inset Formula $d$
\end_inset

 is one larger than the maximum priority occuring in the game graph), since
 each vector consists of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\left\lfloor \frac{d}{2}\right\rfloor $
\end_inset

 components.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- Insert pseudo-code
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- Mention vertex mapping? (This should be described somewhere else, as it's
 part of the global framework, not just SPM)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Graph Preprocessing
\end_layout

\begin_layout Standard
One peculiarity of the Small Progress Measures algorithm is that it may
 spend a lot of time lifting vertices with high priority values which lie
 on a cycle.
 The most typical example of this is a vertex which is controlled by player
 Odd, has a high, odd priority and its only edge is a loop (an edge from
 the vertex back to itself).
 The final progress measure for such a vertex will obviously be 
\begin_inset Formula $\top$
\end_inset

 (since Odd will keep the token at this vertex indefinitely), but its high
 priority ensures that it is only lifted in very small increments.
\end_layout

\begin_layout Standard
Something similar occurs for vertices of odd priority which are controlled
 by Even.
 Although these cannot be initialized to 
\begin_inset Formula $\top$
\end_inset

 (they may still be won by Even) we can and should discard the loop edge,
 to speed up propagation of values from successor vertices through this
 vertex.
\end_layout

\begin_layout Subsubsection
Loop removal
\end_layout

\begin_layout Standard
All known implementations of Small Progress Measures do some form of preprocessi
ng, where such cases are detected and the progress measures of vertices
 won by Odd are set to 
\begin_inset Formula $\top$
\end_inset

 before running the main algorithm.
 Four cases can be distinguished based on the controller and parity of a
 vertex, as summarized in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SPM-preprocessing"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Player
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Priority
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Winner
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loop edge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Other edges
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
undecided
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
even
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
undecided
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Odd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\top$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kept
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
removed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Preprocessing of vertices with loops
\begin_inset CommandInset label
LatexCommand label
name "tab:SPM-preprocessing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Note that when a vertex has only one outgoing edge, then it can be considered
 to belong to either player; in this case it's most beneficial to assign
 it to the player corresponding to the parity of its priority.) There are
 different ways to use this information.
 The simplest is to remove some of the vertices and initialize the progress
 measure vector to 
\begin_inset Formula $\top$
\end_inset

 in the fourth case, and solve the rest of the game as usual.
 This is the approach used by the existing solvers.
\end_layout

\begin_layout Standard
It should be noted that in two of the four cases, it is known to which winning
 set the vertex belongs, and the associated strategy is to use the loop
 back to the vertex.
 A simple extension is then to collect sets of these vertices for each player,
 and extend these to their attractor sets, to obtain a larger subset of
 vertices that are completely solved and can be removed from the game entirely.
 The resulting game graph then has no more loops.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: example pictures for the four cases above?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Winner-controlled cycle removal
\end_layout

\begin_layout Standard
In his solver, Freark van der Berg introduced a slightly more sophisticated
 version of the loop removal process described above.
 He searches for cycles of vertices controlled by Odd with odd priority.
 Since he uses a simple depth-limited depth-first-search, he is limited
 to finding small cycles only.
 Despite this, his benchmark results show that this already provides significant
 benefits over the removal of loops only, at least in some random games.
\end_layout

\begin_layout Standard
His approach can be generalized in several ways.
 First, we would like to find cycles of any size, not just small ones.
 Second, we do not need to limit ourselves to cycles of equal parity: if
 the dominant priority for the cycle matches the controlling player, the
 priorities for the other vertices do not matter.
 To find such cycles, a simple depth-first search no longer suffices.
 Third, as with loop removal, we would like to remove cycles for both players,
 not just for Odd.
 The general process is called 
\emph on
winner controlled cycle removal
\emph default
; i.e.
 removal of all cycles consisting of vertices for which the winner is equal
 to the controlling player.
\end_layout

\begin_layout Standard
To remove all 
\begin_inset Formula $i$
\end_inset

-cycles controlled by player 
\begin_inset Formula $p$
\end_inset

 (where 
\begin_inset Formula $p\equiv i\mod{2})$
\end_inset

 in the graph, an approach similar to that used to verify strategies can
 be applied.
 Construct a subgraph of all vertices controlled by 
\begin_inset Formula $p$
\end_inset

 (including vertices controlled by 
\begin_inset Formula $1-p$
\end_inset

 with outdegree 1) with priority greater than or equal to 
\begin_inset Formula $i$
\end_inset

.
 Decompose the graph into strongly connected components.
 Vertices with priority 
\begin_inset Formula $i$
\end_inset

 that occur in a connected component with at least one edge (i.e.
 either the component contains two vertices or the vertex has an edge to
 itself) are part of a cycle with dominant priority 
\begin_inset Formula $i$
\end_inset

.
 If we collect one such vertex per component (if one exists) and then compute
 the attractor set for these vertices, we have identified all vertices which
 either lie on an 
\begin_inset Formula $p$
\end_inset

-controlled 
\begin_inset Formula $i$
\end_inset

-cycle or which can be reached from there.
\end_layout

\begin_layout Standard
Strategies for these vertices can be constructed as follows: from a vertex
 with priority 
\begin_inset Formula $p$
\end_inset

 any successor inside the component may be chosen, and the rest of the strategy
 can be constructed during computation of the attractor set, as discussed
 earlier.
 Any vertices solved in this way can be removed from the game.
 This process is repeated for every priority in the game.
 Every iteration requires constructing a subgraph with the appropriate vertices,
 decomposing it into strongly connected component, computing the attractor
 set in the original game, and then computing a subgame with the remaining
 vertices.
 Using appropriate data structures, each of these operations take at most
 time linear in the number of the edges in the graph, for a total runtime
 complexity of 
\begin_inset Formula $O(dE)$
\end_inset

.
 Although this is considerably more than simple preprocessing on vertices
 with loops only, the potential benefits are larger too.
\end_layout

\begin_layout Subsection
Distributed implementation
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Partition graph, process independently, propagate changes at overlapping
 vertices.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Linear Lifting Strategy
\end_layout

\begin_layout Standard
Arguably the most basic lifting strategy is a strategy that simply picks
 vertices in order of increasing indices, repeating the process as necessary,
 until all vertices in the graph have failed to be lifted in succession.
 Its advantages are that it is simple to implement, requires almost no additiona
l memory, and takes very little time.
 However, the main disadvantage is that it ends up spending a lot of time
 attempting (and failing) to lift vertices in stable parts of the game graph.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: pseudo-code
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Weber and Van de Pol call this strategy s
\emph on
wiping
\emph default
 instead and it is one of the main strategies implemented in their multi-core
 solver.
\end_layout

\begin_layout Standard
One variation of the strategy is to iterate vertices from back to front.
 This can be beneficial in cases where the graph has been constructed in
 a forward fashion, so that a vertex tends to have a higher index than its
 predecessors.
 Since changes in the graph propagate from vertices to their predecessors,
 iterating in reverse may cause many more vertices to be lifted, the pathologica
l example being a graph which is a simple cycle, with edges 
\begin_inset Formula $E=\{(v,w):\; w\equiv v+1\mod{\left|V\right|}$
\end_inset

.
 Iterating in forward direction might cause only a single succesful lift
 on every pass, while the reverse allows all vertices to be lifted.
\end_layout

\begin_layout Standard
If we expect the edges of the graph to be predominantly oriented one way
 or the other, but we do not know which way in advance, another variation
 would be to alternate the direction of iteration on every pass, avoiding
 the bad case mentioned above.
 Even then we can construct cases which cause a lot of failed lifts, but
 these may arise less frequently in practice.
\end_layout

\begin_layout Standard
In addition to these variations, it is possible to try to reorder vertices
 in the graph at the start, so that the dominant edge direction is optimal
 for the linear lifting strategy.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
mention this as a preprocessing step for SPM
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Predecessor Lifting Strategy
\end_layout

\begin_layout Standard
A more sophisticated lifting strategy takes into account the fact that a
 known-stable vertex can only become unstable after the progress measure
 vector of one of its successors has been updated.
 After all, the value for one vertex depends only on the values for its
 successors.
 The predecessor lifting strategy uses a set datastructure to store potentially
 unstable vertices, which is initialized to all vertices in the graph.
 A vertex is arbitrarily removed from this set to be lifted, and if this
 succeeds, its predecessors are inserted back into the set (if they were
 not yet present).
 All vertices not in the set are necessarily stable, so when the set becomes
 empty, lifting is complete.
\end_layout

\begin_layout Standard
The advantage of this strategy is that it prevents a lot of unnecessary
 lifting that may occur with the linear lifting strategy.
 In fact, the ratio of unsuccesful to succesful lifts is strictly limited
 by the maximum indegree of a vertex in the graph.
 Again, pathological cases can be constructed where this strategy performs
 badly.
 For example, when the game graph is complete (i.e.
 
\begin_inset Formula $E=V\times V$
\end_inset

) all vertices remain in the set until the game is completely solved.
 Fortunately, in practice parity game graphs tend to be sparse, making this
 an unlikely scenario.
\end_layout

\begin_layout Standard
The main disadvantage of the lifting strategy is that it requires maintaining
 the set of unstable vertices, which requires 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

 extra memory.
 In my solver, I choose to implement this set with a linear array of boolean
 variables to indicate whether a vertex is in the set, and another array
 which acts as a circular queue of vertices.
 This implementation has the advantage of allowing constant time insertion
 and deletion of vertices in the queue, though the time required to update
 the queue is still linear in the number of predecessors of the last vertex
 lifted.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: pseudo-code
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Weber and Van de Pol call this the 
\emph on
work list approach
\emph default
, but reject it in their multi-core solver making two objections:
\end_layout

\begin_layout Enumerate
It requires predecessors of vertices to be stored in addition to successors,
 which requires additional memory.
\end_layout

\begin_layout Enumerate
The overhead involved maintaining the set may be too large.
\end_layout

\begin_layout Standard
However, in my experience graphs do not take a prohibitively large amount
 of memory, and the non-blocking primitives required to implement the set
 in a lock-free manner are readily available, and may well have been easier
 to implement than the focus list approach described below.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
So this probably means I should try to implement it instead.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In PGSolver, which is limited to single-threaded operation only, the predecessor
 lifting strategy is the only lifting strategy implemented.
\end_layout

\begin_layout Standard
There is some freedom of implementation when deciding which vertex from
 the set of potentially unstable vertices to lift next.
 The maximum measure lifting strategy (described later) uses the current
 progress measures vectors to select a vertex.
 My implementation uses no external information, but can be configured to
 extract vertices from the queue in a first in, first out (FIFO) or last
 in, last out (LIFO) manner, in which case the queue works like a stack.
 Additionally, the vertices can initially be inserted in forward or in reverse
 order, for similar reasons as the linear lifting strategy can change directions.
 This gives a total of four different variations, which perform differently
 depending on the test case.
 Extracting vertices in LIFO order may have the benefit of providing better
 cache locality, even when it doesn't reduce the number of lifts.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
but I have no practical results that show this clearly
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Focus List Approach
\end_layout

\begin_layout Standard
The 
\emph on
focus list approach
\emph default
 is a strategy designed by Weber and van de Pol in order to avoid the disadvanta
ges of the linear lifting strategy (mainly that it performs a lot of unnecessary
 failed lifting attempts) without introducing complicated data structures.
 Solving occurs by alternation of two phases of operation.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
mention randomization of work list (vertices are put on work list with p=0.5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First, the algorithm iterates linearly over the vertices of the graph, putting
 vertices which are succesfully lifted on a fixed-size work list.
 When the work list is full, the second phase begins: vertices on the work
 list are assigned an initial credit value and are selected for lifting
 again.
 When lifting a vertex succeeds, its credit is incremented linearly (adding
 a constant); if it fails, it is decreased exponentially (dividing by a
 constant).
 A vertex whose credit drops below a certain threshold is removed from the
 work list.
 When the work list is empty or a predetermined amount of lifting attempts
 have been performed, the work list is cleared and the first phase is resumed.
\end_layout

\begin_layout Standard
The idea behind the work list is that it captures unstable parts of the
 graph.
 When processing the work list, either lifting attempts will have a high
 success rate, or the list will be cleared quickly, allowing new vertices
 to be selected.
 Limiting the number of attempts at this time ensures that if little progress
 is made in one part of the game (i.e.
 despite high lifting success rate, vertices do not stabilize) work will
 soon continue on some other part of the game.
\end_layout

\begin_layout Standard
Since Weber and van de Pol are the only ones to implement this strategy,
 there is little emperical evidence available about its performance, though
 it seems to perform much better than linear lifting in some cases, and
 not much worse in most other cases, which suggests it meets its design
 goals.
 Compared to the predecessor lifting strategy, it has the advantage of being
 able to postpone difficult parts of the game, which may help in some hard
 cases.
\end_layout

\begin_layout Standard
The main downside of the strategy is that it depends on various constants
 (work list size, initial credit, credit increment, credit divisor) to work
 well.
 In Weber's implementation these are emperically derived while testing on
 random games, but it is unclear if and how these values should change for
 other types of games.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Mention constants used?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Maximum-Measure Propagation
\end_layout

\begin_layout Standard
The maximum-measure propagation strategy is a variant of the predecessor
 lifting strategy that at each iteration attempts to lift a vertex with
 a successor that has a maximal progress measure vector assigned to it.
 The rationale behind this strategy is the observation that since we increase
 the progress measure vector for at most one vertex every iteration, and
 since the final progress measure for this vertex does not depend on the
 order of lifting, then in order to perform as few (succesful) lifts as
 possible, it makes sense to try to lift vertices with the largest increments
 possible.
\end_layout

\begin_layout Standard
Pathological examples can be constructed in which this order of lifting
 provides obvious benefit.
 Specifically, whenever a vertex is known to be won by player Odd (when
 it is assigned top value) all vertices in its attractor set will be set
 to top too, before any other vertices are lifted, since top is the maximal
 value in the graph.
 With the normal predecessor lifting strategy, these vertices might have
 been lifted multiple times before inevitably finally reaching top value.
\end_layout

\begin_layout Standard
In practice, maximum-measure propagation is not always strictly better than
 the general simple predecessor lifting strategy described above, as will
 be shown later.
 However, in many cases it does cause fewer (succesful as well as total)
 lifting attempts.
 Its main disadvantage lies in the considerable amount of overhead in the
 implementation of the strategy itself.
 In order to keep track of vertices with high progress measures, it is necessary
 to implement some sort of priority queue structure.
 Additionally, it must be possible to move queued vertices in the queue
 when the value for their successor changes.
\end_layout

\begin_layout Standard
In my implementation, the successors (not the vertices themselves) are kept
 in a complete binary heap structure ordered by their progress measure vectors,
 stored in an array of size equal to 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 In order to be able to move vertices up in the heap whenever they are lifted,
 another array of size 
\begin_inset Formula $\left|V\right|$
\end_inset

 keeps track of the position of vertices in the heap.
 (Since progress measure vectors are only ever increased, never decreased,
 moving down is not necessary).
 Finally, for each predecessor in the heap I store whether or not it is
 queued in a boolean array of size 
\begin_inset Formula $\left|V\right|$
\end_inset

.
 Whenever a vertex is succesfully lifted, I mark all of its predecessors
 that have not yet been assigned top value as queued.
 If there are any, then the vertex itself is inserted into the heap or moved
 up from its current position if it is already present.
 If there are none, then the successor vertex is removed.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
CHECKME: why did I implement it like this, instead of storing the queued
 vertices in the heap directly? I believe there was a good reason, but I
 can't recall what it was.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, to select the next vertex to be lifted, the highest vertex in the heap
 is consulted, and if any of its predecessors are still marked as queued,
 it is returned.
 If there are no predecessors to be lifted, the vertex is removed from the
 heap, and we repeat the process.
 When the heap is empty, no more vertices are queued and the solution is
 complete.
 Note that for each vertex, on average, we insert one vertex in the heap,
 remove one vertex on the heap, and look up a number of vertices equal to
 half of the in-degree of vertices in the graph.
 Insertion and removal in a binary heap takes at most 
\begin_inset Formula $O(\log\left|V\right|)$
\end_inset

 time.
 Since we assume the game graph to be sparse, this is also the average overhead
 per 
\emph on
succesful
\emph default
 lift for this strategy.
 Although this overhead is still small, it is considerably more than the
 
\begin_inset Formula $O(1)$
\end_inset

 overhead of data structures described previously.
 Like the predecessor lifting strategy, the memory overhead is limited to
 
\begin_inset Formula $O(\left|V\right|)$
\end_inset

, though with a larger constant factor.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- Pseudo-code
\end_layout

\begin_layout Plain Layout
- Worst cases, if different from predecessor lifting?
\end_layout

\begin_layout Plain Layout
- Note that biggest-steps algorithm is possible too! (How?)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Two-way SPM 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Needs a better name?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A noteworthy variant of the Small Progress Measures algorithm was implemented
 by Olivier Friedmann in PGSolver.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add citation or mention that this variant is unpublished.
\end_layout

\end_inset

 In this case, the algorithm is not run for one player at a time, but for
 both players at once.
 In Friedmann's implementation this means that a single vertex is selected,
 and it is lifted both in the normal game and its dual, and if either lift
 succeeds, the predecessor vertices are queued.
 Effectively, the queue is shared between the two games.
 Conceivably, the two games could be processed independently, even in parallel
 on separate machines.
\end_layout

\begin_layout Standard
Periodically (in the current implementation after every 
\begin_inset Formula $\left|V\right|$
\end_inset

 lifting attempts) information about winning vertices is exchanged between
 the games, by conservatively identifying vertices in one game that are
 won by the player for which we are computing the strategy, and setting
 the progress measures of these vertices to 
\begin_inset Formula $\top$
\end_inset

 in the corresponding dual game being solved for its opponent.
 These vertices are identified as follows.
\end_layout

\begin_layout Standard
Without loss of generality, assume we are computing the strategy for player
 Even.
 First, all vertices in the graph are marked to indicate that they might
 be winning for Even.
 Then, if any of the following is true for a vertex, its mark is removed:
\end_layout

\begin_layout Enumerate
Its progress measure is 
\begin_inset Formula $\top$
\end_inset


\end_layout

\begin_layout Enumerate
The vertex is controlled by Even and either:
\end_layout

\begin_deeper
\begin_layout Enumerate
has no marked successors; or
\end_layout

\begin_layout Enumerate
its progress measure is less than the minimum of its marked successors
\end_layout

\end_deeper
\begin_layout Enumerate
The vertex is controlled by Odd and either:
\end_layout

\begin_deeper
\begin_layout Enumerate
has at least one unmarked successor; or
\end_layout

\begin_layout Enumerate
its progress measure is less than the maximum of its successors
\end_layout

\end_deeper
\begin_layout Standard
Here, 
\begin_inset Quotes eld
\end_inset

less
\begin_inset Quotes erd
\end_inset

 means less with respect to the priority of the current vertex.
 Eventually, the only vertices that remain marked are those with progress
 measures less than 
\begin_inset Formula $\top$
\end_inset

 which are guaranteed to be stable indefinitely and thus are known to be
 won by Even.
 As a result, we can set the progress measures for these vertices in the
 dual game being solved for Odd to 
\begin_inset Formula $\top$
\end_inset

, avoiding the need to lift these vertices in the dual game to arrive at
 
\begin_inset Formula $\top$
\end_inset

 value.
 The process is then is repeated for player Odd.
\end_layout

\begin_layout Standard
To compute the final set of marked vertices, a similar approach as in the
 main SPM algorithm is used: all vertices are queued, checked against the
 properties mentioned above, and whenever a mark is removed from a vertex,
 its predecessors must be re-examined, so they are queued again.
 The difference with the main SPM algorithm is that a mark can be removed
 only once, which bounds the total processing time to the number of edges
 in the graph.
\end_layout

\begin_layout Standard
If we assume that we tend to examine vertices with average outdegree then
 the main algorithm examines about 
\begin_inset Formula $\left|E\right|$
\end_inset

 vertices before updating the progress measures for both players, which
 ensures the time required to solve a game increases at worst by a constant
 factor (about two or three, presumably).
 Additionally, the algorithm requires up to twice as much memory, because
 progress measures for both players must be kept.
\end_layout

\begin_layout Standard
This may seem like a lot of overhead, but the benefits tend to outweigh
 the additional costs in practice, especially on problems that contain parts
 which are hard to solve from the perspective of one player but easy from
 its opponent's perspective.
 For example, the hard games designed by Jurdziński to require exponential
 time can be solved efficiently this way.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- cite parallel implementation by Michael
\end_layout

\begin_layout Plain Layout
- cite parallel implementaiton on PS3 [mention/cite Jorne Kandziora, Freark
 van den Berg]
\end_layout

\begin_layout Plain Layout
- describe dual version as implemented by Olivier Friedman
\end_layout

\begin_layout Plain Layout
- describe preprocessing passses: removing cycles of odd players/odd priority
 and setting measure to top (partially implemented) + what else?
\end_layout

\begin_layout Plain Layout
(re: removing odd cycles: cite PGSolver&Michael for loops on vertices, credit
 Freark for coming up with a very limited version applied to longer cycles)
\end_layout

\begin_layout Plain Layout
- note that solving time for the two players is usually highly asymmetric,
 which is why the dual method works well, and why it makes sense to try
 to pick the easiest player to solve for first, as the second run will be
 on a smaller graph and then run much faster.
\end_layout

\begin_layout Plain Layout
- dual games
\end_layout

\begin_layout Plain Layout
- describe priority propagation
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Zielonka's Recursive Algorithm
\end_layout

\begin_layout Standard
An entirely different approach to solving parity games arises from a constructiv
e proof of the existince of memoryless strategies by Wiesław Zielonka in
 
\begin_inset CommandInset citation
LatexCommand cite
key "zielonka1998igf"

\end_inset

.
 It is presented solely as a proof, not as an efficient algorithm, but it
 was discovered 
\begin_inset Note Note
status open

\begin_layout Plain Layout
by whom?
\end_layout

\end_inset

 that it works well as an actual solver too.
 It is a proof by induction on the number of different priorities: when
 there is a single priority, the game is trivially solved (this is the basis
 for the induction).
 Then, assuming that we can solve any game with 
\begin_inset Formula $d$
\end_inset

 priorities, we can solve any game with 
\begin_inset Formula $d+1$
\end_inset

 priorities as follows.
\end_layout

\begin_layout Standard
Without loss of generality (using priority compression if necessary) suppose
 we start with a game 
\begin_inset Formula $\Gamma$
\end_inset

 in wich some vertices have priority 0.
 Then, we can compute the attractor set of these vertices for player Even
 (
\begin_inset Formula $U=Attr^{0}(\Gamma,\{v:\,\phi(v)=0\}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
)
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 and its complement 
\begin_inset Formula $V'$
\end_inset

 (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $V'=V\setminus U)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 and call the induced subgame
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\Gamma'$
\end_inset

 (
\begin_inset Formula $\Gamma'=\Gamma|V'$
\end_inset

).
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
Since there are no vertices with priority 
\begin_inset Formula $0$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

'
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 left, it has at most 
\begin_inset Formula $d$
\end_inset

 different priorities and
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 we can invoke the induction hypothesis to solve 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\Gamma'$
\end_inset

, yielding winning sets 
\begin_inset Formula $W'_{0}$
\end_inset

 and 
\begin_inset Formula $W'_{1}$
\end_inset

 and associated strategies.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
At this point, we know that 
\begin_inset Formula $W'_{1}\subseteq W_{1}$
\end_inset

 because 
\begin_inset Formula $V'$
\end_inset

 is a trap for Even in 
\begin_inset Formula $\Gamma$
\end_inset

 and therefore any strategy which works for Odd in 
\begin_inset Formula $\Gamma'$
\end_inset

 is winning in 
\begin_inset Formula $\Gamma$
\end_inset

 too.
 The same does not apply to 
\begin_inset Formula $W_{0}$
\end_inset

, because it is possible that Odd can escape from 
\begin_inset Formula $W_{0}$
\end_inset

 into 
\begin_inset Formula $U$
\end_inset

 as 
\begin_inset Formula $V'$
\end_inset

 is not a trap for Odd.
 Let 
\begin_inset Formula $U'=Attr^{1}(\Gamma,W'_{1})$
\end_inset

 then since 
\begin_inset Formula $V\setminus U'$
\end_inset

 is a trap for Odd, we can solve the subgame 
\begin_inset Formula $\Gamma|(V\setminus U')$
\end_inset

 independently to determine the remainder of the winning sets.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: picture!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We thus repeat the process to solve increasingly smaller subgames, until
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
either 
\begin_inset Formula $U=\emptyset$
\end_inset

 (i.e.
 no vertices with priority 0 remain and we we can invoke the induction hypothesi
s to solve it) or 
\begin_inset Formula $U'=\emptyset$
\end_inset

 (i.e.
 all remaining vertices are won by Even).
 Winning strategies can be constructed along the way by combing the strategies
 obtained recursively with those found by computing attractor sets.
\end_layout

\begin_layout Standard
From the above, it is clear that to solve a game with 
\begin_inset Formula $d$
\end_inset

 priorities, we must recursively call the solver at most 
\begin_inset Formula $V$
\end_inset

 times for a worst-case runtime of 
\begin_inset Formula $O(V^{d})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO:
\end_layout

\begin_layout Plain Layout
real worst case is smaller; need to figure out how small, and if possible
 construct a worst-case example.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- note that McNaughton proposed something similar (when/where?)
\end_layout

\begin_layout Plain Layout
- describe my implementation
\end_layout

\begin_layout Plain Layout
- but finish stuff above first!
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
TODO LIST
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- identify and label lemma's so I can refer to them more easily
\end_layout

\begin_layout Plain Layout
- distinguish more clearly between previous work and stuff I came up with
\end_layout

\begin_layout Plain Layout
- replace x by a different player variable? (Zielonka uses 
\begin_inset Formula $\sigma$
\end_inset

 for players, but Jurdziński uses it for strategies instead)
\begin_inset Newline newline
\end_inset

- have I described everything I came up with?
\end_layout

\begin_layout Plain Layout
- need many more references!
\end_layout

\begin_layout Plain Layout
- should I say `minimum' or `minimal' fixed point?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
