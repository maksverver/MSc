/*! \mainpage

Introduction
============

The Parity Game Solver tool can read parity games in different file formats,
apply various preprocessing operations, solve games with a variety of solver
configurations, optionally verify the obtained solution, and finally write
solution data in various output formats.

The purpose of this page is to provide links to the functions and classes which
are used to implement the functionality of the solver tool, so that new
developers have a starting point for exploring the source code.

Basic data structures and algorithms
====================================

The main data structures used are the StaticGraph class (modeling an immutable
directed graph) and the ParityGame class (which augments the vertices of a game
graph with priority and player information).

Additionally, DenseSet and DenseMap data structures are often used instead of
std::set and std::map when the key set is dense enough to improve performance.

Abortable, Logger and RefCounted are small mix-in classes that add support for
voluntary abortion of long-running computations, multi-level logging, and
reference counting memory management.

Various algorithms depend on the decomposition of a directed graph into Strongly
Connected Components (SCCs). For this purpose Tarjan's algorithm is implemented
iteratively in decompose_graph() using class SCC.


Input formats
=============

Parity games can be obtained from a variety of sources.

@see ParityGame::make_random() generates (uniform or clustered) random games
     (see also StaticGraph::make_random() for generating the game graph).
@see ParityGame::read_pgsolver() reads games from files in PGSolver's plain-text
     file format.
@see ParityGame::read_pbes() generates games from files in mCRL2 PBES
    (Parametrized Boolean Equation Systems) format.  Note: this functionality
    requires compiling and linking with mCRL2.
@see ParityGame::read_raw() reads games from files in the internal (raw) data
    format generated by ParityGame::write_raw().

Output formats
==============

Likewise, a variety of output formats are supported for writing games, winner
and strategy information.

@see ParityGame::write_pgsolver() writes games in PGSolver's plain-text
    file format. (This is mainly useful to convert games generated randomly
    or from PBES to a format that can be processed by other tools.)
@see ParityGame::write_raw() writes games in the internal (raw) file format.
    This is useful to store generated games (e.g. from PBES) so they can be
    reused easily without having to regenerate them from scratch.
@see ParityGame::write_dot() writes the game graphs in Graphviz DOT format,
    which is useful to visualize (small) games.
@see ParityGame::write_debug() writes a plain-text game description whih is more
    readable than PGSolver fromat, and additionally includes winner and strategy
    information (if the game has been solved).  As a non-standard format, it is
    mostly useful for debugging.
@see write_winners() writes the winner for each vertex after solving.
@see write_strategy() writes winning strategies after solving.
@see write_paritysol() writes winner and strategy data in PGSolver plain-text
    solution format (which is also accepted by MLSolver).
@see write_hot_vertices() writes the "hot" vertices in a game (those lifted more
    than a specified number of times by the Small Progress Measures algorithm)
    to Graphvis DOT format.  This is useful to visualize the hotspots in games
    when solved with Small Progress Measures.

Verification
============

After solving a game, the solution may be verified using ParityGame::verify().

Preprocessing
=============

After reading or generating a parity game, various preprocessing operations may
be applied before solving the game.  The simplest ones are implemented as
methods of the ParityGame class:

@see ParityGame::make_dual() converts a game to its dual form.
@see ParityGame::compress_priorities() applies priority compression.
@see ParityGame::propagate_priorities() applies priority propagation.
@see ParityGame::shuffle() reorders vertex indices according to a given
    permutation.

More sophisticated preprocessing operations are implemented as subclasses of the
ParityGameSolver base class.  They are distinguished from the actual solvers by
wrapping another, general solver (passed as an argument to the constructor).
This allows an arbitrary sequence of preprocessing operations to be applied
before finally invoking a general solver.

Rather than instantiating solvers directly in the main() function, solvers
are created indirectly following an abstract factory pattern, with the class
ParityGameSolverFactory providing the base class for solver factory classes.
This allows configuration of the solver pipeline to be separated from
instantiation of actual solvers, which in turn allows solvers to be created
when and where they are needed.

@see DeloopSolver removes winning loops and their attractor set from the
    game before solving the remaining subgame.
@see DecycleSolver removse winner-controlled cycles and their attractor set
    from the game before solving the remaining subgame.
@see ComponentSolver decomposes the game graph into strongly connected
    components which may be solved separately.

Solving
=======

The solver tool supports two main parity game solving algorithms:

 1. RecursiveSolver implements a solution approach based on recursive as well as
    iterative decomposition of the graph due to Zielonka/McNaughton.

 2. SmallProgressMeasuresSolver solves using Small Progress Measures, a
    fixed-point iteration algorithm due to Jurdziński.

The support for Small Progress Measures is most extensive and supports a large
number of variations that may differ in performance in practice.
The core of the algorithm is implemented in the abstract class
SmallProgressMeasures which does not fix any particular data format for storing
progress measure vectors; DenseSPM is the (currently only) concrete subclass 
that represents progress measures as a consecutive array of integers.

The SmallProgressMeasuresSolver offers a choice between using the traditional
algorithm described by Jurdziński (SmallProgressMeasuresSolver::solve_normal())
or the two-sided implementation due to Friedmann (SmallProgressMeasuresSolver::solve_alternate()),
which periodically alternates between solving the game and its dual, exchanging
information about stable vertices between the two.

SmallProgressMeasuresSolver2 is a variant that eliminates the possibility of
failed lifting attempts, which improves performance in practice.  It still
supports both the normal and two-sided approaches, but not the same set of
lifting strategies.

Lifting strategies
------------------

Lifting strategies are heuristics used by the Small Progress Measure solvers to
decide which vertex to lift next.  The choice of lifting strategy influences the
practical performance of the algorithm greatly.  The most useful strategies
implemented are as follows.

\see LinearLiftingStrategy is one of the simplest strategies possible;
    it is very simple, has low overhead, but requires a lot of lifting attempts
    to solve a gam.e
\see PredecessorLiftingStrategy is a strategy that lifts only dirty vertices;
    incurs little overhead and usually performs well in practice (see also
    PredecessorLiftingStrategy2 for SmallProgressMeasuresSolver2).
\see MaxMeasureLiftingStrategy2 is a strategy which tries to reduce lifting
    attempts by propagating larger values first.  Generally this reduces the
    number of lifts required to solve a game, but this comes at the cost of
    incurring more bookkeeping overhead.

For a complete overview of implemented strategies, see the subclasses derived
from LiftingStrategy and LiftingStrategy2.


Multithreading & Distributed computation
========================================

Some of these algorithms have multithreaded and/or distributed implementations
as well.  Generally these are experimental, and currently they seem to offer
only limited performance benefits in practice.

\see ConcurrentRecursiveSolver, an OpenMP-based multithreaded implementation
    of the recursive solver
\see MpiRecursiveSolver, an MPI-based distributed implementation of the
    recursive solver
\see MpiSpmSolver, an MPI-based distributed implementation of Small Progress
    Measures

The MPI-based solvers use Friedemann Mattern's four-counter method for
termination detection, implemented in class MpiTermination.  The MPI-based
recursive solver requires a distributed implementation of the attractor set
computation algorithm too.  Two variants are implemented:

\see SyncMpiAttractorAlgorithm, which implements a strict breadth-first search
where all fringe vertices are expanded on each iteration, synchronizing all
processes in between.
\see AsyncMpiAttractorAlgorithm, which is an asynchronous reachability search
where all processes continue to run until distributed termination has been
detected.

*/