#include "ParityGame.h"
#include <assert.h>
#ifdef WITH_MCRL2
#include <mcrl2/pbes/pbes.h>
#include <mcrl2/pbes/parity_game_generator.h>
#endif

void ParityGame::read_pgsolver( std::istream &is,
                                StaticGraph::EdgeDirection edge_dir )
{
    // Read header line (if present)
    char ch = 0;
    is.get(ch);
    if (isdigit(ch))
    {
        // No header; put character back to parse later
        is.putback(ch);
    }
    else
    {
        // Skip to terminating semicolon
        while (is.get(ch) && ch != ';') ch = 0;
    }

    int max_prio = 0;
    std::vector<ParityGameVertex> vertices;
    StaticGraph::edge_list edges;

    // Read vertex specs
    while (is)
    {
        verti id;
        int prio, player;
        if (!(is >> id >> prio >> player)) break;

        if (prio < 0) prio = 0;
        if (prio > 127) prio = 127;
        if (player < 0) player = 0;
        if (player > 1) player = 1;

        if (prio > max_prio) max_prio = prio;
        if (id >= vertices.size()) vertices.resize(id + 1);
        vertices[id].player   = player;
        vertices[id].priority = prio;

        /* FIXME: the PGSolver file format description requires that we remove
                  existing successor edges (in case a vertex is defined more
                  than once). */

        // Read successors
        do {
            verti succ;
            if (!(is >> succ)) break;
            if (succ >= vertices.size()) vertices.resize(succ + 1);

            edges.push_back(std::make_pair(id, succ));

            // Skip to separator (comma) or end-of-list (semicolon)
            while (is.get(ch) && ch != ',' && ch != ';') ch = 0;

        } while (ch == ',');
    }

    // Assign vertex info and recount cardinalities
    vertex_ = new ParityGameVertex();
    reset((verti)vertices.size(), max_prio + 1);
    for (size_t n = 0; n < vertices.size(); ++n) vertex_[n] = vertices[n];
    vertices.clear();
    recalculate_cardinalities(vertices.size());

    // Assign graph
    graph_.assign(edges, edge_dir);
}

void ParityGame::write_pgsolver(std::ostream &os) const
{
    os << "parity " << graph_.V() - 1 << ";\n";
    for (verti v = 0; v < graph_.V(); ++v)
    {
        os << v << ' ' << priority(v) << ' ' << player(v);
        StaticGraph::const_iterator it  = graph_.succ_begin(v),
                                    end = graph_.succ_end(v);
        assert(it != end);
        os << ' ' << *it++;
        while (it != end) os << ',' << *it++;
        os << ";\n";
    }
}

void ParityGame::read_pbes( const std::string &file_path,
                            StaticGraph::EdgeDirection edge_dir )
{
#ifdef WITH_MCRL2
    /* NOTE: this code assumes the vertices generated by parity_game_generator
             are numbered from 2 to num_vertices-1 with no gaps, with 0 and 1
             representing true and false (respectively) and 2 representing the
             initial condition. */

    mcrl2::pbes_system::pbes<> pbes;
    pbes.load(file_path);  // TODO: handle exceptions raised here?

    // Generate min-priority parity game
    mcrl2::pbes_system::parity_game_generator pgg(pbes, true, true);

    // Build the edge list
    StaticGraph::edge_list edges;
    verti num_vertices = 3;
    for (verti v = 2; v < num_vertices; ++v)
    {
        std::set<unsigned> deps = pgg.get_dependencies(v);
        for ( std::set<unsigned>::const_iterator it = deps.begin();
              it != deps.end(); ++it )
        {
            verti w = (verti)*it;
            assert(w >= 2);
            if (w >= num_vertices) num_vertices = w + 1;
            edges.push_back(std::make_pair(v - 2, w - 2));
        }
    }

    // Determine maximum prioirity
    int max_prio = 0;
    for (verti v = 2; v < num_vertices; ++v)
    {
        max_prio = std::max(max_prio, (int)pgg.get_priority(v));
    }

    // Assign vertex info and recount cardinalities
    reset(num_vertices - 2, max_prio + 1);
    for (verti v = 2; v < num_vertices; ++v)
    {
        bool and_op = pgg.get_operation(v) ==
                      mcrl2::pbes_system::parity_game_generator::PGAME_AND;
        vertex_[v - 2].player = and_op ? PLAYER_ODD : PLAYER_EVEN;
        vertex_[v - 2].priority = pgg.get_priority(v);
    }
    recalculate_cardinalities(num_vertices - 2);

    // Assign graph
    graph_.assign(edges, edge_dir);
#else /* ifdef WITH_MCRL2 */
    assert(0);
#endif /* def WITH_MCRL2 */
}

void ParityGame::read_raw(std::istream &is)
{
    graph_.read_raw(is);
    assert(is.good());
    int d;
    is.read((char*)&d, sizeof(d));
    reset(graph_.V(), d);
    is.read((char*)vertex_, sizeof(ParityGameVertex)*graph_.V());
    is.read((char*)cardinality_, sizeof(verti)*d);
}

void ParityGame::write_raw(std::ostream &os) const
{
    graph_.write_raw(os);
    assert(os.good());
    os.write((const char*)&d_, sizeof(d_));
    os.write((const char*)vertex_, sizeof(ParityGameVertex)*graph_.V());
    os.write((const char*)cardinality_, sizeof(verti)*d_);
}

void ParityGame::write_dot(std::ostream &os) const
{
    os << "digraph {\n";
    for (verti v = 0; v < graph_.V(); ++v)
    {
        bool even = player(v) == ParityGame::PLAYER_EVEN;
        os << v << " ["
           << "shape=" << (even ? "diamond" : "box") << ", "
           << "label=\"" << priority(v) << " (" << v << ")\"]\n";

        if (graph_.edge_dir() & StaticGraph::EDGE_SUCCESSOR)
        {
            for ( StaticGraph::const_iterator it = graph_.succ_begin(v);
                  it != graph_.succ_end(v); ++it )
            {
                os << v << " -> " << *it << ";\n";
            }
        }
        else
        {
            for ( StaticGraph::const_iterator it = graph_.pred_begin(v);
                  it != graph_.pred_end(v); ++it )
            {
                os << *it << " -> " << v << ";\n";
            }
        }
    }
    os << "}\n";
}
